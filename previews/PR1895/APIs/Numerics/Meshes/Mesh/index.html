<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Meshes · ClimateMachine</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.svg" alt="ClimateMachine logo"/></a><div class="docs-package-name"><span class="docs-autofit">ClimateMachine</span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../GettingStarted/Installation/">Installation</a></li><li><a class="tocitem" href="../../../../GettingStarted/Terminology/">Terminology</a></li><li><a class="tocitem" href="../../../../GettingStarted/RunningClimateMachine/">Running</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Defaults</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../GettingStarted/Atmos/">Atmosphere model configurations</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/TutorialList/">Home</a></li><li><a class="tocitem" href="../../../../generated/how_to_make_a_balance_law/">Balance Law</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Atmos/heldsuarez/">Dry Idealized GCM (Held-Suarez)</a></li><li><a class="tocitem" href="../../../../generated/Atmos/burgers_single_stack/">Single Element Stack Experiment (Burgers Equation)</a></li><li><a class="tocitem" href="../../../../generated/Atmos/densitycurrent/">LES Experiment (Density Current)</a></li><li><a class="tocitem" href="../../../../generated/Atmos/risingbubble/">LES Experiment (Rising Thermal Bubble)</a></li><li><a class="tocitem" href="../../../../generated/Atmos/agnesi_hs_lin/">Linear Hydrostatic Mountain (Topography)</a></li><li><a class="tocitem" href="../../../../generated/Atmos/agnesi_nh_lin/">Linear Non-Hydrostatic Mountain (Topography)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Land</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-4-1" type="checkbox"/><label class="tocitem" for="menuitem-3-4-1"><span class="docs-label">Heat</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Land/Heat/heat_equation/">Heat Equation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4-2" type="checkbox"/><label class="tocitem" for="menuitem-3-4-2"><span class="docs-label">Soil</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Land/Soil/Water/hydraulic_functions/">Hydraulic Functions</a></li><li><a class="tocitem" href="../../../../generated/Land/Soil/Heat/bonan_heat_tutorial/">Soil Heat Equation</a></li><li><a class="tocitem" href="../../../../generated/Land/Soil/Water/equilibrium_test/">Richards Equation</a></li><li><a class="tocitem" href="../../../../generated/Land/Soil/Coupled/equilibrium_test/">Coupled Water and Heat</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Ocean</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Ocean/geostrophic_adjustment/">One-dimensional geostrophic adjustment</a></li><li><a class="tocitem" href="../../../../generated/Ocean/internal_wave/">Propagating mode-1 internal wave</a></li><li><a class="tocitem" href="../../../../generated/Ocean/shear_instability/">Shear instability</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6" type="checkbox"/><label class="tocitem" for="menuitem-3-6"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-6-1" type="checkbox"/><label class="tocitem" for="menuitem-3-6-1"><span class="docs-label">System Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Numerics/SystemSolvers/cg/">Conjugate Gradient</a></li><li><a class="tocitem" href="../../../../generated/Numerics/SystemSolvers/bgmres/">Batched Generalized Minimal Residual</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-6-2" type="checkbox"/><label class="tocitem" for="menuitem-3-6-2"><span class="docs-label">DG Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Numerics/DGMethods/showcase_filters/">Filters</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-7-1" type="checkbox"/><label class="tocitem" for="menuitem-3-7-1"><span class="docs-label">Debug</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Diagnostics/Debug/StateCheck/">State Statistics Regression</a></li></ul></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to-guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Common/Thermodynamics/">Thermodynamics</a></li><li><a class="tocitem" href="../../../../HowToGuides/Common/UniversalFunctions/">Universal Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Atmos/TemperatureProfiles/">Temperature profiles</a></li><li><a class="tocitem" href="../../../../HowToGuides/Atmos/AtmosReferenceState/">Reference profiles</a></li><li><a class="tocitem" href="../../../../HowToGuides/Atmos/MoistureModelChoices/">Moisture model</a></li><li><a class="tocitem" href="../../../../HowToGuides/Atmos/PrecipitationModelChoices/">Precipitation model</a></li><li><a class="tocitem" href="../../../../HowToGuides/Atmos/MoistureAndPrecip/">How to create an experiment with moisture and precipitation</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><span class="tocitem">Land</span></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><span class="tocitem">Meshes</span></li><li><input class="collapse-toggle" id="menuitem-4-5-2" type="checkbox"/><label class="tocitem" for="menuitem-4-5-2"><span class="docs-label">DG methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/">How to make a balance law</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5-3" type="checkbox"/><label class="tocitem" for="menuitem-4-5-3"><span class="docs-label">ODE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Numerics/ODESolvers/Timestepping/">Time-integration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5-4" type="checkbox"/><label class="tocitem" for="menuitem-4-5-4"><span class="docs-label">System Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Numerics/SystemSolvers/IterativeSolvers/">Iterative Solvers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Diagnostics/UsingDiagnostics/">Using Diagnostics</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">APIs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Driver</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Driver/">Top level interface</a></li><li><a class="tocitem" href="../../../Driver/Checkpoint/">Checkpoint</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../Atmos/Microphysics_0M/">Microphysics_0M</a></li><li><a class="tocitem" href="../../../Atmos/Microphysics/">Microphysics</a></li><li><a class="tocitem" href="../../../Atmos/TemperatureProfiles/">Temperature Profiles</a></li></ul></li><li><a class="tocitem" href="../../../Ocean/Ocean/">Ocean</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Land</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Land/LandModel/">Land Model</a></li><li><a class="tocitem" href="../../../Land/Runoff/">Runoff Parameterizations</a></li><li><a class="tocitem" href="../../../Land/SoilWaterParameterizations/">Soil Water Parameterizations</a></li><li><a class="tocitem" href="../../../Land/SoilHeatParameterizations/">Soil Heat Parameterizations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Common/Orientations/">Orientations</a></li><li><a class="tocitem" href="../../../Common/Spectra/">Spectra</a></li><li><a class="tocitem" href="../../../Common/SurfaceFluxes/">Surface Fluxes</a></li><li><a class="tocitem" href="../../../Common/Thermodynamics/">Thermodynamics</a></li><li><a class="tocitem" href="../../../Common/TurbulenceClosures/">Turbulence Closures</a></li><li><a class="tocitem" href="../../../Common/TurbulenceConvection/">Turbulence Convection</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Balance Laws</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../BalanceLaws/BalanceLaws/">Balance Laws</a></li><li><a class="tocitem" href="../../../BalanceLaws/Problems/">Problems</a></li></ul></li><li><a class="tocitem" href="../../../Arrays/Arrays/">Arrays</a></li><li><input class="collapse-toggle" id="menuitem-5-9" type="checkbox"/><label class="tocitem" for="menuitem-5-9"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Diagnostics/Diagnostics/">Diagnostics groups</a></li><li><a class="tocitem" href="../../../Diagnostics/StateCheck/">State Check</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-10" type="checkbox"/><label class="tocitem" for="menuitem-5-10"><span class="docs-label">Input/Output</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../InputOutput/">Input/Output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-11" type="checkbox" checked/><label class="tocitem" for="menuitem-5-11"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Meshes</a><ul class="internal"><li><a class="tocitem" href="#Topologies"><span>Topologies</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Brick-Mesh"><span>Brick Mesh</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Filters"><span>Filters</span></a></li><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li></ul></li><li><a class="tocitem" href="../../SystemSolvers/SystemSolvers/">SystemSolvers</a></li><li><a class="tocitem" href="../../ODESolvers/ODESolvers/">ODESolvers</a></li><li><a class="tocitem" href="../../DGMethods/DGMethods/">DG Methods</a></li><li><a class="tocitem" href="../../DGMethods/Courant/">Courant</a></li><li><a class="tocitem" href="../../DGMethods/NumericalFluxes/">Numerical Fluxes</a></li><li><a class="tocitem" href="../../DGMethods/FVReconstructions/">Finite Volume Reconstructions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-12" type="checkbox"/><label class="tocitem" for="menuitem-5-12"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Utilities/VariableTemplates/">Variable Templates</a></li><li><a class="tocitem" href="../../../Utilities/SingleStackUtils/">Single Stack Utilities</a></li><li><a class="tocitem" href="../../../Utilities/TicToc/">Tic Toc</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../../Contributing/">Contribution guide</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Theory/Common/SurfaceFluxes/">SurfaceFluxes</a></li><li><a class="tocitem" href="../../../../Theory/Common/Turbulence/">Turbulence Closures</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Theory/Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/EDMF_plots/">EDMF Model</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/Microphysics_0M/">Microphysics_0M</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/Microphysics/">Microphysics</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/EDMFEquations/">EDMF equations</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/Model/tracers/">Tracers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../DevDocs/CodeStyle/">Coding style</a></li><li><a class="tocitem" href="../../../../DevDocs/AcceptableUnicode/">Acceptable Unicode</a></li><li><a class="tocitem" href="../../../../DevDocs/ModelVariableList/">Model variable list</a></li><li><a class="tocitem" href="../../../../DevDocs/ModelOutput/">Model output</a></li><li><a class="tocitem" href="../../../../DevDocs/DiagnosticVariableList/">Diagnostic variable list</a></li><li><a class="tocitem" href="../../../../DevDocs/SystemImage/">Custom System Image</a></li></ul></li><li><a class="tocitem" href="../../../../References/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">APIs</a></li><li><a class="is-disabled">Numerics</a></li><li class="is-active"><a href>Meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Meshes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Clima/ClimateMachine.jl/blob/master/docs/src/APIs/Numerics/Meshes/Mesh.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Meshing-Stuff"><a class="docs-heading-anchor" href="#Meshing-Stuff">Meshing Stuff</a><a id="Meshing-Stuff-1"></a><a class="docs-heading-anchor-permalink" href="#Meshing-Stuff" title="Permalink"></a></h1><h2 id="Topologies"><a class="docs-heading-anchor" href="#Topologies">Topologies</a><a id="Topologies-1"></a><a class="docs-heading-anchor-permalink" href="#Topologies" title="Permalink"></a></h2><p>Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.</p><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.AbstractTopology" href="#ClimateMachine.Mesh.Topologies.AbstractTopology"><code>ClimateMachine.Mesh.Topologies.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTopology{dim, T, nb}</code></pre><p>Represents the connectivity of individual elements, with local dimension <code>dim</code> with <code>nb</code> boundary conditions types. The element coordinates are of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.BoxElementTopology" href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>ClimateMachine.Mesh.Topologies.BoxElementTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoxElementTopology{dim, T, nb} &lt;: AbstractTopology{dim,T,nb}</code></pre><p>The local topology of a larger MPI-distributed topology, represented by <code>dim</code>-dimensional box elements, with <code>nb</code> boundary conditions.</p><p>This contains the necessary information for the connectivity elements of the elements on the local process, along with &quot;ghost&quot; elements from neighbouring processes.</p><p><strong>Fields</strong></p><ul><li><p><code>mpicomm</code></p><p>MPI communicator for communicating with neighbouring processes.</p></li></ul><ul><li><p><code>elems</code></p><p>Range of element indices</p></li></ul><ul><li><p><code>realelems</code></p><p>Range of real (aka nonghost) element indices</p></li></ul><ul><li><p><code>ghostelems</code></p><p>Range of ghost element indices</p></li></ul><ul><li><p><code>ghostfaces</code></p><p>Ghost element to face is received; <code>ghostfaces[f,ge] == true</code> if face <code>f</code> of ghost element <code>ge</code> is received.</p></li></ul><ul><li><p><code>sendelems</code></p><p>Array of send element indices</p></li></ul><ul><li><p><code>sendfaces</code></p><p>Send element to face is sent; <code>sendfaces[f,se] == true</code> if face <code>f</code> of send element <code>se</code> is sent.</p></li></ul><ul><li><p><code>interiorelems</code></p><p>Array of real elements that do not have a ghost element as a neighbor.</p></li></ul><ul><li><p><code>exteriorelems</code></p><p>Array of real elements that have at least on ghost element as a neighbor.</p><p>Note that this is different from <code>sendelems</code> because <code>sendelems</code> duplicates elements that need to be sent to multiple neighboring processes.</p></li></ul><ul><li><p><code>elemtocoord</code></p><p>Element to vertex coordinates; <code>elemtocoord[d,i,e]</code> is the <code>d</code>th coordinate of corner <code>i</code> of element <code>e</code></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>currently coordinates always are of size 3 for <code>(x1, x2, x3)</code></p></div></div></li></ul><ul><li><p><code>elemtoelem</code></p><p>Element to neighboring element; <code>elemtoelem[f,e]</code> is the number of the element neighboring element <code>e</code> across face <code>f</code>. If it is a boundary face, then it is the boundary element index.</p></li></ul><ul><li><p><code>elemtoface</code></p><p>Element to neighboring element face; <code>elemtoface[f,e]</code> is the face number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoface[f,e] == f</code>.&quot;</p></li></ul><ul><li><p><code>elemtoordr</code></p><p>element to neighboring element order; <code>elemtoordr[f,e]</code> is the ordering number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoordr[f,e] == 1</code>.</p></li></ul><ul><li><p><code>elemtobndy</code></p><p>Element to boundary number; <code>elemtobndy[f,e]</code> is the boundary number of face <code>f</code> of element <code>e</code>.  If there is a neighboring element then <code>elemtobndy[f,e] == 0</code>.</p></li></ul><ul><li><p><code>nabrtorank</code></p><p>List of the MPI ranks for the neighboring processes</p></li></ul><ul><li><p><code>nabrtorecv</code></p><p>Range in ghost elements to receive for each neighbor</p></li></ul><ul><li><p><code>nabrtosend</code></p><p>Range in <code>sendelems</code> to send for each neighbor</p></li></ul><ul><li><p><code>origsendorder</code></p><p>original order in partitioning</p></li></ul><ul><li><p><code>bndytoelem</code></p><p>Tuple of boundary to element. <code>bndytoelem[b][i]</code> is the element which faces the <code>i</code>th boundary element of boundary <code>b</code>.</p></li></ul><ul><li><p><code>bndytoface</code></p><p>Tuple of boundary to element face. <code>bndytoface[b][i]</code> is the face number of the element which faces the <code>i</code>th boundary element of boundary <code>b</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L27-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.BrickTopology" href="#ClimateMachine.Mesh.Topologies.BrickTopology"><code>ClimateMachine.Mesh.Topologies.BrickTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BrickTopology{dim, T, nb} &lt;: AbstractTopology{dim, T, nb}</code></pre><p>A simple grid-based topology. This is a convenience wrapper around <a href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L226-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.StackedBrickTopology" href="#ClimateMachine.Mesh.Topologies.StackedBrickTopology"><code>ClimateMachine.Mesh.Topologies.StackedBrickTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StackedBrickTopology{dim, T, nb} &lt;: AbstractStackedTopology{dim}</code></pre><p>A simple grid-based topology, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around <a href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L254-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.CubedShellTopology" href="#ClimateMachine.Mesh.Topologies.CubedShellTopology"><code>ClimateMachine.Mesh.Topologies.CubedShellTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CubedShellTopology{T} &lt;: AbstractTopology{2, T, 0}</code></pre><p>A cube-shell topology. This is a convenience wrapper around <a href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L238-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology" href="#ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology"><code>ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StackedCubedSphereTopology{T, nb} &lt;: AbstractStackedTopology{3, T, nb}</code></pre><p>A cube-sphere topology. All elements on the same &quot;vertical&quot; dimension are stacked to be contiguous. This is a convenience wrapper around <a href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L271-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.SingleExponentialStretching" href="#ClimateMachine.Mesh.Topologies.SingleExponentialStretching"><code>ClimateMachine.Mesh.Topologies.SingleExponentialStretching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingleExponentialStretching(A)</code></pre><p>Apply single-exponential stretching: <code>A &gt; 0</code> will increase the density of points at the lower boundary, <code>A &lt; 0</code> will increase the density at the upper boundary.</p><p><strong>Reference</strong></p><ul><li>&quot;Handbook of Grid Generation&quot; J. F. Thompson, B. K. Soni, N. P. Weatherill (Editors) RCR Press 1999, §3.6.1 Single-Exponential Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L1298-L1307">source</a></section></article><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.BrickTopology-Tuple{Any,Any}" href="#ClimateMachine.Mesh.Topologies.BrickTopology-Tuple{Any,Any}"><code>ClimateMachine.Mesh.Topologies.BrickTopology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)</code></pre><p>Generate a brick mesh topology with coordinates given by the tuple <code>elemrange</code> and the periodic dimensions given by the <code>periodicity</code> tuple.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x2$</span>-direction with</p><pre><code class="language-julia">
using ClimateMachine.Topologies
using MPI
MPI.Init()
topology = BrickTopology(MPI.COMM_SELF, (2:5,4:6);
                         periodicity=(false,true),
                         boundary=((1,2),(3,4)))</code></pre><p>This returns the mesh structure for</p><pre><code class="language-none">         x2

          ^
          |
         6-  +-----+-----+-----+
          |  |     |     |     |
          |  |  3  |  4  |  5  |
          |  |     |     |     |
         5-  +-----+-----+-----+
          |  |     |     |     |
          |  |  1  |  2  |  6  |
          |  |     |     |     |
         4-  +-----+-----+-----+
          |
          +--|-----|-----|-----|--&gt; x1
             2     3     4     5</code></pre><p>For example, the (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtocoord
2×4×6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 3  4  3  4
 4  4  5  5

[:, :, 3] =
 2  3  2  3
 5  5  6  6

[:, :, 4] =
 3  4  3  4
 5  5  6  6

[:, :, 5] =
 4  5  4  5
 5  5  6  6

[:, :, 6] =
 4  5  4  5
 4  4  5  5</code></pre><p>Note that the corners are listed in Cartesian order.</p><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtobndy
4×6 Array{Int64,2}:
 1  0  1  0  0  0
 0  0  0  0  2  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L295-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}" href="#ClimateMachine.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}"><code>ClimateMachine.Mesh.Topologies.StackedBrickTopology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">StackedBrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)</code></pre><p>Generate a stacked brick mesh topology with coordinates given by the tuple <code>elemrange</code> and the periodic dimensions given by the <code>periodicity</code> tuple.</p><p>The elements are stacked such that the elements associated with range <code>elemrange[dim]</code> are contiguous in the element ordering.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.  Further, stacks are not split at MPI boundaries.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x2$</span>-direction with</p><pre><code class="language-julia">
using ClimateMachine.Topologies
using MPI
MPI.Init()
topology = StackedBrickTopology(MPI.COMM_SELF, (2:5,4:6);
                                periodicity=(false,true),
                                boundary=((1,2),(3,4)))</code></pre><p>This returns the mesh structure stacked in the <span>$x2$</span>-direction for</p><pre><code class="language-none">         x2

          ^
          |
         6-  +-----+-----+-----+
          |  |     |     |     |
          |  |  2  |  4  |  6  |
          |  |     |     |     |
         5-  +-----+-----+-----+
          |  |     |     |     |
          |  |  1  |  3  |  5  |
          |  |     |     |     |
         4-  +-----+-----+-----+
          |
          +--|-----|-----|-----|--&gt; x1
             2     3     4     5</code></pre><p>For example, the (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtocoord
2×4×6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 2  3  2  3
 5  5  6  6

[:, :, 3] =
 3  4  3  4
 4  4  5  5

[:, :, 4] =
 3  4  3  4
 5  5  6  6

[:, :, 5] =
 4  5  4  5
 4  4  5  5

[:, :, 6] =
 4  5  4  5
 5  5  6  6</code></pre><p>Note that the corners are listed in Cartesian order.</p><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtobndy
4×6 Array{Int64,2}:
 1  0  1  0  0  0
 0  0  0  0  2  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L453-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}" href="#ClimateMachine.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}"><code>ClimateMachine.Mesh.Topologies.CubedShellTopology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CubedShellTopology(mpicomm, Nelem, T) &lt;: AbstractTopology{dim,T,nb}</code></pre><p>Generate a cubed shell mesh with the number of elements along each dimension of the cubes being <code>Nelem</code>. This topology actual creates a cube mesh, and the warping should be done after the grid is created using the <code>cubedshellwarp</code> function. The coordinates of the points will be of type <code>T</code>.</p><p>The elements of the shell are partitioned equally across the MPI ranks based on a space-filling curve.</p><p>Note that this topology is logically 2-D but embedded in a 3-D space</p><p><strong>Examples</strong></p><p>We can build a cubed shell mesh with 10 elements on each cube, total elements is <code>10 * 10 * 6 = 600</code>, with</p><pre><code class="language-julia">using ClimateMachine.Topologies
using MPI
MPI.Init()
topology = CubedShellTopology(MPI.COMM_SELF, 10, Float64)

# Typically the warping would be done after the grid is created, but the cell
# corners could be warped with...

# Shell radius = 1
x1, x2, x3 = ntuple(j-&gt;topology.elemtocoord[j, :, :], 3)
for n = 1:length(x1)
   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])
end

# Shell radius = 10
x1, x2, x3 = ntuple(j-&gt;topology.elemtocoord[j, :, :], 3)
for n = 1:length(x1)
  x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n], 10)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L752-L790">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}" href="#ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}"><code>ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology</code></a> — <span class="docstring-category">Method</span></header><section><div><p>StackedCubedSphereTopology(mpicomm, Nhorz, Rrange;                               boundary=(1,1)) &lt;: AbstractTopology{3}</p><p>Generate a stacked cubed sphere topology with <code>Nhorz</code> by <code>Nhorz</code> cells for each horizontal face and <code>Rrange</code> is the radius edges of the stacked elements.  This topology actual creates a cube mesh, and the warping should be done after the grid is created using the <code>cubedshellwarp</code> function. The coordinates of the points will be of type <code>eltype(Rrange)</code>. The inner boundary condition type is <code>boundary[1]</code> and the outer boundary condition type is <code>boundary[2]</code>.</p><p>The elements are stacked such that the vertical elements are contiguous in the element ordering.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve. Further, stacks are not split at MPI boundaries.</p><p><strong>Examples</strong></p><p>We can build a cubed sphere mesh with 10 x 10 x 5 elements on each cube, total elements is <code>10 * 10 * 5 * 6 = 3000</code>, with</p><pre><code class="language-julia">using ClimateMachine.Topologies
using MPI
MPI.Init()
Nhorz = 10
Nstack = 5
Rrange = Float64.(accumulate(+,1:Nstack+1))
topology = StackedCubedSphereTopology(MPI.COMM_SELF, Nhorz, Rrange)

x1, x2, x3 = ntuple(j-&gt;reshape(topology.elemtocoord[j, :, :],
                            2, 2, 2, length(topology.elems)), 3)
for n = 1:length(x1)
   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])
end</code></pre><p>Note that the faces are listed in Cartesian order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L1040-L1077">source</a></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.cubedshellmesh" href="#ClimateMachine.Mesh.Topologies.cubedshellmesh"><code>ClimateMachine.Mesh.Topologies.cubedshellmesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cubedshellmesh(T, Ne; part=1, numparts=1)</code></pre><p>Generate a cubed mesh with each of the &quot;cubes&quot; has an <code>Ne X Ne</code> grid of elements.</p><p>The mesh can optionally be partitioned into <code>numparts</code> and this returns partition <code>part</code>.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.</p><p>This mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.</p><p>The mesh structures for the cubes is as follows:</p><pre><code class="language-none">x2
   ^
   |
4Ne-           +-------+
   |           |       |
   |           |   6   |
   |           |       |
3Ne-           +-------+
   |           |       |
   |           |   5   |
   |           |       |
2Ne-           +-------+
   |           |       |
   |           |   4   |
   |           |       |
 Ne-   +-------+-------+-------+
   |   |       |       |       |
   |   |   1   |   2   |   3   |
   |   |       |       |       |
  0-   +-------+-------+-------+
   |
   +---|-------|-------|------|-&gt; x1
       0      Ne      2Ne    3Ne</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L855-L897">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.cubedshellwarp" href="#ClimateMachine.Mesh.Topologies.cubedshellwarp"><code>ClimateMachine.Mesh.Topologies.cubedshellwarp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))</code></pre><p>Given points <code>(a, b, c)</code> on the surface of a cube, warp the points out to a spherical shell of radius <code>R</code> based on the equiangular gnomonic grid proposed by <a href="../../../../References/#Ronchi1996">C. Ronchi , R. Iacono , P. S. Paolucci  (1996)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L957-L963">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.hasboundary" href="#ClimateMachine.Mesh.Topologies.hasboundary"><code>ClimateMachine.Mesh.Topologies.hasboundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasboundary(topology::AbstractTopology)</code></pre><p>query function to check whether a topology has a boundary (i.e., not fully periodic)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.cubedshellunwarp" href="#ClimateMachine.Mesh.Topologies.cubedshellunwarp"><code>ClimateMachine.Mesh.Topologies.cubedshellunwarp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cubedshellunwarp(x1, x2, x3)</code></pre><p>The inverse of <a href="#ClimateMachine.Mesh.Topologies.cubedshellwarp"><code>cubedshellwarp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L999-L1003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.grid1d" href="#ClimateMachine.Mesh.Topologies.grid1d"><code>ClimateMachine.Mesh.Topologies.grid1d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grid1d(a, b[, stretch::AbstractGridStretching]; elemsize, nelem)</code></pre><p>Discretize the 1D interval [<code>a</code>,<code>b</code>] into elements. Exactly one of the following keyword arguments must be provided:</p><ul><li><code>elemsize</code>: the average element size, or</li><li><code>nelem</code>: the number of elements.</li></ul><p>The optional <code>stretch</code> argument allows stretching, otherwise the element sizes will be uniform.</p><p>Returns either a range object or a vector containing the element boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Topologies.jl#L1270-L1282">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Geometry.LocalGeometry" href="#ClimateMachine.Mesh.Geometry.LocalGeometry"><code>ClimateMachine.Mesh.Geometry.LocalGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LocalGeometry</code></pre><p>The local geometry at a nodal point.</p><p><strong>Constructors</strong></p><pre><code class="language-none">LocalGeometry{Np, N}(vgeo::AbstractArray{T}, n::Integer, e::Integer)</code></pre><p>Extracts a <code>LocalGeometry</code> object from the <code>vgeo</code> array at node <code>n</code> in element <code>e</code> with <code>Np</code> being the number of points in the element and <code>N</code> being the polynomial order</p><p><strong>Fields</strong></p><ul><li><p><code>polyorder</code></p><p>polynomial order of the element</p></li><li><p><code>coord</code></p><p>local degree of freedom Cartesian coordinate </p></li><li><p><code>invJ</code></p><p>Jacobian from Cartesian to element coordinates: <code>invJ[i,j]</code> is <span>$∂ξ_i / ∂x_j$</span></p></li></ul><ul><li><p><code>vgeo</code></p><p>Global volume geometry array</p></li><li><p><code>n</code></p><p>element local linear node index</p></li><li><p><code>e</code></p><p>process local element index</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Geometry.jl#L24-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Geometry.lengthscale" href="#ClimateMachine.Mesh.Geometry.lengthscale"><code>ClimateMachine.Mesh.Geometry.lengthscale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lengthscale(g::LocalGeometry)</code></pre><p>The effective grid resolution at the point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Geometry.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Geometry.resolutionmetric" href="#ClimateMachine.Mesh.Geometry.resolutionmetric"><code>ClimateMachine.Mesh.Geometry.resolutionmetric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resolutionmetric(g::LocalGeometry)</code></pre><p>The metric tensor of the discretisation resolution. Given a unit vector <code>u</code> in Cartesian coordinates and <code>M = resolutionmetric(g)</code>, <code>sqrt(u&#39;*M*u)</code> is the degree-of-freedom density in the direction of <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Geometry.jl#L104-L110">source</a></section></article><h2 id="Brick-Mesh"><a class="docs-heading-anchor" href="#Brick-Mesh">Brick Mesh</a><a id="Brick-Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Brick-Mesh" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.BrickMesh.partition" href="#ClimateMachine.Mesh.BrickMesh.partition"><code>ClimateMachine.Mesh.BrickMesh.partition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partition(comm::MPI.Comm, elemtovert, elemtocoord, elemtobndy,
          faceconnections)</code></pre><p>This function takes in a mesh (as returned for example by <code>brickmesh</code>) and returns a Hilbert curve based partitioned mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/BrickMesh.jl#L524-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.BrickMesh.brickmesh" href="#ClimateMachine.Mesh.BrickMesh.brickmesh"><code>ClimateMachine.Mesh.BrickMesh.brickmesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">brickmesh(x, periodic; part=1, numparts=1; boundary)</code></pre><p>Generate a brick mesh with coordinates given by the tuple <code>x</code> and the periodic dimensions given by the <code>periodic</code> tuple.</p><p>The brick can optionally be partitioned into <code>numparts</code> and this returns partition <code>part</code>.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x_2$</span>-direction with</p><pre><code class="language-julia-repl">julia&gt; (elemtovert, elemtocoord, elemtobndy, faceconnections) =
        brickmesh((2:5,4:6), (false,true); boundary=((1,2), (3,4)));</code></pre><p>This returns the mesh structure for</p><pre><code class="language-none">         x_2

          ^
          |
         6-  9----10----11----12
          |  |     |     |     |
          |  |  4  |  5  |  6  |
          |  |     |     |     |
         5-  5-----6-----7-----8
          |  |     |     |     |
          |  |  1  |  2  |  3  |
          |  |     |     |     |
         4-  1-----2-----3-----4
          |
          +--|-----|-----|-----|--&gt; x_1
             2     3     4     5</code></pre><p>The (number of corners by number of elements) array <code>elemtovert</code> gives the global vertex number for the corners of each element.</p><pre><code class="language-julia-repl">julia&gt; elemtovert
4×6 Array{Int64,2}:
 1  2  3   5   6   7
 2  3  4   6   7   8
 5  6  7   9  10  11
 6  7  8  10  11  12</code></pre><p>Note that the vertices are listed in Cartesian order.</p><p>The (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-jldoctes">julia&gt; elemtocoord
2×4×6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 3  4  3  4
 4  4  5  5

[:, :, 3] =
 4  5  4  5
 4  4  5  5

[:, :, 4] =
 2  3  2  3
 5  5  6  6

[:, :, 5] =
 3  4  3  4
 5  5  6  6

[:, :, 6] =
 4  5  4  5
 5  5  6  6</code></pre><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; elemtobndy
4×6 Array{Int64,2}:
 1  0  0  1  0  0
 0  0  2  0  0  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p><p>Finally, the periodic face connections are given in <code>faceconnections</code> which is a list of arrays, one for each connection. Each array in the list is given in the format <code>[e, f, vs...]</code> where</p><ul><li><code>e</code>  is the element number;</li><li><code>f</code>  is the face number; and</li><li><code>vs</code> is the global vertices that face associated with.</li></ul><p>I the example</p><pre><code class="language-julia-repl">julia&gt; faceconnections
3-element Array{Array{Int64,1},1}:
 [4, 4, 1, 2]
 [5, 4, 2, 3]
 [6, 4, 3, 4]</code></pre><p>we see that face <code>4</code> of element <code>5</code> is associated with vertices <code>[2 3]</code> (the vertices for face <code>1</code> of element <code>2</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/BrickMesh.jl#L157-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.BrickMesh.connectmesh" href="#ClimateMachine.Mesh.BrickMesh.connectmesh"><code>ClimateMachine.Mesh.BrickMesh.connectmesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">connectmesh(comm::MPI.Comm, elemtovert, elemtocoord, elemtobndy,
            faceconnections)</code></pre><p>This function takes in a mesh (as returned for example by <code>brickmesh</code>) and returns a connected mesh.  This returns a <code>NamedTuple</code> of:</p><ul><li><code>elems</code> the range of element indices</li><li><code>realelems</code> the range of real (aka nonghost) element indices</li><li><code>ghostelems</code> the range of ghost element indices</li><li><code>ghostfaces</code> ghost element to face is received; <code>ghostfaces[f,ge] == true</code> if face <code>f</code> of ghost element <code>ge</code> is received.</li><li><code>sendelems</code> an array of send element indices</li><li><code>sendfaces</code> send element to face is sent; <code>sendfaces[f,se] == true</code> if face <code>f</code> of send element <code>se</code> is sent.</li><li><code>elemtocoord</code> element to vertex coordinates; <code>elemtocoord[d,i,e]</code> is the  <code>d</code>th coordinate of corner <code>i</code> of element <code>e</code></li><li><code>elemtoelem</code> element to neighboring element; <code>elemtoelem[f,e]</code> is the number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoelem[f,e] == e</code>.</li><li><code>elemtoface</code> element to neighboring element face; <code>elemtoface[f,e]</code> is the face number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoface[f,e] == f</code>.</li><li><code>elemtoordr</code> element to neighboring element order; <code>elemtoordr[f,e]</code> is the ordering number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoordr[f,e] == 1</code>.</li><li><code>elemtobndy</code> element to bounday number; <code>elemtobndy[f,e]</code> is the boundary number of face <code>f</code> of element <code>e</code>.  If there is a neighboring element then <code>elemtobndy[f,e] == 0</code>.</li><li><code>nabrtorank</code> a list of the MPI ranks for the neighboring processes</li><li><code>nabrtorecv</code> a range in ghost elements to receive for each neighbor</li><li><code>nabrtosend</code> a range in <code>sendelems</code> to send for each neighbor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/BrickMesh.jl#L793-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.BrickMesh.centroidtocode" href="#ClimateMachine.Mesh.BrickMesh.centroidtocode"><code>ClimateMachine.Mesh.BrickMesh.centroidtocode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">centroidtocode(comm::MPI.Comm, elemtocorner; coortocode, CT)</code></pre><p>Returns a code for each element based on its centroid.</p><p>These element codes can be used to determine a linear ordering for the partition function.</p><p>The communicator <code>comm</code> is used to calculate the bounding box for representing the centroids in coordinates of type <code>CT</code>, defaulting to <code>CT=UInt64</code>.  These integer coordinates are converted to a code using the function <code>coortocode</code>, which defaults to <code>hilbertcode</code>.</p><p>The array containing the element corner coordinates, <code>elemtocorner</code>, is used to compute the centroids.  <code>elemtocorner</code> is a dimension by number of corners by number of elements array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/BrickMesh.jl#L95-L111">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><p>Grids specify the approximation within each element, and any necessary warping.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Grids.get_z" href="#ClimateMachine.Mesh.Grids.get_z"><code>ClimateMachine.Mesh.Grids.get_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_z(grid; z_scale = 1, rm_dupes = false)</code></pre><p>Get the Gauss-Lobatto points along the Z-coordinate.</p><ul><li><code>grid</code>: DG grid</li><li><code>z_scale</code>: multiplies <code>z-coordinate</code></li><li><code>rm_dupes</code>: removes duplicate Gauss-Lobatto points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Grids.jl#L377-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Grids.referencepoints" href="#ClimateMachine.Mesh.Grids.referencepoints"><code>ClimateMachine.Mesh.Grids.referencepoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">referencepoints(::AbstractGrid)</code></pre><p>Returns the points on the reference element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Grids.jl#L39-L43">source</a></section><section><div><pre><code class="language-none">referencepoints(::DiscontinuousSpectralElementGrid)</code></pre><p>Returns the 1D interpolation points used for the reference element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Grids.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Grids.min_node_distance" href="#ClimateMachine.Mesh.Grids.min_node_distance"><code>ClimateMachine.Mesh.Grids.min_node_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">min_node_distance(::AbstractGrid, direction::Direction=EveryDirection() )</code></pre><p>Returns an approximation of the minimum node distance in physical space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Grids.jl#L46-L50">source</a></section><section><div><pre><code class="language-none">min_node_distance(::DiscontinuousSpectralElementGrid,
                  direction::Direction=EveryDirection()))</code></pre><p>Returns an approximation of the minimum node distance in physical space along the reference coordinate directions.  The direction controls which reference directions are considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Grids.jl#L337-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid" href="#ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid"><code>ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,
                                 polynomialorder,
                                 meshwarp = (x...)-&gt;identity(x))</code></pre><p>Generate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a <code>topology</code>, where the order of the elements is given by <code>polynomialorder</code>. <code>DeviceArray</code> gives the array type used to store the data (<code>CuArray</code> or <code>Array</code>), and the coordinate points will be of <code>FloatType</code>.</p><p>The polynomial order can be different in each direction (specified as a <code>NTuple</code>). If only a single integer is specified, then each dimension will use the same order. If the topology dimension is 3 and the <code>polynomialorder</code> has dimension 2, then the first value will be used for horizontal and the second for the vertical.</p><p>The optional <code>meshwarp</code> function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Grids.jl#L101-L121">source</a></section></article><h2 id="Filters"><a class="docs-heading-anchor" href="#Filters">Filters</a><a id="Filters-1"></a><a class="docs-heading-anchor-permalink" href="#Filters" title="Permalink"></a></h2><p>There are methods used to cleanup state vectors.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Filters.CutoffFilter" href="#ClimateMachine.Mesh.Filters.CutoffFilter"><code>ClimateMachine.Mesh.Filters.CutoffFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CutoffFilter(grid, Nc=polynomialorders(grid))</code></pre><p>Returns the spectral filter that zeros out polynomial modes greater than or equal to <code>Nc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Filters.jl#L237-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Filters.BoydVandevenFilter" href="#ClimateMachine.Mesh.Filters.BoydVandevenFilter"><code>ClimateMachine.Mesh.Filters.BoydVandevenFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoydVandevenFilter(grid, Nc=0, s=32)</code></pre><p>Returns the spectral filter using the logorithmic error function of the form:</p><p class="math-container">\[σ(η) = 1/2 erfc(2*sqrt(s)*χ(η)*(abs(η)-0.5))\]</p><p>whenever s ≤ i ≤ N, and 1 otherwise. The function <code>χ(η)</code> is defined as</p><p class="math-container">\[χ(η) = sqrt(-log(1-4*(abs(η)-0.5)^2)/(4*(abs(η)-0.5)^2))\]</p><p>if <code>x != 0.5</code> and <code>1</code> otherwise. Here, <code>s</code> is the filter order, the filter starts with polynomial order <code>Nc</code>, and <code>alpha</code> is a parameter controlling the smallest value of the filter function.</p><p><strong>References</strong></p><ul><li><a href="../../../../References/#Boyd1996">JP Boyd  (1996)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Filters.jl#L179-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Filters.ExponentialFilter" href="#ClimateMachine.Mesh.Filters.ExponentialFilter"><code>ClimateMachine.Mesh.Filters.ExponentialFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExponentialFilter(grid, Nc=0, s=32, α=-log(eps(eltype(grid))))</code></pre><p>Returns the spectral filter with the filter function</p><p class="math-container">\[σ(η) = xp(-α η^s)\]</p><p>where <code>s</code> is the filter order (must be even), the filter starts with polynomial order <code>Nc</code>, and <code>alpha</code> is a parameter controlling the smallest value of the filter function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Filters.jl#L129-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Filters.TMARFilter" href="#ClimateMachine.Mesh.Filters.TMARFilter"><code>ClimateMachine.Mesh.Filters.TMARFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TMARFilter()</code></pre><p>Returns the truncation and mass aware rescaling nonnegativity preservation filter.  The details of this filter are described in <a href="../../../../References/#Light2016">Devin Light , Dale Durran  (2016)</a></p><p>Note this needs to be used with a restrictive time step or a flux correction to ensure that grid integral is conserved.</p><p><strong>Examples</strong></p><p>This filter can be applied to the 3rd and 4th fields of an <code>MPIStateArray</code> <code>Q</code> with the code</p><pre><code class="language-julia">Filters.apply!(Q, (3, 4), grid, TMARFilter())</code></pre><p>where <code>grid</code> is the associated <code>DiscontinuousSpectralElementGrid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Filters.jl#L276-L295">source</a></section></article><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.InterpolationBrick" href="#ClimateMachine.Mesh.Interpolation.InterpolationBrick"><code>ClimateMachine.Mesh.Interpolation.InterpolationBrick</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolationBrick{
    FT &lt;: AbstractFloat,CuArrays
    UI8AD &lt;: AbstractArray{UInt8, 2},
    UI16VD &lt;: AbstractVector{UInt16},
    I32V &lt;: AbstractVector{Int32},
} &lt;: InterpolationTopology</code></pre><p>This interpolation data structure and the corresponding functions works for a brick, where stretching/compression happens only along the x1, x2 &amp; x3 axis. Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3).</p><p><strong>Fields</strong></p><ul><li><p><code>Nel</code></p><p>Number of elements</p></li><li><p><code>Np</code></p><p>Total number of interpolation points</p></li><li><p><code>Npl</code></p><p>Total number of interpolation points on local process</p></li><li><p><code>xbnd</code></p><p>Domain bounds in x1, x2 and x3 directions</p></li><li><p><code>x1g</code></p><p>Interpolation grid in x1 direction</p></li><li><p><code>x2g</code></p><p>Interpolation grid in x2 direction</p></li><li><p><code>x3g</code></p><p>Interpolation grid in x3 direction</p></li><li><p><code>ξ1</code></p><p>Unique ξ1 coordinates of interpolation points within each spectral element</p></li><li><p><code>ξ2</code></p><p>Unique ξ2 coordinates of interpolation points within each spectral element</p></li><li><p><code>ξ3</code></p><p>Unique ξ3 coordinates of interpolation points within each spectral element</p></li><li><p><code>flg</code></p><p>Flags when ξ1/ξ2/ξ3 interpolation point matches with a GLL point</p></li><li><p><code>fac</code></p><p>Normalization factor</p></li><li><p><code>x1i</code></p><p>x1 interpolation grid index of interpolation points within each element on the local process</p></li><li><p><code>x2i</code></p><p>x2 interpolation grid index of interpolation points within each element on the local process</p></li><li><p><code>x3i</code></p><p>x3 interpolation grid index of interpolation points within each element on the local process</p></li><li><p><code>offset</code></p><p>Offsets for each element</p></li><li><p><code>m_ξ1</code></p><p>GLL points in ξ1 direction</p></li><li><p><code>m_ξ2</code></p><p>GLL points in ξ2 direction</p></li><li><p><code>m_ξ3</code></p><p>GLL points in ξ3 direction</p></li><li><p><code>wb1</code></p><p>Barycentric weights</p></li><li><p><code>wb2</code></p><p>Barycentric weights</p></li><li><p><code>wb3</code></p><p>Barycentric weights</p></li><li><p><code>Np_all</code></p><p>Number of interpolation points on each of the processes</p></li><li><p><code>x1i_all</code></p><p>x1 interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li><li><p><code>x2i_all</code></p><p>x2 interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li><li><p><code>x3i_all</code></p><p>x3 interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li></ul><p><strong>Usage</strong></p><pre><code class="language-none">InterpolationBrick(
    grid::DiscontinuousSpectralElementGrid{FT},
    xbnd::Array{FT,2},
    xres,
) where FT &lt;: AbstractFloat</code></pre><p>This interpolation structure and the corresponding functions works for a brick, where stretching/compression happens only along the x1, x2 &amp; x3 axis. Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3).</p><p><strong>Arguments for the inner constructor</strong></p><ul><li><code>grid</code>: DiscontinousSpectralElementGrid</li><li><code>xbnd</code>: Domain boundaries in x1, x2 and x3 directions</li><li><code>xres</code>: Resolution of the interpolation grid in x1, x2 and x3 directions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Interpolation.jl#L29-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere" href="#ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere"><code>ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolationCubedSphere{
FT &lt;: AbstractFloat,
T &lt;: Int,
FTV &lt;: AbstractVector{FT},
FTVD &lt;: AbstractVector{FT},
TVD &lt;: AbstractVector{T},
UI8AD &lt;: AbstractArray{UInt8, 2},
UI16VD &lt;: AbstractVector{UInt16},
I32V &lt;: AbstractVector{Int32},
} &lt;: InterpolationTopology</code></pre><p>This interpolation structure and the corresponding functions works for a cubed sphere topology. The data is interpolated along a lat/long/rad grid.</p><p>-90⁰  ≤ lat  ≤ 90⁰</p><p>-180⁰ ≤ long ≤ 180⁰</p><p>Rᵢ ≤ r ≤ Rₒ</p><p><strong>Fields</strong></p><ul><li><p><code>Nel</code></p><p>Number of elements</p></li><li><p><code>Np</code></p><p>Number of interpolation points</p></li><li><p><code>Npl</code></p><p>Number of interpolation points on local process</p></li><li><p><code>n_rad</code></p><p>Number of interpolation points in radial direction</p></li><li><p><code>n_lat</code></p><p>Number of interpolation points in lat direction</p></li><li><p><code>n_long</code></p><p>Number of interpolation points in long direction</p></li><li><p><code>rad_grd</code></p><p>Interpolation grid in radial direction</p></li><li><p><code>lat_grd</code></p><p>Interpolation grid in lat direction</p></li><li><p><code>long_grd</code></p><p>Interpolation grid in long direction</p></li><li><p><code>ξ1</code></p><p>Device array containing ξ1 coordinates of interpolation points within each element</p></li><li><p><code>ξ2</code></p><p>Device array containing ξ2 coordinates of interpolation points within each element</p></li><li><p><code>ξ3</code></p><p>Device array containing ξ3 coordinates of interpolation points within each element</p></li><li><p><code>flg</code></p><p>flags when ξ1/ξ2/ξ3 interpolation point matches with a GLL point</p></li><li><p><code>fac</code></p><p>Normalization factor</p></li><li><p><code>radi</code></p><p>Radial coordinates of interpolation points withing each element</p></li><li><p><code>lati</code></p><p>Latitude coordinates of interpolation points withing each element</p></li><li><p><code>longi</code></p><p>Longitude coordinates of interpolation points withing each element</p></li><li><p><code>offset</code></p><p>Offsets for each element</p></li><li><p><code>m_ξ1</code></p><p>GLL points in ξ1 direction</p></li><li><p><code>m_ξ2</code></p><p>GLL points in ξ2 direction</p></li><li><p><code>m_ξ3</code></p><p>GLL points in ξ3 direction</p></li><li><p><code>wb1</code></p><p>Barycentric weights in ξ1 direction</p></li><li><p><code>wb2</code></p><p>Barycentric weights in ξ2 direction</p></li><li><p><code>wb3</code></p><p>Barycentric weights in ξ3 direction</p></li><li><p><code>Np_all</code></p><p>Number of interpolation points on each of the processes</p></li><li><p><code>radi_all</code></p><p>Radial interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li><li><p><code>lati_all</code></p><p>Latitude interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li><li><p><code>longi_all</code></p><p>Longitude interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li></ul><p><strong>Usage</strong></p><pre><code class="language-none">InterpolationCubedSphere(grid::DiscontinuousSpectralElementGrid, vert_range::AbstractArray{FT}, nhor::Int, lat_res::FT, long_res::FT, rad_res::FT) where {FT &lt;: AbstractFloat}</code></pre><p>This interpolation structure and the corresponding functions works for a cubed sphere topology. The data is interpolated along a lat/long/rad grid.</p><p>-90⁰  ≤ lat  ≤ 90⁰</p><p>-180⁰ ≤ long ≤ 180⁰</p><p>Rᵢ ≤ r ≤ Rₒ</p><p><strong>Arguments for the inner constructor</strong></p><ul><li><code>grid</code>: DiscontinousSpectralElementGrid</li><li><code>vert_range</code>: Vertex range along the radial coordinate</li><li><code>lat_res</code>: Resolution of the interpolation grid along the latitude coordinate in radians</li><li><code>long_res</code>: Resolution of the interpolation grid along the longitude coordinate in radians</li><li><code>rad_res</code>: Resolution of the interpolation grid along the radial coordinate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Interpolation.jl#L583-L625">source</a></section></article><h3 id="Functions-2"><a class="docs-heading-anchor" href="#Functions-2">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.interpolate_local!" href="#ClimateMachine.Mesh.Interpolation.interpolate_local!"><code>ClimateMachine.Mesh.Interpolation.interpolate_local!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interpolate_local!(
    intrp_brck::InterpolationBrick{FT},
    sv::AbstractArray{FT},
    v::AbstractArray{FT},
) where {FT &lt;: AbstractFloat}</code></pre><p>This interpolation function works for a brick, where stretching/compression happens only along the x1, x2 &amp; x3 axis.  Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3)</p><p><strong>Arguments</strong></p><ul><li><code>intrp_brck</code>: Initialized InterpolationBrick structure</li><li><code>sv</code>: State Array consisting of various variables on the discontinuous Galerkin grid</li><li><code>v</code>:  Interpolated variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Interpolation.jl#L374-L390">source</a></section><section><div><pre><code class="language-none">interpolate_local!(intrp_cs::InterpolationCubedSphere{FT},
                         sv::AbstractArray{FT},
                          v::AbstractArray{FT}) where {FT &lt;: AbstractFloat}</code></pre><p>This interpolation function works for cubed spherical shell geometry.</p><p><strong>Arguments</strong></p><ul><li><code>intrp_cs</code>: Initialized cubed sphere structure</li><li><code>sv</code>: Array consisting of various variables on the discontinuous Galerkin grid</li><li><code>v</code>:  Array consisting of variables on the interpolated grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Interpolation.jl#L1238-L1249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.project_cubed_sphere!" href="#ClimateMachine.Mesh.Interpolation.project_cubed_sphere!"><code>ClimateMachine.Mesh.Interpolation.project_cubed_sphere!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">project_cubed_sphere!(intrp_cs::InterpolationCubedSphere{FT},
                             v::AbstractArray{FT},
                          uvwi::Tuple{Int,Int,Int}) where {FT &lt;: AbstractFloat}</code></pre><p>This function projects the velocity field along unit vectors in radial, lat and long directions for cubed spherical shell geometry.</p><p><strong>Fields</strong></p><ul><li><code>intrp_cs</code>: Initialized cubed sphere structure</li><li><code>v</code>: Array consisting of x1, x2 and x3 components of the vector field</li><li><code>uvwi</code>:  Tuple providing the column numbers for x1, x2 and x3 components of vector field in the array.          These columns will be replaced with projected vector fields along unit vectors in long, lat and rad directions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Interpolation.jl#L1304-L1316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!" href="#ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!"><code>ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accumulate_interpolated_data!(intrp::InterpolationTopology,
                                 iv::AbstractArray{FT,2},
                                fiv::AbstractArray{FT,4}) where {FT &lt;: AbstractFloat}</code></pre><p>This interpolation function gathers interpolated data onto process # 0.</p><p><strong>Fields</strong></p><ul><li><code>intrp</code>: Initialized interpolation topology structure</li><li><code>iv</code>: Interpolated variables on local process</li><li><code>fiv</code>: Full interpolated variables accumulated on process # 0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Clima/ClimateMachine.jl/blob/47c3f342ac5badea2a5bae843d791a4668f82255/src/Numerics/Mesh/Interpolation.jl#L1426-L1437">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../InputOutput/">« Input/Output</a><a class="docs-footer-nextpage" href="../../SystemSolvers/SystemSolvers/">SystemSolvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 December 2020 21:36">Wednesday 23 December 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
