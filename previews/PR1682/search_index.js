var documenterSearchIndex = {"docs":
[{"location":"APIs/#Application-Programming-Interface-(APIs)","page":"Home","title":"Application Programming Interface (APIs)","text":"","category":"section"},{"location":"APIs/","page":"Home","title":"Home","text":"Here, references are provided for ClimateMachine's programming interface. These references aim to describe what functions do, their arguments, what is returned, and the composition of structs.","category":"page"},{"location":"APIs/Driver/#Driver","page":"Top level interface","title":"Driver","text":"","category":"section"},{"location":"APIs/Driver/","page":"Top level interface","title":"Top level interface","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Driver/#Solver-types","page":"Top level interface","title":"Solver types","text":"","category":"section"},{"location":"APIs/Driver/","page":"Top level interface","title":"Top level interface","text":"HEVISplitting\nMISSolverType\nMultirateSolverType\nAbstractSolverType\nDiscreteSplittingType\nExplicitSolverType\nImplicitSolverType\nSplitExplicitSolverType\nConfigTypes\nIMEXSolverType","category":"page"},{"location":"APIs/Driver/#ClimateMachine.HEVISplitting","page":"Top level interface","title":"ClimateMachine.HEVISplitting","text":"HEVISplitting\n\nHEVI (horizontally explicit, vertically implicit) type method, where vertical acoustic waves are treated implicitly. All other dynamics are treated explicitly.\n\nNote: Can potentially imagine several different types of HEVI splittings (for example, include vertical momentum and/or diffusion)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.MISSolverType","page":"Top level interface","title":"ClimateMachine.MISSolverType","text":"Description\n\nMISSolverType(;\n    splitting_type = SlowFastSplitting(),\n    fast_model = AtmosAcousticGravityLinearModel,\n    mis_method = MIS2,\n    fast_method = LSRK54CarpenterKennedy,\n    nsubsteps = 50,\n)\n\nThis solver type constructs an ODE solver using a generalization of the split-explicit Runge-Kutta method. Known as the Multirate Infinitesimal Step (MIS) method, this solver solves ODEs with the partitioned form:\n\n    dotQ = f_fast(Q t) + f_slow(Q t)\n\nwhere the right-hand-side functions f_fast and f_slow denote fast and slow dynamics respectively, depending on the state Q.\n\nArguments\n\nsplitting_type (DiscreteSplittingType): The type of discrete   splitting to apply to the right-hand side.   Default: SlowFastSplitting()\nfast_model (Type): The model describing fast dynamics.   Default: AtmosAcousticGravityLinearModel\nmis_method (Function): Function defining the particular MIS   method to be used.   Default: MIS2\nfast_method (Function): Function defining the fast solver.   Default: LSRK54CarpenterKennedy\nnsubsteps (Int): Integer denoting the total number of times   to substep the fast process.   Default: 50\ndiscrete_splitting (Boolean): Boolean denoting whether a PDE level or   discretized level splitting should be used. If true then the PDE is   discretized in such a way that f_fast + f_slow is equivalent to   discretizing the original PDE directly.   Default: false\n\nReferences\n\n@article{KnothWensch2014,\n    title={Generalized split-explicit Runge--Kutta methods for\n        the compressible Euler equations},\n    author={Knoth, Oswald and Wensch, Joerg},\n    journal={Monthly Weather Review},\n    volume={142},\n    number={5},\n    pages={2067--2081},\n    year={2014}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.MultirateSolverType","page":"Top level interface","title":"ClimateMachine.MultirateSolverType","text":"Description\n\nMultirateSolverType(;\n    splitting_type = SlowFastSplitting(),\n    fast_model = AtmosAcousticGravityLinearModel,\n    implicit_solver = ManyColumnLU,\n    implicit_solver_adjustable = false,\n    slow_method = LSRK54CarpenterKennedy,\n    fast_method = LSRK54CarpenterKennedy,\n    timestep_ratio = 100,\n)\n\nThis solver type constructs an ODE solver using a standard multirate Runge-Kutta implementation. This solver computes solutions to ODEs with the partitioned form:\n\n    dotQ = f_fast(Q t) + f_slow(Q t)\n\nwhere the right-hand-side functions f_fast and f_slow denote fast and slow dynamics respectively, depending on the state Q.\n\nArguments\n\nsplitting_type (DiscreteSplittingType): The type of discrete   splitting to apply to the right-hand side.   Default: SlowFastSplitting()\nfast_model (Type): The model describing fast dynamics.   Default: AtmosAcousticGravityLinearModel\nimplicit_solver (Type): An implicit solver for inverting the   implicit system of equations (if using HEVISplitting()).   Default: ManyColumnLU\nimplicit_solver_adjustable (Bool): A flag identifying whether   or not the implicit_solver can be updated as the time-step   size changes. This is particularly important when using   an implicit solver within a multirate scheme.   Default: false\nslow_method (Function): Function defining the particular explicit   Runge-Kutta method to be used for the slow processes.   Default: LSRK54CarpenterKennedy\nfast_method (Function): Function defining the fast solver.   Depending on the choice of splitting_type, this can be   an explicit Runge Kutta method or a 1-D IMEX (additive Runge-Kutta)   method.   Default: LSRK54CarpenterKennedy\ntimestep_ratio (Int): Integer denoting the ratio between the slow   and fast time-step sizes.   Default: 100\ndiscrete_splitting (Boolean): Boolean denoting whether a PDE level or   discretized level splitting should be used. If true then the PDE is   discretized in such a way that f_fast + f_slow is equivalent to   discretizing the original PDE directly.\n\nReferences\n\n@article{SchlegelKnothArnoldWolke2012,\n    title={Implementation of multirate time integration methods for air\n        pollution modelling},\n    author={Schlegel, M and Knoth, O and Arnold, M and Wolke, R},\n    journal={Geoscientific Model Development},\n    volume={5},\n    number={6},\n    pages={1395--1405},\n    year={2012},\n    publisher={Copernicus GmbH}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.AbstractSolverType","page":"Top level interface","title":"ClimateMachine.AbstractSolverType","text":"AbstractSolverType\n\nThis is an abstract type representing a generic solver. By a \"solver,\" we mean an ODE solver together with any potential implicit solver (linear solvers).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.DiscreteSplittingType","page":"Top level interface","title":"ClimateMachine.DiscreteSplittingType","text":"DiscreteSplittingType\n\nThis is an abstract type representing a temporal splitting in the discrete equations. For example, HEVI (horizontally explicit, vertically implicit) type methods.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.ExplicitSolverType","page":"Top level interface","title":"ClimateMachine.ExplicitSolverType","text":"Description\n\nExplicitSolverType(;\n    solver_method = LSRK54CarpenterKennedy,\n)\n\nThis solver type constructs an ODE solver using an explicit Runge-Kutta method.\n\nArguments\n\nsolver_method (Function): Function defining the explicit   Runge-Kutta solver.   Default: LSRK54CarpenterKennedy\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.ImplicitSolverType","page":"Top level interface","title":"ClimateMachine.ImplicitSolverType","text":"Description\n\nImplicitSolverType(;\n    solver_method = KenCarp4,\n)\n\nThis solver type constructs an ODE solver using a fully implicit method.\n\nArguments\n\nsolver_method (Function): Function defining the implicit   solver.   Default: KenCarp4\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.SplitExplicitSolverType","page":"Top level interface","title":"ClimateMachine.SplitExplicitSolverType","text":"Description\n\nSplitExplicitSolverType\n\nThis solver type constructs an ODE solver using the SplitExplicitLSRK2nSolver.\n\nArguments\n\ndt_slow (AbstractFloat): Time step for the slow solver\ndt_fast (AbstractFloat): Time step for the fast solver\nslow_method (Function): Function defining the explicit   Runge-Kutta solver for the slow model.   Default: LSRK54CarpenterKennedy\nfast_method (Function): Function defining the explicit   Runge-Kutta solver for the fast model.   Default: LSRK54CarpenterKennedy\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.ConfigTypes","page":"Top level interface","title":"ClimateMachine.ConfigTypes","text":"ConfigTypes\n\nModule containing ClimateMachine configuration types.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Driver/#ClimateMachine.IMEXSolverType","page":"Top level interface","title":"ClimateMachine.IMEXSolverType","text":"Description\n\nIMEXSolverType(;\n    splitting_type = HEVISplitting(),\n    implicit_model = AtmosAcousticGravityLinearModel,\n    implicit_solver = ManyColumnLU,\n    implicit_solver_adjustable = false,\n    solver_method = ARK2GiraldoKellyConstantinescu,\n    solver_storage_variant = LowStorageVariant(),\n    split_explicit_implicit = false,\n    discrete_splitting = true,\n)\n\nThis solver type constructs a solver for ODEs with the additively-partitioned form.  When split_explicit_implicit == false the equation is assumed to be decomposed as\n\n  dotQ = l(Q t) + f(Q t) - l(Q t)\n\nwhere Q is the state, f is the full tendency and l is the chosen implicit operator.\n\nWhen split_explicit_implicit == true the assumed decomposition is\n\n  dotQ = l(Q t) + n(Q t)\n\nwhere n is now only the nonlinear tendency.\n\nArguments\n\nsplitting_type (DiscreteSplittingType): The type of discrete   splitting to apply to the right-hand side.   Default: HEVISplitting()\nimplicit_model (Type): The model describing dynamics to be   treated implicitly.   Default: AtmosAcousticGravityLinearModel\nimplicit_solver (Type): A solver for inverting the   implicit system of equations.   Default: ManyColumnLU\nimplicit_solver_adjustable (Bool): A flag identifying whether   or not the implicit_solver can be updated as the time-step   size changes.   Default: false\nsolver_method (Function): Function defining the particular additive   Runge-Kutta method to be used for the IMEX method.   Default: ARK2GiraldoKellyConstantinescu\nsolver_storage_variant (Type): Storage type for the additive   Runge-Kutta method.   Default: LowStorageVariant()\nsplit_explicit_implicit (Boolean): Whether the tendency is split in explicit   and implicit parts or not.\ndiscrete_splitting (Boolean): Boolean denoting whether a PDE level or   discretized level splitting should be used. If true then the PDE is   discretized in such a way that f_fast + f_slow is equivalent to   discretizing the original PDE directly.\n\nReferences\n\n@article{giraldo2013implicit,\n  title={Implicit-explicit formulations of a three-dimensional\n         nonhydrostatic unified model of the atmosphere ({NUMA})},\n  author={Giraldo, Francis X and Kelly, James F and Constantinescu, Emil M},\n  journal={SIAM Journal on Scientific Computing},\n  volume={35},\n  number={5},\n  pages={B1162--B1194},\n  year={2013},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#Configurations","page":"Top level interface","title":"Configurations","text":"","category":"section"},{"location":"APIs/Driver/","page":"Top level interface","title":"Top level interface","text":"DriverConfiguration\nSolverConfiguration\nInterpolationConfiguration\nDiagnosticsConfiguration\nConservationCheck","category":"page"},{"location":"APIs/Driver/#ClimateMachine.DriverConfiguration","page":"Top level interface","title":"ClimateMachine.DriverConfiguration","text":"ClimateMachine.DriverConfiguration\n\nCollects all parameters necessary to set up a ClimateMachine simulation.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.SolverConfiguration","page":"Top level interface","title":"ClimateMachine.SolverConfiguration","text":"ClimateMachine.SolverConfiguration\n\nParameters needed by ClimateMachine.solve!() to run a simulation.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.InterpolationConfiguration","page":"Top level interface","title":"ClimateMachine.InterpolationConfiguration","text":"InterpolationConfiguration(\n    driver_config::DriverConfiguration,\n    boundaries::Array,\n    resolution::Tuple,\n)\n\nCreates an InterpolationTopology (either an InterpolationBrick or an InterpolationCubedSphere) to be used with a DiagnosticsGroup. The axes are set up based on boundaries and resolution.\n\n\n\n\n\nInterpolationConfiguration(\n    driver_config::DriverConfiguration,\n    boundaries::Array,\n    axes,\n)\n\nCreates an InterpolationTopology (either an InterpolationBrick or an InterpolationCubedSphere) to be used with a DiagnosticsGroup. The axes are directly specified in lat/lon/lvl order.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Driver/#ClimateMachine.DiagnosticsConfiguration","page":"Top level interface","title":"ClimateMachine.DiagnosticsConfiguration","text":"DiagnosticsConfiguration\n\nContainer for all the DiagnosticsGroups to be used for a simulation.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#ClimateMachine.ConservationCheck","page":"Top level interface","title":"ClimateMachine.ConservationCheck","text":"ClimateMachine.ConservationCheck\n\nPass a tuple of these to ClimateMachine.invoke! to perform a conservation check of each varname at the specified interval. This computes Σv = weightedsum(Q.varname) and δv = (Σv - Σv₀) / Σv. invoke! throws an error if abs(δv) exceeds error_threshold. Ifshow,δv` is displayed.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Driver/#Initialize-/-solve","page":"Top level interface","title":"Initialize / solve","text":"","category":"section"},{"location":"APIs/Driver/","page":"Top level interface","title":"Top level interface","text":"array_type\ninit\ninvoke!","category":"page"},{"location":"APIs/Driver/#ClimateMachine.array_type","page":"Top level interface","title":"ClimateMachine.array_type","text":"ClimateMachine.array_type()\n\nReturn the array type used by ClimateMachine. This defaults to (CPU-based) Array and is only correctly set (based on choice from the command line, from an environment variable, or from experiment code) after ClimateMachine.init() is called.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Driver/#ClimateMachine.init","page":"Top level interface","title":"ClimateMachine.init","text":"ClimateMachine.init(;\n    parse_clargs::Bool = false,\n    custom_clargs::Union{Nothing, ArgParseSettings} = nothing,\n    init_driver::Bool = true,\n    keyword_args...,\n)\n\nInitialize the ClimateMachine. If parse_clargs is set, parse command line arguments (additional driver-specific arguments can be added by specifying custom_clargs).\n\nSetting init_driver = false will set up the ClimateMachine.Settings singleton values without initializing the ClimateMachine runtime. Otherwise, the runtime will be initialized (see init_runtime()).\n\nFinally, key-value pairs can be supplied to ClimateMachine.init() to set system default settings – the final settings are decided as follows (in order of precedence):\n\nCommand line arguments (if parse_clargs = true).\nEnvironment variables.\nKeyword arguments to init().\nDefaults (in ClimateMachine_Settings).\n\nRecognized keyword arguments are:\n\ndisable_gpu::Bool = false:       do not use the GPU\nshow_updates::String = \"60secs\":       interval at which to show simulation updates\ndiagnostics::String = \"never\":       interval at which to collect diagnostics\"\nvtk::String = \"never\":       inteverval at which to write simulation vtk output\nvtk-number-sample-points::Int = 0:       the number of sampling points in each element for VTK output\nmonitor_timestep_duration::String = \"never\":       interval in time-steps at which to output wall-clock time per time-step\nmonitor_courant_numbers::String = \"never\":       interval at which to output acoustic, advective, and diffusive Courant numbers\"\ncheckpoint::String = \"never\":       interval at which to output a checkpoint\ncheckpoint_keep_one::Bool = true: (interval)       keep all checkpoints (instead of just the most recent)\"\ncheckpoint_at_end::Bool = false:       create a checkpoint at the end of the simulation\"\ncheckpoint_dir::String = \"checkpoint\":       absolute or relative path to checkpoint directory\nrestart_from_num::Int = -1:       checkpoint number from which to restart (in checkpoint_dir)\nfix_rng_seed::Bool = false:       set RNG seed to a fixed value for reproducibility\nlog_level::String = \"INFO\":       log level for ClimateMachine global default runtime logger\ndisable_custom_logger::String = false:       disable using a global custom logger for ClimateMachine\noutput_dir::String = \"output\": (path)       absolute or relative path to output data directory\ndebug_init::Bool = false:       fill state arrays with NaNs and dump them post-initialization\nintegration_testing::Bool = false:       enable integration_testing\n\nReturns nothing, or if parse_clargs = true, returns parsed command line arguments.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Driver/#ClimateMachine.invoke!","page":"Top level interface","title":"ClimateMachine.invoke!","text":"ClimateMachine.invoke!(\n    solver_config::SolverConfiguration;\n    adjustfinalstep = false,\n    diagnostics_config = nothing,\n    user_callbacks = (),\n    user_info_callback = () -> nothing,\n    check_cons = (),\n    check_euclidean_distance = false,\n)\n\nRun the simulation defined by solver_config.\n\nKeyword Arguments:\n\nThe value of 'adjustfinalstepis passed to the ODE solver; see [solve!`](@ref ODESolvers.solve!).\n\nThe user_callbacks are passed to the ODE solver as callback functions; see solve!.\n\nThe function user_info_callback is called after the default info callback (which is called every Settings.show_updates interval). The single input argument init is true when the callback is called for initialization (before time stepping begins) and false when called during the actual ODE solve; see GenericCallbacks and solve!.\n\nIf conservation checks are to be performed, check_cons must be a tuple of ConservationCheck.\n\nIf check_euclidean_distance is true, then the Euclidean distance between the final solution and initial condition function evaluated withsolver_config.timeend` is reported.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics_0M/#Microphysics_0M","page":"Microphysics_0M","title":"Microphysics_0M","text":"","category":"section"},{"location":"APIs/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"Microphysics_0M","category":"page"},{"location":"APIs/Atmos/Microphysics_0M/#ClimateMachine.Microphysics_0M","page":"Microphysics_0M","title":"ClimateMachine.Microphysics_0M","text":"Microphysics_0M\n\nZero-moment bulk microphysics scheme that instantly removes moisture above certain threshold. This is equivalent to instanteneous conversion of cloud condensate into precipitation and precipitation fallout with infinite terminal velocity.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Atmos/Microphysics_0M/#Methods","page":"Microphysics_0M","title":"Methods","text":"","category":"section"},{"location":"APIs/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"Microphysics_0M.remove_precipitation","category":"page"},{"location":"APIs/Atmos/Microphysics_0M/#ClimateMachine.Microphysics_0M.remove_precipitation","page":"Microphysics_0M","title":"ClimateMachine.Microphysics_0M.remove_precipitation","text":"remove_precipitation(param_set::APS, q; q_vap_sat)\n\nparam_set - abstract parameter set\nq - current PhasePartition\nq_vap_sat - water vapor specific humidity at saturation\n\nReturns the q_tot tendency due to the removal of precipitation. The tendency is obtained assuming a relaxation with a constant timescale to a state with precipitable water removed. The threshold for when to remove q_tot is defined either by the condensate specific humidity or supersaturation. The thresholds and the relaxation timescale are defined in CLIMAParameters.\n\n\n\n\n\n","category":"function"},{"location":"Theory/Common/SurfaceFluxes/#Surface-Fluxes","page":"SurfaceFluxes","title":"Surface Fluxes","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"CurrentModule = ClimateMachine.SurfaceFluxes","category":"page"},{"location":"Theory/Common/SurfaceFluxes/","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"This module provides a means to compute surface fluxes given several variables, described in surface_conditions.","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#Interface","page":"SurfaceFluxes","title":"Interface","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"surface_conditions computes\nMonin-Obukhov length\nPotential temperature flux (if not given) using Monin-Obukhov theory\ntransport fluxes using Monin-Obukhov theory\nfriction velocity/temperature scale/tracer scales\nexchange coefficients","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#References","page":"SurfaceFluxes","title":"References","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Businger, Joost A., et al. \"Flux-profile relationships in the atmospheric surface layer.\" Journal of the atmospheric Sciences 28.2 (1971): 181-189.\nNishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin-Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.\nBusinger, Joost A., et al. \"Flux-profile relationships in the atmospheric surface layer.\" Journal of the atmospheric Sciences 28.2 (1971): 181-189. doi: 10.1175/1520-0469(1971)028<0181:FPRITA>2.0.CO;2\nByun, Daewon W. \"On the analytical solutions of flux-profile relationships for the atmospheric surface layer.\" Journal of Applied Meteorology 29.7 (1990): 652-657.\nWyngaard, John C. \"Modeling the planetary boundary layer-Extension to the stable case.\" Boundary-Layer Meteorology 9.4 (1975): 441-460.","category":"page"},{"location":"DevDocs/CodeStyle/#Coding-conventions","page":"Coding style","title":"Coding conventions","text":"","category":"section"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"For the most part, we follow the YASGuide. Some key considerations:","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"Limit use of Unicode as described in Acceptable Unicode characters.\nModules and struct names should follow TitleCase convention.\nFunction names should be lowercase with words separated by underscores as necessary to improve readability.\nVariable names follow the format used in the ClimateMachine Variable List. In addition, follow CMIP conventions where possible and practicable.\nDocument design and purpose rather than mechanics and implementation (document interfaces and embed documentation in code).\nAvoid variable names that coincide with module and struct names, as well as function/variable names that are natively supported.\nNever use the characters l (lowercase letter 'el'), O (uppercase letter 'oh'), or I (uppercase letter 'eye') as single character variable names.\nTry to limit all lines to a maximum of 78 characters.\nimport/using should be grouped in the following order:\nStandard library imports.\nRelated third party imports.\nLocal application/library specific imports.\nUse a blank line between each group of imports.","category":"page"},{"location":"DevDocs/CodeStyle/#Use-JuliaFormatter","page":"Coding style","title":"Use JuliaFormatter","text":"","category":"section"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"Once you are happy with your PR, apply our JuliaFormatter.jl settings to all changed files in the repository from the top-level ClimateMachine directory:","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"julia .dev/climaformat.jl <list of changed files>","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"This is easiest done by installing our formatting githook.","category":"page"},{"location":"DevDocs/CodeStyle/#Formatting-githook","page":"Coding style","title":"Formatting githook","text":"","category":"section"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"A pre-commit script can be placed in $GIT_DIR/hooks/* which will prevent commits of incorrectly formatted Julia code.  It will also provide instructions on how to format the code correctly.","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"Install the script with:","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"$ ln -s ../../.dev/hooks/pre-commit .git/hooks","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"Then, when you run git commit, an error message will be shown for staged Julia files that are not formatted correctly. For example, if you try to commit changes to src/Arrays/MPIStateArrays.jl that are not formatted correctly:","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"❯ git commit                                                                                                           │\nActivating environment at `~/research/code/ClimateMachine.jl/.dev/Project.toml`                                        │\n┌ Error: File src/Arrays/MPIStateArrays.jl needs to be indented with:                                                  │\n│     julia /home/lucas/research/code/ClimateMachine.jl/.dev/climaformat.jl /home/lucas/research/code/ClimateMachine.jl│\n/src/Arrays/MPIStateArrays.jl                                                                                          │\n│ and added to the git index via                                                                                       │\n│     git add /home/lucas/research/code/ClimateMachine.jl/src/Arrays/MPIStateArrays.jl                                 │\n└ @ Main ~/research/code/ClimateMachine.jl/.git/hooks/pre-commit:30","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"Learn more about git hooks.","category":"page"},{"location":"DevDocs/CodeStyle/#Precompiling-JuliaFormatter","page":"Coding style","title":"Precompiling JuliaFormatter","text":"","category":"section"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"To speed up the formatter and the githook, a custom system image can be built with the [PackageCompiler]. That said, the following [drawback] from the PackageCompiler repository should be noted:","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"It should be clearly stated that there are some drawbacks to using a custom sysimage, thereby sidestepping the standard Julia package precompilation system. The biggest drawback is that packages that are compiled into a sysimage (including their dependencies!) are \"locked\" to the version they where at when the sysimage was created. This means that no matter what package version you have installed in your current project, the one in the sysimage will take precedence. This can lead to bugs where you start with a project that needs a specific version of a package, but you have another one compiled into the sysimage.","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"The PackageCompiler compiler can be used with JuliaFormatter using the following commands (from the top-level directory of a clone of ClimateMachine):","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"$ julia -q\njulia> using Pkg\njulia> Pkg.add(\"PackageCompiler\")\njulia> using PackageCompiler\njulia> Pkg.activate(joinpath(@__DIR__, \".dev\"))\njulia> using PackageCompiler\njulia> PackageCompiler.create_sysimage(:JuliaFormatter; precompile_execution_file=joinpath(@__DIR__, \".dev/precompile.jl\"), replace_default=true)","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"If you cannot or do not want to modify the default system image, use the following instead:","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"$ julia -q\njulia> using Pkg\njulia> Pkg.add(\"PackageCompiler\")\njulia> using PackageCompiler\njulia> Pkg.activate(joinpath(@__DIR__, \".dev\"))\njulia> PackageCompiler.create_sysimage(:JuliaFormatter; precompile_execution_file=joinpath(@__DIR__, \".dev/precompile.jl\"), sysimage_path=joinpath(@__DIR__, \".git/hooks/JuliaFormatterSysimage.so\"))","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"In this case, use the pre-commit.sysimage git hook with:","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"$ ln -s ../../.dev/hooks/pre-commit.sysimage .git/hooks/pre-commit","category":"page"},{"location":"DevDocs/CodeStyle/","page":"Coding style","title":"Coding style","text":"Note: Putting the system image in .git/hooks protects it from calls to git clean -x.","category":"page"},{"location":"APIs/Numerics/DGMethods/DGMethods/#Discontinuous-Galerkin-Methods","page":"DG Methods","title":"Discontinuous Galerkin Methods","text":"","category":"section"},{"location":"APIs/Numerics/DGMethods/DGMethods/","page":"DG Methods","title":"DG Methods","text":"CurrentModule = ClimateMachine.DGMethods","category":"page"},{"location":"APIs/Numerics/DGMethods/DGMethods/","page":"DG Methods","title":"DG Methods","text":"DGModel\nremainder_DGModel\ncontinuous_field_gradient!\ncourant","category":"page"},{"location":"APIs/Numerics/DGMethods/DGMethods/#ClimateMachine.DGMethods.DGModel","page":"DG Methods","title":"ClimateMachine.DGMethods.DGModel","text":"DGModel(driver_config; kwargs...)\n\nInitialize a DGModel given a DriverConfiguration and keyword arguments supported by DGModel.\n\n\n\n\n\n(dg::DGModel)(tendency, state_prognostic, nothing, t, α, β)\n\nComputes the tendency terms compatible with IncrementODEProblem\n\ntendency .= α .* dQdt(state_prognostic, p, t) .+ β .* tendency\n\nThe 4-argument form will just compute\n\ntendency .= dQdt(state_prognostic, p, t)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/DGMethods/#ClimateMachine.DGMethods.remainder_DGModel","page":"DG Methods","title":"ClimateMachine.DGMethods.remainder_DGModel","text":"remainder_DGModel(\n    maindg::DGModel,\n    subsdg::NTuple{NumModels, DGModel};\n    numerical_flux_first_order,\n    numerical_flux_second_order,\n    numerical_flux_gradient,\n    state_auxiliary,\n    state_gradient_flux,\n    states_higher_order,\n    diffusion_direction,\n    modeldata,\n)\n\nConstructs a DGModel from the maindg model and the tuple of subsdg models. The concept of a remainder model is that it computes the contribution of the model after subtracting all of the subcomponents.\n\nBy default the numerical fluxes are set to be a tuple of the main models numerical flux and the splitting is done at the PDE level (e.g., the remainder model is calculated prior to discretization). If instead a tuple of numerical fluxes is passed in the main numerical flux is evaluated first and then the subcomponent numerical fluxes are subtracted off. This is discretely different (for the Rusanov / local Lax-Friedrichs flux) than defining a numerical flux for the remainder of the physics model.\n\nThe other parameters are set to the value in the maindg component, mainly the data and arrays are aliased to the maindg values.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGMethods/DGMethods/#ClimateMachine.DGMethods.continuous_field_gradient!","page":"DG Methods","title":"ClimateMachine.DGMethods.continuous_field_gradient!","text":"continuous_field_gradient!(::BalanceLaw, ∇state::MPIStateArray,\n                           vars_out, state::MPIStateArray, vars_in, grid;\n                           direction = EveryDirection())\n\nTake the gradient of the variables vars_in located in the array state and stores it in the variables vars_out of ∇state. This function computes element wise gradient without accounting for numerical fluxes and hence its primary purpose is to take the gradient of continuous reference fields.\n\nExamples\n\nFT = eltype(state_auxiliary)\ngrad_Φ = similar(state_auxiliary, vars=@vars(∇Φ::SVector{3, FT}))\ncontinuous_field_gradient!(\n    model,\n    grad_Φ,\n    (\"∇Φ\",),\n    state_auxiliary,\n    (\"orientation.Φ\",),\n    grid,\n)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGMethods/DGMethods/#ClimateMachine.DGMethods.courant","page":"DG Methods","title":"ClimateMachine.DGMethods.courant","text":"DGMethods.courant(local_cfl, solver_config::SolverConfiguration;\n                  Q=solver_config.Q, dt=solver_config.dt)\n\nReturns the maximum of the evaluation of the function local_courant pointwise throughout the domain with the model defined by solver_config. The keyword arguments Q and dt can be used to call the courant method with a different state Q or time step dt than are defined in solver_config.\n\n\n\n\n\ncourant(local_courant::Function, dg::DGModel, m::BalanceLaw,\n        state_prognostic::MPIStateArray, direction=EveryDirection())\n\nReturns the maximum of the evaluation of the function local_courant pointwise throughout the domain.  The function local_courant is given an approximation of the local node distance Δx.  The direction controls which reference directions are considered when computing the minimum node distance Δx. An example local_courant function is     function localcourant(m::AtmosModel, stateprognostic::Vars, state_auxiliary::Vars,                            diffusive::Vars, Δx)       return Δt * cmax / Δx     end where Δt is the time step size and cmax is the maximum flow speed in the model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGMethods/DGMethods/#Mathematical-Formulation","page":"DG Methods","title":"Mathematical Formulation","text":"","category":"section"},{"location":"APIs/Numerics/DGMethods/DGMethods/","page":"DG Methods","title":"DG Methods","text":"to be filled","category":"page"},{"location":"APIs/Numerics/DGMethods/DGMethods/#Examples","page":"DG Methods","title":"Examples","text":"","category":"section"},{"location":"APIs/Numerics/DGMethods/DGMethods/","page":"DG Methods","title":"DG Methods","text":"attribution: Attribution\nThe style of examples we use here is heavily inspired by JuAFEM.jl","category":"page"},{"location":"APIs/Numerics/DGMethods/DGMethods/","page":"DG Methods","title":"DG Methods","text":"to be filled","category":"page"},{"location":"APIs/Utilities/TicToc/#Tic-Toc","page":"Tic Toc","title":"Tic Toc","text":"","category":"section"},{"location":"APIs/Utilities/TicToc/","page":"Tic Toc","title":"Tic Toc","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Utilities/TicToc/","page":"Tic Toc","title":"Tic Toc","text":"ClimateMachine.TicToc","category":"page"},{"location":"APIs/Utilities/TicToc/#ClimateMachine.TicToc","page":"Tic Toc","title":"ClimateMachine.TicToc","text":"TicToc -- timing measurement\n\nLow-overhead time interval measurement via minimally invasive macros.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Utilities/TicToc/#Methods","page":"Tic Toc","title":"Methods","text":"","category":"section"},{"location":"APIs/Utilities/TicToc/","page":"Tic Toc","title":"Tic Toc","text":"TicToc.@tic\nTicToc.@toc\nTicToc.tictoc","category":"page"},{"location":"APIs/Utilities/TicToc/#ClimateMachine.TicToc.@tic","page":"Tic Toc","title":"ClimateMachine.TicToc.@tic","text":"@tic nm\n\nIndicate the start of the interval nm.\n\n\n\n\n\n","category":"macro"},{"location":"APIs/Utilities/TicToc/#ClimateMachine.TicToc.@toc","page":"Tic Toc","title":"ClimateMachine.TicToc.@toc","text":"@toc nm\n\nIndicate the end of the interval nm.\n\n\n\n\n\n","category":"macro"},{"location":"APIs/Utilities/TicToc/#ClimateMachine.TicToc.tictoc","page":"Tic Toc","title":"ClimateMachine.TicToc.tictoc","text":"tictoc()\n\nCall at program start (only once!) to set up the globals used by the macros and to register the at-exit callback.\n\n\n\n\n\n","category":"function"},{"location":"HowToGuides/Common/UniversalFunctions/#Universal-Functions","page":"Universal Functions","title":"Universal Functions","text":"","category":"section"},{"location":"HowToGuides/Common/UniversalFunctions/","page":"Universal Functions","title":"Universal Functions","text":"UniversalFunctions.jl provides universal functions for SurfaceFluxes.jl. Here, we reproduce some plots from literature, specifically from Gryanik et al. 2020, and Businger.","category":"page"},{"location":"HowToGuides/Common/UniversalFunctions/","page":"Universal Functions","title":"Universal Functions","text":"using ClimateMachine.SurfaceFluxes.UniversalFunctions\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\nusing Plots\nFT = Float32;\nζ = FT(-0.1):FT(0.001):FT(0.1);\nL = FT(10);\nargs = (param_set,L)\nuniversal_functions(args) = (Gryanik(args...),\n    Grachev(args...),\n    Businger(args...),)\n\nfunction save_ϕ_figs(args, ζ; ylims=nothing, fig_prefix=\"\", xaxis=:identity, yaxis=:identity)\n    plot()\n    for uf in universal_functions(args)\n        ϕ_m = phi.(uf, ζ, MomentumTransport());\n        name = \"$(typeof(uf).name)\"\n        plot!(ζ, ϕ_m, xlabel=\"ζ\", ylabel=\"ϕ_m\", label=name, ylims=ylims, xaxis=xaxis,yaxis=yaxis)\n    end\n    savefig(\"$(fig_prefix)_phi_m.svg\");\n    plot()\n    for uf in universal_functions(args)\n        ϕ_h = phi.(uf, ζ, HeatTransport());\n        name = \"$(typeof(uf).name)\"\n        plot!(ζ, ϕ_h, xlabel=\"ζ\", ylabel=\"ϕ_h\", label=name, ylims=ylims, xaxis=xaxis,yaxis=yaxis)\n    end\n    savefig(\"$(fig_prefix)_phi_h.svg\")\nend\nfunction save_ψ_figs(args, ζ; ylims=nothing, fig_prefix=\"\", xaxis=:identity, yaxis=:identity)\n    plot()\n    for uf in universal_functions(args)\n        ψ_m = psi.(uf, ζ, MomentumTransport());\n        name = \"$(typeof(uf).name)\"\n        plot!(ζ, ψ_m, xlabel=\"ζ\", ylabel=\"ψ_m\", label=name, ylims=ylims, xaxis=xaxis,yaxis=yaxis)\n    end\n    savefig(\"$(fig_prefix)_psi_m.svg\");\n    plot()\n    for uf in universal_functions(args)\n        ψ_h = psi.(uf, ζ, HeatTransport());\n        name = \"$(typeof(uf).name)\"\n        plot!(ζ, ψ_h, xlabel=\"ζ\", ylabel=\"ψ_h\", label=name, ylims=ylims, xaxis=xaxis,yaxis=yaxis)\n    end\n    savefig(\"$(fig_prefix)_psi_h.svg\");\nend","category":"page"},{"location":"HowToGuides/Common/UniversalFunctions/#Figs-1,2-(Gryanik)","page":"Universal Functions","title":"Figs 1,2 (Gryanik)","text":"","category":"section"},{"location":"HowToGuides/Common/UniversalFunctions/","page":"Universal Functions","title":"Universal Functions","text":"save_ϕ_figs(args, FT(0):FT(0.01):FT(15);ylims=(0,30), fig_prefix=\"Gryanik12\")\nsave_ψ_figs(args, FT(0):FT(0.01):FT(15);ylims=(-25,0), fig_prefix=\"Gryanik12\")","category":"page"},{"location":"HowToGuides/Common/UniversalFunctions/","page":"Universal Functions","title":"Universal Functions","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"HowToGuides/Common/UniversalFunctions/#Fig-3-(Gryanik)","page":"Universal Functions","title":"Fig 3 (Gryanik)","text":"","category":"section"},{"location":"HowToGuides/Common/UniversalFunctions/","page":"Universal Functions","title":"Universal Functions","text":"save_ϕ_figs(args, 10 .^ (FT(-3):0.1:FT(2)); ylims=(0.1,10^2), xaxis=:log10, yaxis=:log10, fig_prefix=\"Gryanik3\")","category":"page"},{"location":"HowToGuides/Common/UniversalFunctions/","page":"Universal Functions","title":"Universal Functions","text":"(Image: ) (Image: )","category":"page"},{"location":"HowToGuides/Common/UniversalFunctions/#Figs-1,2-(Businger)","page":"Universal Functions","title":"Figs 1,2 (Businger)","text":"","category":"section"},{"location":"HowToGuides/Common/UniversalFunctions/","page":"Universal Functions","title":"Universal Functions","text":"save_ϕ_figs(args, FT(-2.5):FT(0.01):FT(2);ylims=(-1,8),fig_prefix=\"Businger\")","category":"page"},{"location":"HowToGuides/Common/UniversalFunctions/","page":"Universal Functions","title":"Universal Functions","text":"(Image: ) (Image: )","category":"page"},{"location":"Theory/Atmos/Microphysics/#Microphysics","page":"Microphysics","title":"Microphysics","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The Microphysics.jl module describes a 1-moment bulk parameterization of   cloud microphysical processes. The module is based on the ideas of   Kessler_1995,   Grabowski_1998   and Kaul_et_al_2015.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The cloud microphysics variables are expressed as specific humidities:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"q_tot - total water specific humidity,\nq_vap - water vapor specific humidity,\nq_liq - cloud water specific humidity,\nq_ice - cloud ice specific humidity,\nq_rai - rain specific humidity,\nq_sno - snow specific humidity.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Assumed-particle-size-relationships","page":"Microphysics","title":"Assumed particle size relationships","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Particles are assumed to follow mass(radius), cross section(radius), and   terminal velocity(radius) relationships defined as power laws. The coefficients are defined in the   CLIMAParameters.jl package   and are shown in the table below. For rain and ice they correspond to spherical liquid water drops   and ice particles, respectively. There is no assumed particle shape for snow, and the relationships are   empirical.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"m(r) = chi_m  m_0 left(fracrr_0right)^m_e + Delta_m","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"a(r) = chi_a  a_0 left(fracrr_0right)^a_e + Delta_a","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"v_term(r) = chi_v  v_0 left(fracrr_0right)^v_e + Delta_v","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"r is the particle radius,\nr_0 is the typical particle radius used to nondimensionalize,\nm_0  m_e  a_0  a_e  v_0  v_e  are the default coefficients,\nchi_m, Delta_m, chi_a, Delta_a, chi_v, Delta_v are the coefficients that can be used during model calibration to expand around the default values. Without calibration all chi parameters are set to 1 and all Delta parameters are set to 0.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The above coefficients, similarly to all other microphysics parameters,   are not hardcoded in the final microphysics parameterizations. The goal is to allow easy flexibility when calibrating the scheme. With that said, the assumption about the shape of the particles is used three   times when deriving the microphysics formulae:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The mass transfer equation (\\ref{eq:mass_rate}) used in snow autoconversion, rain evaporation, snow sublimation and snow melt rates is derived assuming spherical particle shapes. To correct for non-spherical shape it should be multiplied by a function of the particle aspect ratio.\nThe geometric collision kernel used for deriving rain-snow accretion rate assumes that both colliding particles are spherical. It does not take into account the reduced cross-section of snow particles that is used when modeling snow - cloud liquid water and snow - cloud ice accretion.\nIn the definition of the Reynolds number that is used when computing ventilation factors.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"symbol definition units default value reference\nr_0^rai typical rain drop radius m 10^-3 \nm_0^rai coefficient in m(r) for rain kg frac43  pi  rho_water  r_0^3 \nm_e^rai exponent in m(r) for rain - 3 \na_0^rai coefficient in a(r) for rain m^2 pi  r_0^2 \na_e^rai exponent in a(r) for rain - 2 \nv_e^rai exponent in v_term(r) for rain - 05 \n    \nr_0^ice typical ice crystal radius m 10^-5 \nm_0^ice coefficient in m(r) for ice kg frac43  pi  rho_ice  r_0^3 \nm_e^ice exponent in m(r) for ice - 3 \n    \nr_0^sno typical snow crystal radius m 10^-3 \nm_0^sno coefficient in m(r) for snow kg 01   r_0^2 eq (6b) Grabowski_1998\nm_e^sno exponent in m(r) for snow - 2 eq (6b) Grabowski_1998\na_0^sno coefficient in a(r) for snow m^2 03 pi  r_0^2 alpha in eq(16b) Grabowski_1998.\na_e^sno exponent in a(r) for snow - 2 \nv_0^sno coefficient in v_term(r) for snow fracms 2^94 r_0^14 eq (6b) Grabowski_1998\nv_e^sno exponent in v_term(r) for snow - 025 eq (6b) Grabowski_1998","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"rho_water is the density of water,\nrho_ice is the density of ice.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The terminal velocity of an individual rain drop is defined by the balance   between the gravitational acceleration (taking into account   the density difference between water and air) and the drag force. Therefore the v_0^rai is defined as","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nv_0^rai =\n  left(\n    frac83  C_drag left( fracrho_waterrho -1 right)\n  right)^12 (g r_0^rai)^12\nlabeleqvdrop\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"g is the gravitational acceleration,\nC_drag is the drag coefficient,\nrho is the density of air.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"note: Note\nIt would be great to replace the above simple power laws with more accurate relationships. For example: Khvorostyanov_and_Curry_2002 or Karrer_et_al_2020","category":"page"},{"location":"Theory/Atmos/Microphysics/#Assumed-particle-size-distributions","page":"Microphysics","title":"Assumed particle size distributions","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The particle size distributions are assumed to follow   Marshall-Palmer distribution   Marshall_and_Palmer_1948   eq. 1:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  n(r) = n_0 expleft(- lambda  r right)\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"n_0 and lambda are the Marshall-Palmer distribution parameters.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The n_0 for rain and ice is assumed constant. The n_0 for snow is defined as","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  n_0^sno = mu^sno left(fracrhorho_0 q_snoright)^nu^sno\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"mu^sno and nu^sno are the coefficients\nrho_0 is the typical air density used to nondimensionalize the equation and is equal to 1  kgm^3","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The coefficients are defined in   CLIMAParameters.jl package and are shown in the table below.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"symbol definition units default value reference\nn_0^rai rain drop size distribution parameter frac1m^4 16 cdot 10^6 eq (2) Marshall_and_Palmer_1948\nn_0^ice cloud ice size distribution parameter frac1m^4 2 cdot 10^7 bottom of page 4396 Kaul_et_al_2015\nmu^sno snow size distribution parameter coefficient frac1m^4 436 cdot 10^9  rho_0^nu^sno eq (A1) Kaul_et_al_2015\nnu^sno snow size distribution parameter exponent - 063 eq (A1) Kaul_et_al_2015","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The lambda parameter is defined as","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nlambda =\n  left(\n    frac Gamma(m_e + Delta_m + 1)  chi_m  m_0  n_0\n         q  rho  (r_0)^m_e + Delta_m\n  right)^frac1m_e + Delta_m + 1\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"q is rain, snow or ice specific humidity\nchi_m, m_0, m_e, Delta_m, r_0, and n_0 are the corresponding mass(radius) and size distribution parameters\nGamma() is the gamma function","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The cloud-ice size distribution is used   when computing snow autoconversion rate and rain sink due to accretion. In other derivations cloud ice, similar to cloud liquid water,   is treated as continuous.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"note: Note\nDo we want to keep the n_0 for rain constant and n_0 for snow empirical?\nDo we want to test different size distributions?","category":"page"},{"location":"Theory/Atmos/Microphysics/#Parameterized-processes","page":"Microphysics","title":"Parameterized processes","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Parameterized processes include:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"diffusion of water vapour on cloud droplets and cloud ice crystals modeled as a relaxation to equilibrium,\nautoconversion of rain and snow,\naccretion,\nevaporation of rain water,\nsublimation, vapor deposition and melting of snow,\nsedimentation of rain and snow with mass weighted average terminal velocity (cloud water and cloud ice are part of the working fluid and do not sediment).","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Parameters used in the parameterization are defined in   CLIMAParameters.jl package. They consist of:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"symbol definition units default value reference\nC_drag rain drop drag coefficient - 055 C_drag is such that the mass averaged terminal velocity is close to Smolarkiewicz_and_Grabowski_1996\ntau_cond_evap cloud water condensation/evaporation timescale s 10 \ntau_dep_sub cloud ice deposition/sublimation timescale s 10 \ntau_acnv cloud to rain water autoconversion timescale s 10^3 eq (5a) Smolarkiewicz_and_Grabowski_1996\nq_liq_threshold cloud to rain water autoconversion threshold - 5 cdot 10^-4 eq (5a) Smolarkiewicz_and_Grabowski_1996\nr_is threshold particle radius between ice and snow m 625 cdot 10^-6 abstract Harrington_1995\nE_lr collision efficiency between rain drops and cloud droplets - 08 eq (16a) Grabowski_1998\nE_ls collision efficiency between snow and cloud droplets - 01 Appendix B Rutledge_and_Hobbs_1983\nE_ir collision efficiency between rain drops and cloud ice - 1 Appendix B Rutledge_and_Hobbs_1984\nE_is collision efficiency between snow and cloud ice - 01 bottom page 3649 Morrison_and_Gettelman_2008\nE_rs collision efficiency between rain drops and snow - 1 top page 3650 Morrison_and_Gettelman_2008\na_vent^rai b_vent^rai rain drop ventilation factor coefficients - 15 , 053 chosen such that at q_tot=15 gkg and T=288K the evap. rate is close to empirical evap. rate in Smolarkiewicz_and_Grabowski_1996\na_vent^sno b_vent^sno snow ventilation factor coefficients - 065 , 044 eq (A19) Kaul_et_al_2015\nK_therm thermal conductivity of air fracJm  s  K 24 cdot 10^-2 \nnu_air kinematic viscosity of air fracm^2s 16 cdot 10^-5 \nD_vapor diffusivity of water vapor fracm^2s 226 cdot 10^-5 ","category":"page"},{"location":"Theory/Atmos/Microphysics/#Ventilation-factor","page":"Microphysics","title":"Ventilation factor","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The ventilation factor parameterizes the increase in the mass and heat exchange   for falling particles. Following Seifert_and_Beheng_2006   eq. 24  the ventilation factor is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  F(r) = a_vent + b_vent  N_Sc^13 N_Re(r)^12\nlabeleqventil_factor\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"a_vent, b_vent are coefficients,\nN_Sc is the Schmidt number,\nN_Re is the Reynolds number of a falling particle.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The Schmidt number is assumed constant:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"N_Sc = fracnu_airD_vapor","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"nu_air is the kinematic viscosity of air,\nD_vapor is the diffusivity of water.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The Reynolds number of a spherical drop is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"N_Re = frac2  r  v_term(r)nu_air","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Applying the terminal velocity(radius) relationship results in","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nF(r) = a_vent +\n       b_vent \n       left(fracnu_airD_vaporright)^frac13 \n       left(frac2  chi_v  v_0\n                  r_0^v_e + Delta_v  nu_airright)^frac12 \n       r^fracv_e + Delta_v + 12\nlabeleqvent_factor\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#Terminal-velocity","page":"Microphysics","title":"Terminal velocity","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The mass weighted terminal velocity v_t is defined following Ogura_and_Takahashi_1971:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  v_t = fracint_0^infty n(r)  m(r)  v_term(r)  dr\n             int_0^infty n(r)  m(r)  dr\nlabeleqvt\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Integrating over the assumed Marshall-Palmer distribution and using the   m(r) and v_term(r) relationships results in","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  v_t = chi_v  v_0  left(frac1r_0  lambdaright)^v_e + Delta_v\n        fracGamma(m_e + v_e + Delta_m + Delta_v + 1)\n             Gamma(m_e + Delta_m + 1)\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"note: Note\nAssuming a constant drag coefficient is an approximation and it should be size and flow dependent. <!– drag_coefficient –> In general we should implement these terminal velocity parameterizations: Khvorostyanov_and_Curry_2002 or Karreretal_2020","category":"page"},{"location":"Theory/Atmos/Microphysics/#Cloud-water-condensation/evaporation","page":"Microphysics","title":"Cloud water condensation/evaporation","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Condensation and evaporation of cloud liquid water is parameterized   as a relaxation to equilibrium value at the current time step.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_liqdt right_cond evap =\n    fracq^eq_liq - q_liqtau_cond_evap\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"q^eq_liq - liquid water specific humidity in equilibrium,\nq_liq - liquid water specific humidity,\ntau_cond_evap - relaxation timescale.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Cloud-ice-deposition/sublimation","page":"Microphysics","title":"Cloud ice deposition/sublimation","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Deposition and sublimation of cloud ice is parameterized as   a relaxation to equilibrium value at the current time step.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_icedt right_dep sub =\n    fracq^eq_ice - q_icetau_dep_sub\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"q^eq_ice - ice specific humidity in equilibrium,\nq_ice - ice specific humidity,\ntau_dep_sub - relaxation timescale.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"note: Note\nBoth tau_cond_evap and tau_dep_sub are assumed constant here. It would be great to make the relaxation time a function of available condensation nuclei, turbulence intensity, etc. See works by prof Raymond Shaw for hints. In particular, Desai et al., 2019.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Rain-autoconversion","page":"Microphysics","title":"Rain autoconversion","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Rain autoconversion defines the rate of conversion form cloud liquid water   to rain water due to collisions between cloud droplets. It is parameterized following   Kessler_1995:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_raidt right_acnv =\n    fracmax(0 q_liq - q_liq_threshold)tau_acnv\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"q_liq - liquid water specific humidity,\ntau_acnv - timescale,\nq_liq_threshold - autoconversion threshold.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"note: Note\nThis is the simplest possible autoconversion parameterization. It would be great to implement others and test the impact on precipitation. See for example Wood_2005 Table 1 for other simple choices.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Snow-autoconversion","page":"Microphysics","title":"Snow autoconversion","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Snow autoconversion defines the rate of conversion form cloud ice to snow due   the growth of cloud ice by water vapor deposition. It is defined as the change of mass of cloud ice for cloud ice particles   larger than threshold r_is. See Harrington_1995   for derivation.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_snodt right_acnv =\n  frac1rho fracddt\n    left( int_r_is^infty m(r) n(r) dr right) =\n    left frac1rho fracdrdt right_r=r_is m(r_is) n(r_is)\n    + frac1rho int_r_is^infty fracdmdt n(r) dr\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The fracdmdt is obtained by solving the water vapor diffusion equation   in spherical coordinates and linking the changes in temperature at the drop   surface to the changes in saturated vapor pressure via the Clausius-Clapeyron   equation, following   Mason_1971.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"For the simplest case of spherical particles and not taking into account   ventilation effects:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nfracdmdt = 4 pi  r  (S - 1)  G(T)\nlabeleqmass_rate\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"S(q_vap q_vap^sat) = fracq_vapq_vap^sat is saturation,\nq_vap^sat   is the saturation vapor specific humidity (over ice in this case),\nG(T) = left(fracL_sKT left(fracL_sR_v T - 1 right) + fracR_v Tp_vap^sat D right)^-1   combines the effects of thermal conductivity and water diffusivity.\nL_s is the latent heat of sublimation,\nK_thermo is the thermal conductivity of air,\nR_v is the gas constant of water vapor,\nD_vapor is the diffusivity of water vapor","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Using eq. (\\ref{eq:mass_rate}) and the assumed m(r) relationship we obtain","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nfracdrdt = frac4 pi  (S - 1)chi_m  (m_e + Delta_m)\n   left( fracr_0r right)^m_e + Delta_m\n   fracG(T)  r^2m_0\nlabeleqr_rate\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Finally the snow autoconversion rate is computed as","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_snodt right_acnv =\n   frac1rho 4 pi  (S-1)  G(T) \n   n_0^ice  exp(-lambda_ice r_is)\n   left( fracr_is^2m_e^ice + Delta_m^ice +\n   fracr_is lambda_ice +1lambda_ice^2 right)\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"note: Note\nWe should include ventilation effects.For non-spherical particles the mass rate of growth should be multiplied by a function depending on the particle aspect ratio. For functions proposed for different crystal habitats see Harrington_1995 Appendix B.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Accretion","page":"Microphysics","title":"Accretion","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Accretion defines the rates of conversion between different categories due to   collisions between particles.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"For the case of collisions between cloud water (liquid water or ice)   and precipitation (rain or snow) the sink of cloud water is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_cdt right_accr =\n  - int_0^infty n_p(r)  a^p(r)  v_term(r)  E_cp  q_c  dr\nlabeleqaccr_1\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"c subscript indicates cloud water category (cloud liquid water or ice)\np subscript indicates precipitation category (rain or snow)\nE_cp is the collision efficiency.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Integrating over the distribution yields:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_cdt right_accr =\n  - n_0^p  Pi_a v^p  q_c  E_cp \n    Gamma(Sigma_a v^p + 1) \n    frac1lambda^p \n    left( frac1r_0^p lambda^p\n    right)^Sigma_a v^p\nlabeleqaccrfin\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Pi_a v^p = a_0^p  v_0^p  chi_a^p  chi_v^p\nSigma_a v^p = a_e^p + v_e^p + Delta_a^p + Delta_v^p","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"For the case of cloud liquid water and rain and cloud ice and snow collisions,   the sink of cloud water becomes simply the source for precipitation. For the case of cloud liquid water and snow collisions   for temperatures below freezing, the sink of cloud liquid water is   a source for snow. For temperatures above freezing, the accreted cloud droplets   along with some melted snow are converted to rain. In this case eq. (\\ref{eq:accrfin}) describes the sink of cloud liquid water. The sink of snow is proportional to the sink of cloud liquid water with the coefficient fracc_wL_f(T - T_freeze).","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The collisions between cloud ice and rain create snow. The source of snow in this case is a sum of sinks from cloud ice and rain. The sink of cloud ice is defined by eq. (\\ref{eq:accrfin}). The sink of rain is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_accr_ri =\n  - int_0^infty int_0^infty\n  frac1rho  E_ir  n_i(r_i)  n_r(r_r)  a_r(r_r)  m_r(r_r)\n   v_term(r_r)  d r_i d r_r\nlabeleqaccr_ir\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"E_ir is the collision efficiency between rain and cloud ice\nn_i and n_r are the cloud ice and rain size distributions\nm_r, a_r and v_term are the mass(radius),   cross section(radius) and terminal velocity(radius) relations for rain\nr_i and r_r mark integration over cloud ice and rain size   distributions","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Integrating eq.(\\ref{eq:accr_ir}) yields:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_accr_ri =\n  - frac1rho  E_ir  n_0^rai  n_0^ice \n  Pi_m a v^rai\n  Gamma(Sigma_m a v^rai + 1) \n  frac1lambda^ice  lambda^rai \n  left( frac1r_0^rai  lambda^rai\n  right)^Sigma_m a v^rai\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Pi_m a v^rai =  m_0^rai  a_0^rai  v_0^rai  chi_m^rai  chi_a^rai  chi_v^rai\nSigma_m a v^rai = m_e^rai + a_e^rai + v_e^rai + Delta_m^rai + Delta_a^rai + Delta_v^rai","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Collisions between rain and snow result in snow in temperatures below freezing   and in rain in temperatures above freezing. The source term is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_idt right_accr =\n    int_0^infty int_0^infty frac1rho\n    n_i(r_i)  n_j(r_j)  a(r_i r_j)  m_j(r_j)  E_ij \n    leftv_term(r_i) - v_term(r_j)right  dr_i dr_j\nlabeleqaccr_sr1\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"i stands for rain (TT_freezing) or snow (TT_freezing)\nj stands for snow (TT_freezing) or rain (TT_freezing)\na(r_i r_j) is the crossection of the two colliding particles","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"There are two additional assumptions that we make to integrate   eq.(\\ref{eq:accr_sr1}):","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"leftv_term(r_i) - v_term(r_j)right approx left v_ti - v_tj right We approximate the terminal velocity difference for each particle pair with a difference between mass-weighted mean terminal velocities and move it outside of the integral. See the discussion in Ikawa_and_Saito_1991 page 88.\nWe assume that a(r_i r_j) = pi (r_i + r_j)^2. This corresponds to a geometric formulation of the collision kernel, aka cylindrical formulation, see Wang_et_al_2005 for discussion.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The eq.(\\ref{eq:accr_sr1}) can then be integrated as:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginalign\nleft fracd  q_idt right_accr  =\n    frac1rho  pi  n_0^i  n_0^j \n    m_0^j  chi_m^j  left(frac1r_0^jright)^m_e^j + Delta_m^j\n     E_ij left v_ti - v_tj right\n    int_0^infty int_0^infty\n    (r_i + r_j)^2\n    r_j^m_e^j + Delta_m^j \n    exp(- lambda_j r_j) \n    exp(- lambda_i r_i) \n    dr_i dr_j \n     =\n    frac1rho  pi  n_0^i  n_0^j  m_0^j  chi_m^j \n    E_ij left v_ti - v_tj right \n    left( frac1r_0^j right)^m_e^j + Delta_m^j\n    left(\n        frac2 Gamma(m_e^j + Delta_m^j + 1)lambda_i^3 lambda_j^m_e^j + Delta_m^j + 1\n        + frac2 Gamma(m_e^j + Delta_m^j + 2) lambda_i^2 lambda_j^m_e^j + Delta_m^j + 2\n        + fracGamma(m_e^j + Delta_m^j + 3)lambda_i lambda_j^m_e^j + Delta_m^j + 3\n    right)\nendalign","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"note: Note\nBoth of the assumptions needed to integrate the snow-rain accretion rate could be revisited:The discussion on page 88 in Ikawa_and_Saito_1991 suggests an alternative approximation of the velocity difference.The (r_i + r_j)^2 assumption for the crossection is inconsistent with the snow crossection used when modelling collisions with cloud water and cloud ice.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Rain-evaporation-and-snow-sublimation","page":"Microphysics","title":"Rain evaporation and snow sublimation","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"We start from a similar equation as when computing snow autoconversion rate but integrate it from 0 to infty.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracdqdt right_evap_subl =\n    frac1rho int_0^infty fracdm(r)dt n(r) dr\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"In contrast to eq.(\\ref{eq:mass_rate}), now we are taking into account   ventilation effects:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  fracdmdt = 4 pi  r  (S - 1)  G(T)  F(r)\nlabeleqmass_rate2\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"F(r) is the rain drop ventilation factor defined in (\\ref{eq:ventil_factor})\nsaturation S is computed over water or ice","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"The final integral is:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginalign\nleft fracdqdt right_evap_subl  =\n    frac4 pi n_0rho (S - 1) G(T)\n    int_0^infty\n    left(\n       a_vent +\n       b_vent \n         left(fracnu_airD_vapor right)^frac13 \n         left(fracrr_0 right)^fracv_e + Delta_v2 \n         left(frac2  chi_v  v_0  rnu_air right)^frac12\n    right)\n    r  exp(-lambda r) dr \n     =\n    frac4 pi n_0rho (S - 1) G(T) lambda^-2\n    left(\n       a_vent +\n       b_vent \n         left(fracnu_airD_vapor right)^frac13 \n         left(frac1r_0  lambda right)^fracv_e + Delta_v2 \n         left(frac2  chi_v  v_0nu_air  lambda right)^frac12 \n         Gammaleft( fracv_e + Delta_v + 52 right)\n    right)\nendalign","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"For the case of rain we only consider evaporation (S - 1  0). For the case of snow we consider both the source term due to vapor deposition  on snow (S - 1  0) and the sink due to vapor sublimation (S - 1  0).","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"note: Note\nWe should take into account the non-spherical snow shape. Modify the Reynolds number and growth equation.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Snow-melt","page":"Microphysics","title":"Snow melt","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"If snow occurs in temperatures above freezing it is melting into rain. The sink for snow is parameterized again as","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracdqdt right_melt =\n    frac1rho int_0^infty fracdm(r)dt n(r) dr\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"For snow melt","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\n  fracdmdt = 4 pi  r  fracK_thermoL_f (T - T_freeze)  F(r)\nlabeleqmass_rate3\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"F(r) is the ventilation factor defined in (\\ref{eq:ventil_factor})\nL_f is the latent heat of freezing.","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"If T  T_freeze:","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracdqdt right_evap_subl =\n    frac4 pi  n_0  K_thermorho  L_f (T - T_freeze) lambda^-2\n    left(\n       a_vent +\n       b_vent \n         left( fracnu_airD_vapor right)^frac13 \n         left( frac1r_0  lambda right)^fracv_e + Delta_v2 \n         left( frac2  chi_v  v_0nu_air  lambda right)^frac12 \n         Gamma left( fracv_e + Delta_v + 52 right)\n    right)\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#Example-figures","page":"Microphysics","title":"Example figures","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"using Plots\n\nusing ClimateMachine.Microphysics\nusing ClimateMachine.Thermodynamics\n\nusing CLIMAParameters\nusing CLIMAParameters.Planet: R_d, planet_radius, grav, MSLP, molmass_ratio\nusing CLIMAParameters.Atmos.Microphysics\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nstruct LiquidParameterSet <: AbstractLiquidParameterSet end\nstruct RainParameterSet <: AbstractRainParameterSet end\nstruct IceParameterSet <: AbstractIceParameterSet end\nstruct SnowParameterSet <: AbstractSnowParameterSet end\n\nconst param_set = EarthParameterSet()\nconst liquid_param_set = LiquidParameterSet()\nconst rain_param_set = RainParameterSet()\nconst ice_param_set = IceParameterSet()\nconst snow_param_set = SnowParameterSet()\n\n# eq. 5d in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction terminal_velocity_empirical(q_rai::DT, q_tot::DT, ρ::DT, ρ_air_ground::DT) where {DT<:Real}\n    rr  = q_rai / (DT(1) - q_tot)\n    vel = DT(14.34) * ρ_air_ground^DT(0.5) * ρ^-DT(0.3654) * rr^DT(0.1346)\n    return vel\nend\n\n# eq. 5b in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction accretion_empirical(q_rai::DT, q_liq::DT, q_tot::DT) where {DT<:Real}\n    rr  = q_rai / (DT(1) - q_tot)\n    rl  = q_liq / (DT(1) - q_tot)\n    return DT(2.2) * rl * rr^DT(7/8)\nend\n\n# eq. 5c in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction rain_evap_empirical(q_rai::DT, q::PhasePartition, T::DT, p::DT, ρ::DT) where {DT<:Real}\n\n    ts_neq = PhaseNonEquil_ρTq(param_set, ρ, T, q)\n    q_sat  = q_vap_saturation(ts_neq)\n    q_vap  = q.tot - q.liq\n    rr     = q_rai / (DT(1) - q.tot)\n    rv_sat = q_sat / (DT(1) - q.tot)\n    S      = q_vap/q_sat - DT(1)\n\n    ag, bg = 5.4 * 1e2, 2.55 * 1e5\n    G = DT(1) / (ag + bg / p / rv_sat) / ρ\n\n    av, bv = 1.6, 124.9\n    F = av * (ρ/DT(1e3))^DT(0.525)  * rr^DT(0.525) + bv * (ρ/DT(1e3))^DT(0.7296) * rr^DT(0.7296)\n\n    return DT(1) / (DT(1) - q.tot) * S * F * G\nend\n\n# example values\nq_liq_range  = range(1e-8, stop=5e-3, length=100)\nq_ice_range  = range(1e-8, stop=5e-3, length=100)\nq_rain_range = range(1e-8, stop=5e-3, length=100)\nq_snow_range = range(1e-8, stop=5e-3, length=100)\nρ_air, ρ_air_ground = 1.2, 1.22\nq_liq, q_ice, q_tot = 5e-4, 5e-4, 20e-3\n\nplot( q_rain_range * 1e3, [terminal_velocity(param_set, rain_param_set, ρ_air, q_rai) for q_rai in q_rain_range],     linewidth=3, xlabel=\"q_rain or q_snow [g/kg]\", ylabel=\"terminal velocity [m/s]\", label=\"Rain-CLIMA\")\nplot!(q_snow_range * 1e3, [terminal_velocity(param_set, snow_param_set, ρ_air, q_sno) for q_sno in q_snow_range],     linewidth=3, label=\"Snow-CLIMA\")\nplot!(q_rain_range * 1e3, [terminal_velocity_empirical(q_rai, q_tot, ρ_air, ρ_air_ground) for q_rai in q_rain_range], linewidth=3, label=\"Rain-Empirical\")\nsavefig(\"terminal_velocity.svg\") # hide\n\nT = 273.15\nplot( q_liq_range * 1e3, [conv_q_liq_to_q_rai(rain_param_set, q_liq) for q_liq in q_liq_range], linewidth=3, xlabel=\"q_liq or q_ice [g/kg]\", ylabel=\"autoconversion rate [1/s]\", label=\"Rain\")\nplot!(q_ice_range * 1e3, [conv_q_ice_to_q_sno(param_set, ice_param_set, PhasePartition(q_tot, 0., q_ice), ρ_air, T-5)  for q_ice in q_ice_range], linewidth=3, label=\"Snow T=-5C\")\nplot!(q_ice_range * 1e3, [conv_q_ice_to_q_sno(param_set, ice_param_set, PhasePartition(q_tot, 0., q_ice), ρ_air, T-10) for q_ice in q_ice_range], linewidth=3, label=\"Snow T=-15C\")\nplot!(q_ice_range * 1e3, [conv_q_ice_to_q_sno(param_set, ice_param_set, PhasePartition(q_tot, 0., q_ice), ρ_air, T-15) for q_ice in q_ice_range], linewidth=3, label=\"Snow T=-25C\")\nsavefig(\"autoconversion_rate.svg\") # hide\n\nplot( q_rain_range * 1e3, [accretion(param_set, liquid_param_set, rain_param_set, q_liq, q_rai, ρ_air) for q_rai in q_rain_range], linewidth=3, xlabel=\"q_rain or q_snow [g/kg]\", ylabel=\"accretion rate [1/s]\", label=\"Liq+Rain-CLIMA\")\nplot!(q_rain_range * 1e3, [accretion(param_set, ice_param_set,    rain_param_set, q_ice, q_rai, ρ_air) for q_rai in q_rain_range], linewidth=3, label=\"Ice+Rain-CLIMA\")\nplot!(q_snow_range * 1e3, [accretion(param_set, liquid_param_set, snow_param_set, q_liq, q_sno, ρ_air) for q_sno in q_snow_range], linewidth=3, label=\"Liq+Snow-CLIMA\")\nplot!(q_snow_range * 1e3, [accretion(param_set, ice_param_set,    snow_param_set, q_ice, q_sno, ρ_air) for q_sno in q_snow_range], linewidth=4, linestyle=:dash, label=\"Ice+Snow-CLIMA\")\nplot!(q_rain_range * 1e3, [accretion_empirical(q_rai, q_liq, q_tot) for q_rai in q_rain_range], linewidth=3, label=\"Liq+Rain-Empirical\")\nsavefig(\"accretion_rate.svg\") # hide\n\nq_ice = 1e-6\nplot(q_rain_range * 1e3, [accretion_rain_sink(param_set, ice_param_set, rain_param_set, q_ice, q_rai, ρ_air) for q_rai in q_rain_range], linewidth=3, xlabel=\"q_rain or q_snow [g/kg]\", ylabel=\"accretion rain sink rate [1/s]\", label=\"q_ice=1e-6\")\nq_ice = 1e-5\nplot!(q_rain_range * 1e3, [accretion_rain_sink(param_set, ice_param_set, rain_param_set, q_ice, q_rai, ρ_air) for q_rai in q_rain_range], linewidth=3, xlabel=\"q_rain or q_snow [g/kg]\", ylabel=\"accretion rain sink rate [1/s]\", label=\"q_ice=1e-5\")\nq_ice = 1e-4\nplot!(q_rain_range * 1e3, [accretion_rain_sink(param_set, ice_param_set, rain_param_set, q_ice, q_rai, ρ_air) for q_rai in q_rain_range], linewidth=3, xlabel=\"q_rain or q_snow [g/kg]\", ylabel=\"accretion rain sink rate [1/s]\", label=\"q_ice=1e-4\")\nsavefig(\"accretion_rain_sink_rate.svg\") # hide\n\nq_sno = 1e-6\nplot(q_rain_range * 1e3, [accretion_snow_rain(param_set, rain_param_set, snow_param_set, q_rai, q_sno, ρ_air) for q_rai in q_rain_range], linewidth=3, xlabel=\"q_rain [g/kg]\", ylabel=\"snow-rain accretion rate [1/s] T>0\", label=\"q_snow=1e-6\")\nq_sno = 1e-5\nplot!(q_rain_range * 1e3, [accretion_snow_rain(param_set, rain_param_set, snow_param_set, q_rai, q_sno, ρ_air) for q_rai in q_rain_range], linewidth=3, label=\"q_snow=1e-5\")\nq_sno = 1e-4\nplot!(q_rain_range * 1e3, [accretion_snow_rain(param_set, rain_param_set, snow_param_set, q_rai, q_sno, ρ_air) for q_rai in q_rain_range], linewidth=3, label=\"q_snow=1e-4\")\nsavefig(\"accretion_snow_rain_above_freeze.svg\") # hide\n\nq_rai = 1e-6\nplot(q_snow_range * 1e3, [accretion_snow_rain(param_set, snow_param_set, rain_param_set, q_sno, q_rai, ρ_air) for q_sno in q_snow_range], linewidth=3, xlabel=\"q_snow [g/kg]\", ylabel=\"snow-rain accretion rate [1/s] T<0\", label=\"q_rain=1e-6\")\nq_rai = 1e-5\nplot!(q_snow_range * 1e3, [accretion_snow_rain(param_set, snow_param_set, rain_param_set, q_sno, q_rai, ρ_air) for q_sno in q_snow_range], linewidth=3, label=\"q_rain=1e-5\")\nq_rai = 1e-4\nplot!(q_snow_range * 1e3, [accretion_snow_rain(param_set, snow_param_set, rain_param_set, q_sno, q_rai, ρ_air) for q_sno in q_snow_range], linewidth=3, label=\"q_rain=1e-4\")\nsavefig(\"accretion_snow_rain_below_freeze.svg\") # hide\n\n# example values\nT, p = 273.15 + 15, 90000.\nϵ = 1. / molmass_ratio(param_set)\np_sat = saturation_vapor_pressure(param_set, T, Liquid())\nq_sat = ϵ * p_sat / (p + p_sat * (ϵ - 1.))\nq_rain_range = range(1e-8, stop=5e-3, length=100)\nq_tot = 15e-3\nq_vap = 0.15 * q_sat\nq_ice = 0.\nq_liq = q_tot - q_vap - q_ice\nq = PhasePartition(q_tot, q_liq, q_ice)\nR = gas_constant_air(param_set, q)\nρ = p / R / T\n\nplot(q_rain_range * 1e3,  [evaporation_sublimation(param_set, rain_param_set, q, q_rai, ρ, T) for q_rai in q_rain_range], xlabel=\"q_rain [g/kg]\", linewidth=3, ylabel=\"rain evaporation rate [1/s]\", label=\"ClimateMachine\")\nplot!(q_rain_range * 1e3, [rain_evap_empirical(q_rai, q, T, p, ρ) for q_rai in q_rain_range], linewidth=3, label=\"empirical\")\nsavefig(\"rain_evaporation_rate.svg\") # hide\n\n# example values\nT, p = 273.15 - 15, 90000.\nϵ = 1. / molmass_ratio(param_set)\np_sat = saturation_vapor_pressure(param_set, T, Ice())\nq_sat = ϵ * p_sat / (p + p_sat * (ϵ - 1.))\nq_snow_range = range(1e-8, stop=5e-3, length=100)\nq_tot = 15e-3\nq_vap = 0.15 * q_sat\nq_liq = 0.\nq_ice = q_tot - q_vap - q_ice\nq = PhasePartition(q_tot, q_liq, q_ice)\nR = gas_constant_air(param_set, q)\nρ = p / R / T\n\nplot(q_snow_range * 1e3,  [evaporation_sublimation(param_set, snow_param_set, q, q_sno, ρ, T) for q_sno in q_snow_range], xlabel=\"q_snow [g/kg]\", linewidth=3, ylabel=\"snow deposition sublimation rate [1/s]\", label=\"T<0\")\n\nT, p = 273.15 + 15, 90000.\nϵ = 1. / molmass_ratio(param_set)\np_sat = saturation_vapor_pressure(param_set, T, Ice())\nq_sat = ϵ * p_sat / (p + p_sat * (ϵ - 1.))\nq_snow_range = range(1e-8, stop=5e-3, length=100)\nq_tot = 15e-3\nq_vap = 0.15 * q_sat\nq_liq = 0.\nq_ice = q_tot - q_vap - q_ice\nq = PhasePartition(q_tot, q_liq, q_ice)\nR = gas_constant_air(param_set, q)\nρ = p / R / T\n\nplot!(q_snow_range * 1e3,  [evaporation_sublimation(param_set, snow_param_set, q, q_sno, ρ, T) for q_sno in q_snow_range], xlabel=\"q_snow [g/kg]\", linewidth=3, ylabel=\"snow deposition sublimation rate [1/s]\", label=\"T>0\")\nsavefig(\"snow_sublimation_deposition_rate.svg\") # hide\n\nT=273.15\nplot( q_snow_range * 1e3,  [snow_melt(param_set, snow_param_set, q_sno, ρ, T+2) for q_sno in q_snow_range], xlabel=\"q_snow [g/kg]\", linewidth=3, ylabel=\"snow melt rate [1/s]\", label=\"T=2C\")\nplot!(q_snow_range * 1e3,  [snow_melt(param_set, snow_param_set, q_sno, ρ, T+4) for q_sno in q_snow_range], xlabel=\"q_snow [g/kg]\", linewidth=3, label=\"T=4C\")\nplot!(q_snow_range * 1e3,  [snow_melt(param_set, snow_param_set, q_sno, ρ, T+6) for q_sno in q_snow_range], xlabel=\"q_snow [g/kg]\", linewidth=3, label=\"T=6C\")\nsavefig(\"snow_melt_rate.svg\") # hide\n","category":"page"},{"location":"Theory/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"APIs/Common/Orientations/#Orientations","page":"Orientations","title":"Orientations","text":"","category":"section"},{"location":"APIs/Common/Orientations/","page":"Orientations","title":"Orientations","text":"CurrentModule = ClimateMachine.Orientations","category":"page"},{"location":"APIs/Common/Orientations/","page":"Orientations","title":"Orientations","text":"Orientations","category":"page"},{"location":"APIs/Common/Orientations/#ClimateMachine.Orientations","page":"Orientations","title":"ClimateMachine.Orientations","text":"Orientations\n\nOrientation functions:\n\nvertical_unit_vector\naltitude\nlatitude\nlongitude\ngravitational_potential\nprojection_normal\nprojection_tangential\n\nfor orientations:\n\nNoOrientation\nFlatOrientation\nSphericalOrientation\n\n\n\n\n\n","category":"module"},{"location":"APIs/Common/Orientations/#Types","page":"Orientations","title":"Types","text":"","category":"section"},{"location":"APIs/Common/Orientations/","page":"Orientations","title":"Orientations","text":"NoOrientation\nFlatOrientation\nSphericalOrientation\nsphr_to_cart_vec\ncart_to_sphr_vec","category":"page"},{"location":"APIs/Common/Orientations/#ClimateMachine.Orientations.NoOrientation","page":"Orientations","title":"ClimateMachine.Orientations.NoOrientation","text":"NoOrientation\n\nNo gravitational force or potential.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Orientations/#ClimateMachine.Orientations.FlatOrientation","page":"Orientations","title":"ClimateMachine.Orientations.FlatOrientation","text":"FlatOrientation <: Orientation\n\nGravity acts in the third coordinate, and the gravitational potential is relative to coord[3] == 0.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Orientations/#ClimateMachine.Orientations.SphericalOrientation","page":"Orientations","title":"ClimateMachine.Orientations.SphericalOrientation","text":"SphericalOrientation <: Orientation\n\nGravity acts towards the origin (0,0,0), and the gravitational potential is relative to the surface of the planet.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Orientations/#ClimateMachine.Orientations.sphr_to_cart_vec","page":"Orientations","title":"ClimateMachine.Orientations.sphr_to_cart_vec","text":"sphr_to_cart_vec(orientation::SphericalOrientation, state::Vars, aux::Vars)\n\nProjects a vector defined based on unit vectors in spherical coordinates to cartesian unit vectors.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Orientations/#ClimateMachine.Orientations.cart_to_sphr_vec","page":"Orientations","title":"ClimateMachine.Orientations.cart_to_sphr_vec","text":"cart_to_sphr_vec(orientation::SphericalOrientation, state::Vars, aux::Vars)\n\nProjects a vector defined based on unit vectors in cartesian coordinates to a spherical unit vectors.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Driver/Checkpoint/#Checkpoint","page":"Checkpoint","title":"Checkpoint","text":"","category":"section"},{"location":"APIs/Driver/Checkpoint/","page":"Checkpoint","title":"Checkpoint","text":"CurrentModule = ClimateMachine.Checkpoint","category":"page"},{"location":"APIs/Driver/Checkpoint/#Methods","page":"Checkpoint","title":"Methods","text":"","category":"section"},{"location":"APIs/Driver/Checkpoint/","page":"Checkpoint","title":"Checkpoint","text":"rm_checkpoint\nread_checkpoint\nwrite_checkpoint","category":"page"},{"location":"APIs/Driver/Checkpoint/#ClimateMachine.Checkpoint.rm_checkpoint","page":"Checkpoint","title":"ClimateMachine.Checkpoint.rm_checkpoint","text":"rm_checkpoint(checkpoint_dir, name, mpicomm, num)\n\nRemove the checkpoint file identified by solver_config.name and num.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Driver/Checkpoint/#ClimateMachine.Checkpoint.read_checkpoint","page":"Checkpoint","title":"ClimateMachine.Checkpoint.read_checkpoint","text":"read_checkpoint(checkpoint_dir, name, mpicomm, num)\n\nRead in the state and auxiliary arrays as well as the simulation time stored in the checkpoint file for name and num.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Driver/Checkpoint/#ClimateMachine.Checkpoint.write_checkpoint","page":"Checkpoint","title":"ClimateMachine.Checkpoint.write_checkpoint","text":"write_checkpoint(solver_config, checkpoint_dir, name, mpicomm, num)\n\nRead in the state and auxiliary arrays as well as the simulation time stored in the checkpoint file for name and num.\n\n\n\n\n\n","category":"function"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/densitycurrent.jl\"","category":"page"},{"location":"generated/Atmos/densitycurrent/#Density-Current","page":"LES Experiment (Density Current)","title":"Density Current","text":"","category":"section"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"In this example, we demonstrate the usage of the ClimateMachine  to solve the density current test by Straka 1993. We solve a flow in a box configuration, which is representative of a large-eddy simulation. Several versions of the problem setup may be found in literature, but the general idea is to examine the vertical ascent of a thermal bubble (we can interpret these as simple representation of convective updrafts).","category":"page"},{"location":"generated/Atmos/densitycurrent/#Description-of-experiment","page":"LES Experiment (Density Current)","title":"Description of experiment","text":"","category":"section"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"The setup described below is such that the simulation reaches completion (timeend = 900 s) in approximately 4 minutes of wall-clock time on 1 GPU","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Dry Density Current (circular potential temperature perturbation)\nBoundaries\nImpenetrable(FreeSlip()) - no momentum flux, no mass flux through walls.\nImpermeable() - non-porous walls, i.e. no diffusive fluxes through  walls.\nDomain - 25600m (horizontal) x 10000m (horizontal) x 6400m (vertical)\nResolution - 100m effective resolution\nTotal simulation time - 900s\nMesh Aspect Ratio (Effective resolution) 1:1\nOverrides defaults for\nCPU Initialisation\nTime integrator\nSources\nSmagorinsky Coefficient Csmag\nDefault settings can be found in src/Driver/<files>.jl","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"note: Note\nThis experiment setup assumes that you have installed the ClimateMachine according to the instructions on the landing page. We assume the users' familiarity with the conservative form of the equations of motion for a compressible fluidThe following topics are covered in this examplePackage requirements\nDefining a model subtype for the set of conservation equations\nDefining the initial conditions\nApplying boundary conditions\nApplying source terms\nChoosing a turbulence model\nAdding tracers to the model\nChoosing a time-integratorThe following topics are not covered in this exampleDefining new boundary conditions\nDefining new turbulence models\nBuilding new time-integrators","category":"page"},{"location":"generated/Atmos/densitycurrent/#Boilerplate-(Using-Modules)","page":"LES Experiment (Density Current)","title":"Boilerplate (Using Modules)","text":"","category":"section"},{"location":"generated/Atmos/densitycurrent/#[Skip-Section](@ref-init-dc)","page":"LES Experiment (Density Current)","title":"Skip Section","text":"","category":"section"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Before setting up our experiment, we recognize that we need to import some pre-defined functions from other packages. Julia allows us to use existing modules (variable workspaces), or write our own to do so.  Complete documentation for the Julia module system can be found here.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"We need to use the ClimateMachine module! This imports all functions specific to atmospheric and ocean flow modeling.  While we do not cover the ins-and-outs of the contents of each of these we provide brief descriptions of the utility of each of the loaded packages.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine\nClimateMachine.init(parse_clargs = true)\n\nusing ClimateMachine.Atmos\nusing ClimateMachine.Orientations","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required so that we inherit the appropriate model types for the large-eddy simulation (LES) and global-circulation-model (GCM) configurations.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine.ConfigTypes","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required so that we may define diagnostics configurations, e.g. choice of file-writer, choice of output variable sets, output-frequency and directory,","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine.Diagnostics","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required so that we may define (or utilise existing functions) functions that are called-back or executed at frequencies of either timesteps, simulation-time, or wall-clock time.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine.GenericCallbacks","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required so we load the appropriate functions for the time-integration component. Contains ODESolver methods.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine.ODESolvers","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required for utility of spatial filtering functions (e.g. positivity preservation)","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine.Mesh.Filters","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required so functions for computation of temperature profiles.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine.TemperatureProfiles","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required so functions for computation of moist thermodynamic quantities and turbulence closures","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"are available.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine.Thermodynamics\nusing ClimateMachine.TurbulenceClosures","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required so we may access our variable arrays by a sensible naming convention rather than by numerical array indices.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using ClimateMachine.VariableTemplates","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"Required so we may access planet parameters (CLIMAParameters specific to this problem include the gas constant, specific heats, mean-sea-level pressure, gravity and the Smagorinsky coefficient)","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"In ClimateMachine we use StaticArrays for our variable arrays.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using StaticArrays","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"We also use the Test package to help with unit tests and continuous integration systems to design sensible tests for our experiment to ensure new / modified blocks of code don't damage the fidelity of the physics. The test defined within this experiment is not a unit test for a specific subcomponent, but ensures time-integration of the defined problem conditions within a reasonable tolerance. Immediately useful macros and functions from this include @test and @testset which will allow us to define the testing parameter sets.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"using Test\n\nusing CLIMAParameters\nusing CLIMAParameters.Atmos.SubgridScale: C_smag\nusing CLIMAParameters.Planet: R_d, cp_d, cv_d, MSLP, grav\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()","category":"page"},{"location":"generated/Atmos/densitycurrent/#init-dc","page":"LES Experiment (Density Current)","title":"Initial Conditions","text":"","category":"section"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"note: Note\nThe following variables are assigned in the initial conditionstate.ρ = Scalar quantity for initial density profile\nstate.ρu= 3-component vector for initial momentum profile\nstate.ρe= Scalar quantity for initial total-energy profile humidity\nstate.tracers.ρχ = Vector of four tracers (here, for demonstration only; we can interpret these as dye injections for visualisation purposes)","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"function init_densitycurrent!(problem, bl, state, aux, localgeo, t)\n    (x, y, z) = localgeo.coord\n\n    # Problem float-type\n    FT = eltype(state)\n\n    # Unpack constant parameters\n    R_gas::FT = R_d(bl.param_set)\n    c_p::FT = cp_d(bl.param_set)\n    c_v::FT = cv_d(bl.param_set)\n    p0::FT = MSLP(bl.param_set)\n    _grav::FT = grav(bl.param_set)\n    γ::FT = c_p / c_v\n\n    # Define bubble center and background potential temperature\n    xc::FT = 0\n    yc::FT = 0\n    zc::FT = 3000\n    rx::FT = 4000\n    rz::FT = 2000\n    r = sqrt(((x - xc)^2) / rx^2 + ((z - zc)^2) / rz^2)\n\n    # TODO: clean this up, or add convenience function:\n    # This is configured in the reference hydrostatic state\n    θ_ref::FT = bl.ref_state.virtual_temperature_profile.T_surface\n    Δθ::FT = 0\n    θamplitude::FT = -15.0\n\n    # Compute temperature difference over bubble region\n    if r <= 1\n        Δθ = 0.5 * θamplitude * (1 + cospi(r))\n    end\n\n    # Compute perturbed thermodynamic state:\n    θ = θ_ref + Δθ                                      ## potential temperature\n    π_exner = FT(1) - _grav / (c_p * θ) * z             ## exner pressure\n    ρ = p0 / (R_gas * θ) * (π_exner)^(c_v / R_gas)      ## density\n    T = θ * π_exner\n    e_int = internal_energy(bl.param_set, T)\n    ts = PhaseDry(bl.param_set, e_int, ρ)\n    ρu = SVector(FT(0), FT(0), FT(0))                   ## momentum\n    # State (prognostic) variable assignment\n    e_kin = FT(0)                                       ## kinetic energy\n    e_pot = gravitational_potential(bl.orientation, aux)## potential energy\n    ρe_tot = ρ * total_energy(e_kin, e_pot, ts)         ## total energy\n\n    # Assign State Variables\n    state.ρ = ρ\n    state.ρu = ρu\n    state.ρe = ρe_tot\nend","category":"page"},{"location":"generated/Atmos/densitycurrent/#config-helper","page":"LES Experiment (Density Current)","title":"Model Configuration","text":"","category":"section"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"We define a configuration function to assist in prescribing the physical model.","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"function config_densitycurrent(FT, N, resolution, xmax, ymax, zmax)\n\n    # Choose an Explicit Single-rate Solver LSRK144 from the existing [ODESolvers](@ref\n    # ODESolvers-docs) options Apply the outer constructor to define the\n    ode_solver = ClimateMachine.ExplicitSolverType(\n        solver_method = LSRK144NiegemannDiehlBusch,\n    )\n\n    # The model coefficient for the turbulence closure is defined via the\n    # [CLIMAParameters\n    # package](https://CliMA.github.io/CLIMAParameters.jl/dev/) A reference\n    # state for the linearisation step is also defined.\n    T_surface = FT(300)\n    T_min_ref = FT(0)\n    T_profile = DryAdiabaticProfile{FT}(param_set, T_surface, T_min_ref)\n    ref_state = HydrostaticState(T_profile)\n\n    # The fun part! Here we assemble the `AtmosModel`.\n    ##md # !!! note\n    ##md #     Docs on model subcomponent options can be found here:\n    ##md #     - [`param_set`](https://CliMA.github.io/CLIMAParameters.jl/dev/)\n    ##md #     - [`turbulence`](@ref Turbulence-Closures-docs)\n    ##md #     - [`source`](@ref atmos-sources)\n    ##md #     - [`init_state`](@ref init-dc)\n\n    _C_smag = FT(0.21)\n    model = AtmosModel{FT}(\n        AtmosLESConfigType,                             # Flow in a box, requires the AtmosLESConfigType\n        param_set;                                      # Parameter set corresponding to earth parameters\n        init_state_prognostic = init_densitycurrent!,   # Apply the initial condition\n        ref_state = ref_state,                          # Reference state\n        turbulence = Vreman(_C_smag),                   # Turbulence closure model\n        moisture = DryModel(),                          # Exclude moisture variables\n        source = (Gravity(),),                          # Gravity is the only source term here\n        tracers = NoTracers(),                          # Tracer model with diffusivity coefficients\n    )\n\n    # Finally, we pass a `Problem Name` string, the mesh information, and the\n    # model type to  the [`AtmosLESConfiguration`](@ref ClimateMachine.AtmosLESConfiguration) object.\n    config = ClimateMachine.AtmosLESConfiguration(\n        \"DryDensitycurrent\",      # Problem title [String]\n        N,                        # Polynomial order [Int]\n        resolution,               # (Δx, Δy, Δz) effective resolution [m]\n        xmax,                     # Domain maximum size [m]\n        ymax,                     # Domain maximum size [m]\n        zmax,                     # Domain maximum size [m]\n        param_set,                # Parameter set.\n        init_densitycurrent!,     # Function specifying initial condition\n        solver_type = ode_solver, # Time-integrator type\n        model = model,            # Model type\n        periodicity = (false, false, false),\n        boundary = ((1, 1), (1, 1), (1, 1)),   # Set all boundaries to solid walls\n    )\n    return config\nend","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"note: Note\nKeywords are used to specify some arguments (see appropriate source files).","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"function main()\n    # These are essentially arguments passed to the\n    # [`config_densitycurrent`](@ref config-helper) function.  For type\n    # consistency we explicitly define the problem floating-precision.\n    FT = Float64\n    # We need to specify the polynomial order for the DG discretization,\n    # effective resolution, simulation end-time, the domain bounds, and the\n    # courant-number for the time-integrator. Note how the time-integration\n    # components `solver_config` are distinct from the spatial / model\n    # components in `driver_config`. `init_on_cpu` is a helper keyword argument\n    # that forces problem initialisation on CPU (thereby allowing the use of\n    # random seeds, spline interpolants and other special functions at the\n    # initialisation step.)\n    N = 4\n    Δx = FT(100)\n    Δy = FT(250)\n    Δv = FT(100)\n    resolution = (Δx, Δy, Δv)\n    xmax = FT(25600)\n    ymax = FT(1000)\n    zmax = FT(6400)\n    t0 = FT(0)\n    timeend = FT(100)\n    CFL = FT(1.5)\n\n    # Assign configurations so they can be passed to the `invoke!` function\n    driver_config = config_densitycurrent(FT, N, resolution, xmax, ymax, zmax)\n    solver_config = ClimateMachine.SolverConfiguration(\n        t0,\n        timeend,\n        driver_config,\n        init_on_cpu = true,\n        Courant_number = CFL,\n    )\n\n    # Invoke solver (calls `solve!` function for time-integrator), pass the driver, solver and diagnostic config\n    # information.\n    result =\n        ClimateMachine.invoke!(solver_config; check_euclidean_distance = true)\n\n    # Check that the solution norm is reasonable.\n    @test isapprox(result, FT(1); atol = 1.5e-2)\nend","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"The experiment definition is now complete. Time to run it. julia --project=$CLIMA_HOME tutorials/Atmos/densitycurrent.jl --vtk 1smins to run with VTK output enabled at intervals of 1 simulation minute.","category":"page"},{"location":"generated/Atmos/densitycurrent/#References","page":"LES Experiment (Density Current)","title":"References","text":"","category":"section"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"[1] J. Straka, R. Wilhelmson, L. Wicker, J. Anderson, K. Droegemeier, Numerical solution of a nonlinear density current: a benchmark solution and comparisons Int. J. Numer. Methods Fluids 17 (1993) 1–22,  https://doi.org/10.1002/fld.1650170103","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"[2] R. Carpenter, K. Droegemeier, P. Woodward, C. Hane, Application of the piecewise parabolic method (PPM) to meteorological modeling, Mon. Weather Rev. 118 (1990) 586–612, https://doi.org/10.1175/1520-0493(1990)118<0586:AOTPPM>2.0.CO;2","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"main()","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"","category":"page"},{"location":"generated/Atmos/densitycurrent/","page":"LES Experiment (Density Current)","title":"LES Experiment (Density Current)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Land/SoilWaterParameterizations/#Soil-Water-Parameterizations","page":"Soil Water Parameterizations","title":"Soil Water Parameterizations","text":"","category":"section"},{"location":"APIs/Land/SoilWaterParameterizations/","page":"Soil Water Parameterizations","title":"Soil Water Parameterizations","text":"CurrentModule = ClimateMachine.Land.SoilWaterParameterizations","category":"page"},{"location":"APIs/Land/SoilWaterParameterizations/#Water-functions","page":"Soil Water Parameterizations","title":"Water functions","text":"","category":"section"},{"location":"APIs/Land/SoilWaterParameterizations/","page":"Soil Water Parameterizations","title":"Soil Water Parameterizations","text":"AbstractImpedanceFactor\nNoImpedance\nIceImpedance\nimpedance_factor\nAbstractViscosityFactor\nConstantViscosity    \nTemperatureDependentViscosity\nviscosity_factor\nAbstractMoistureFactor\nMoistureDependent\nMoistureIndependent\nmoisture_factor\nAbstractHydraulicsModel\nvanGenuchten\nBrooksCorey\nHaverkamp\nhydraulic_conductivity\neffective_saturation\npressure_head\nhydraulic_head\nmatric_potential\nvolumetric_liquid_fraction","category":"page"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.AbstractImpedanceFactor","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.AbstractImpedanceFactor","text":"AbstractImpedanceFactor{FT <: AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.NoImpedance","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.NoImpedance","text":"NoImpedance{FT} <: AbstractImpedanceFactor{FT}\n\nA model to indicate to dependence on ice for the hydraulic conductivity.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.IceImpedance","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.IceImpedance","text":"IceImpedance{FT} <: AbstractImpedanceFactor{FT}\n\nThe necessary parameters for the empirical impedance factor due to ice.\n\nFields\n\nΩ\nEmpirical coefficient from Hansson 2014.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.impedance_factor","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.impedance_factor","text":"impedance_factor(\n    imp::NoImpedance{FT},\n    θ_i::FT,\n    θ_l::FT,\n) where {FT}\n\nReturns the impedance factor when no effect due to ice is desired.  Returns 1.\n\nThe other arguments are included to unify the function call.\n\n\n\n\n\nimpedance_factor(\n    imp::IceImpedance{FT},\n    θ_i::FT,\n    θ_l::FT,\n) where {FT}\n\nReturns the impedance factor when an effect due to the fraction of  ice is desired. \n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.AbstractViscosityFactor","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.AbstractViscosityFactor","text":"AbstractViscosityFactor{FT <: AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.ConstantViscosity","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.ConstantViscosity","text":"ConstantViscosity{FT} <: AbstractViscosityFactor{FT}\n\nA model to indicate a constant viscosity - independent of temperature -  factor in hydraulic conductivity.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.TemperatureDependentViscosity","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.TemperatureDependentViscosity","text":"TemperatureDependentViscosity{FT} <: AbstractViscosityFactor{FT}\n\nThe necessary parameters for the temperature dependent portion of hydraulic  conductivity.\n\nFields\n\nγ\nEmpirical coefficient\nT_ref\nReference temperature\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.viscosity_factor","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.viscosity_factor","text":"viscosity_factor(\n    vm::ConstantViscosity{FT},\n    T::FT,\n) where {FT}\n\nReturns the viscosity factor when we choose no temperature dependence, i.e.  a constant viscosity. Returns 1.\n\nT is included as an argument to unify the function call.\n\n\n\n\n\nviscosity_factor(\n    vm::TemperatureDependentViscosity{FT},\n    T::FT,\n) where {FT}\n\nReturns the viscosity factor when we choose a TemperatureDependentViscosity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.AbstractMoistureFactor","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.AbstractMoistureFactor","text":"AbstractMoistureFactor{FT <:AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.MoistureDependent","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.MoistureDependent","text":"MoistureDependent{FT} <: AbstractMoistureFactor{FT} end\n\nMoisture dependent moisture factor.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.MoistureIndependent","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.MoistureIndependent","text":"MoistureIndependent{FT} <: AbstractMoistureFactor{FT} end\n\nMoisture independent moisture factor.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.moisture_factor","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.moisture_factor","text":"moisture_factor(\n    mm::MoistureDependent{FT},\n    hm::vanGenuchten{FT},\n    S_l::FT,\n) where {FT}\n\nReturns the moisture factor of the hydraulic conductivy assuming a  MoistureDependent and van Genuchten hydraulic model.\n\n\n\n\n\nmoisture_factor(\n    mm::MoistureDependent{FT},\n    hm::BrooksCorey{FT},\n    S_l::FT,\n) where {FT}\n\nReturns the moisture factor of the hydraulic conductivy assuming a  MoistureDependent and Brooks/Corey hydraulic model.\n\n\n\n\n\nmoisture_factor(\n    mm::MoistureDependent{FT},\n    hm::Haverkamp{FT},\n    S_l::FT,\n) where {FT}\n\nReturns the moisture factor of the hydraulic conductivy assuming a  MoistureDependent and Haverkamp hydraulic model.\n\n\n\n\n\nmoisture_factor(mm::MoistureIndependent{FT},\n                hm::AbstractHydraulicsModel{FT},\n                S_l::FT,\n) where {FT}\n\nReturns the moisture factor in hydraulic conductivity when a  MoistureIndependent model is chosen. Returns 1.\n\nNote that the hydraulics model and S_l are not used, but are included  as arguments to unify the function call.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.AbstractHydraulicsModel","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.AbstractHydraulicsModel","text":"AbstractsHydraulicsModel{FT <: AbstractFloat}\n\nHydraulics model is used in the moisture factor in hydraulic  conductivity and in the matric potential. The single hydraulics model  choice sets both of these.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.vanGenuchten","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.vanGenuchten","text":"vanGenuchten{FT} <: AbstractHydraulicsModel{FT}\n\nThe necessary parameters for the van Genuchten hydraulic model;  defaults are for Yolo light clay.\n\nFields\n\nn\nExponent parameter - used in matric potential\nα\nused in matric potential. The inverse of this carries units in      the expression for matric potential (specify in inverse meters).\nm\nExponent parameter - determined by n, used in hydraulic conductivity\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.BrooksCorey","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.BrooksCorey","text":"BrooksCorey{FT} <: AbstractHydraulicsModel{FT}\n\nThe necessary parameters for the Brooks and Corey hydraulic model.\n\nDefaults are chosen to somewhat mirror the Havercamp/vG Yolo light  clay hydraulic conductivity/matric potential.\n\nFields\n\nψb\nψ_b - used in matric potential. Units of meters.\nm\nExponent used in matric potential and hydraulic conductivity.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.Haverkamp","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.Haverkamp","text":"Haverkamp{FT} <: AbstractHydraulicsModel{FT}\n\nThe necessary parameters for the Haverkamp hydraulic model for Yolo light  clay.\n\nNote that this only is used in creating a hydraulic conductivity function,  and another formulation for matric potential must be used.\n\nFields\n\nk\nexponent in conductivity\nA\nconstant A (units of cm^k) using in conductivity. Our sim is in meters\nn\nExponent parameter - using in matric potential\nα\nused in matric potential. The inverse of this carries units in the      expression for matric potential (specify in inverse meters).\nm\nExponent parameter - determined by n, used in hydraulic conductivity\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.hydraulic_conductivity","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.hydraulic_conductivity","text":"hydraulic_conductivity(\n    impedance::AbstractImpedanceFactor{FT},\n    viscosity::AbstractViscosityFactor{FT},\n    moisture::AbstractMoistureFactor{FT},\n    hydraulics::AbstractHydraulicsModel{FT},\n    θ_i::FT,\n    porosity::FT,\n    T::FT,\n    S_l::FT,\n) where {FT}\n\nReturns the hydraulic conductivity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.effective_saturation","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.effective_saturation","text":"effective_saturation(\n    porosity::FT,\n    ϑ_l::FT\n) where {FT}\n\nCompute the effective saturation of soil.\n\nϑ_l is defined to be zero or positive. If ϑ_l is negative,  hydraulic functions that take it as an argument will return  imaginary numbers, resulting in domain errors. Exit in this  case with an error.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.pressure_head","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.pressure_head","text":"pressure_head(\n    model::AbstractHydraulicsModel{FT},\n    porosity::FT,\n    S_s::FT,\n    ϑ_l::FT,\n) where {FT}\n\nDetermine the pressure head in both saturated and unsaturated soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.hydraulic_head","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.hydraulic_head","text":"hydraulic_head(z,ψ)\n\nReturn the hydraulic head.\n\nThe hydraulic head is defined as the sum of vertical height z and  pressure head ψ; meters.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.matric_potential","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.matric_potential","text":"matric_potential(\n        model::vanGenuchten{FT},\n        S_l::FT\n) where {FT}\n\nCompute the van Genuchten function for matric potential.\n\n\n\n\n\nmatric_potential(\n        model::Haverkamp{FT},\n        S_l::FT\n) where {FT}\n\nCompute the van Genuchten function as a proxy for the Haverkamp model  matric potential (for testing purposes).\n\n\n\n\n\nmatric_potential(\n        model::BrooksCorey{FT},\n        S_l::FT\n) where {FT}\n\nCompute the Brooks and Corey function for matric potential.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilWaterParameterizations/#ClimateMachine.Land.SoilWaterParameterizations.volumetric_liquid_fraction","page":"Soil Water Parameterizations","title":"ClimateMachine.Land.SoilWaterParameterizations.volumetric_liquid_fraction","text":"volumetric_liquid_fraction(\n    ϑ_l::FT,\n    porosity::FT,\n) where {FT}\n\nCompute the volumetric liquid fraction from the porosity and the augmented liquid fraction.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/Problems/#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"APIs/BalanceLaws/Problems/","page":"Problems","title":"Problems","text":"CurrentModule = ClimateMachine.Problems","category":"page"},{"location":"APIs/BalanceLaws/Problems/#The-problem","page":"Problems","title":"The problem","text":"","category":"section"},{"location":"APIs/BalanceLaws/Problems/","page":"Problems","title":"Problems","text":"AbstractProblem","category":"page"},{"location":"APIs/BalanceLaws/Problems/#ClimateMachine.Problems.AbstractProblem","page":"Problems","title":"ClimateMachine.Problems.AbstractProblem","text":"AbstractProblem\n\nAn abstract type representing the initial conditions and the boundary conditions for a BalanceLaw.\n\nSubtypes P should define the methods below.\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/Problems/#Initial-condition-methods","page":"Problems","title":"Initial condition methods","text":"","category":"section"},{"location":"APIs/BalanceLaws/Problems/","page":"Problems","title":"Problems","text":"init_state_prognostic!\ninit_state_auxiliary!","category":"page"},{"location":"APIs/BalanceLaws/Problems/#ClimateMachine.Problems.init_state_prognostic!","page":"Problems","title":"ClimateMachine.Problems.init_state_prognostic!","text":"init_state_prognostic!(\n    ::P,\n    ::BalanceLaw,\n    state_prognostic::Vars,\n    state_auxiliary::Vars,\n    localgeo,\n    t,\n    args...,\n)\n\nInitialize the prognostic state variables at t = 0.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/Problems/#ClimateMachine.Problems.init_state_auxiliary!","page":"Problems","title":"ClimateMachine.Problems.init_state_auxiliary!","text":"init_state_auxiliary!(\n    ::P,\n    ::BalanceLaw,\n    state_auxiliary::Vars,\n    geom::LocalGeometry,\n)\n\nInitialize the auxiliary state, at t = 0.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ODESolvers-docs","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers","page":"ODESolvers","title":"ClimateMachine.ODESolvers","text":"ODESolvers\n\nOrdinary differential equation solvers\n\n\n\n\n\n","category":"module"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Low-Storage-Runge-Kutta-methods","page":"ODESolvers","title":"Low Storage Runge Kutta methods","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.LowStorageRungeKutta2N\nODESolvers.LSRK54CarpenterKennedy\nODESolvers.LSRK144NiegemannDiehlBusch","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LowStorageRungeKutta2N","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LowStorageRungeKutta2N","text":"LowStorageRungeKutta2N(f, RKA, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds a low-storage Runge-Kutta scheme using 2N storage based on the provided RKA, RKB and RKC coefficient arrays.\n\nThe available concrete implementations are:\n\nLSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LSRK54CarpenterKennedy","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LSRK54CarpenterKennedy","text":"LSRK54CarpenterKennedy(f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta2N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order, low-storage, Runge–Kutta scheme of Carpenter and Kennedy (1994) (in their notation (5,4) 2N-Storage RK scheme).\n\nReferences\n\n@TECHREPORT{CarpenterKennedy1994,\n  author = {M.~H. Carpenter and C.~A. Kennedy},\n  title = {Fourth-order {2N-storage} {Runge-Kutta} schemes},\n  institution = {National Aeronautics and Space Administration},\n  year = {1994},\n  number = {NASA TM-109112},\n  address = {Langley Research Center, Hampton, VA},\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LSRK144NiegemannDiehlBusch","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LSRK144NiegemannDiehlBusch","text":"LSRK144NiegemannDiehlBusch((f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta2N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order, 14-stage, low-storage, Runge–Kutta scheme of Niegemann, Diehl, and Busch (2012) with optimized stability region\n\nReferences\n\n@article{niegemann2012efficient,\n  title={Efficient low-storage Runge--Kutta schemes with optimized stability regions},\n  author={Niegemann, Jens and Diehl, Richard and Busch, Kurt},\n  journal={Journal of Computational Physics},\n  volume={231},\n  number={2},\n  pages={364--372},\n  year={2012},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Low-Storage-(3N)-Runge-Kutta-methods","page":"ODESolvers","title":"Low Storage (3N) Runge Kutta methods","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.LowStorageRungeKutta3N\nODESolvers.LS3NRK44Classic\nODESolvers.LS3NRK33Heuns","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LowStorageRungeKutta3N","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LowStorageRungeKutta3N","text":"LowStorageRungeKutta3N(f, RKA, RKB, RKC, RKW, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds a low-storage Runge–Kutta scheme using 3N storage based on the provided RKA, RKB and RKC coefficient arrays.  RKC (vector of length the number of stages ns) set nodal points position;  RKA and RKB (size: ns x 2) set weight for tendency and stage-state;  RKW (unused) provides RK weight (last row in Butcher's tableau).\n\nThe 3-N storage formulation from Fyfe (1966) is applicable to any 4-stage, fourth-order RK scheme. It is implemented here as:\n\nhspace-20mm for  j  in  1ns hspace10mm\n  t_j = t^n + Delta t  rkC_j\n\n  dQ_j = dQ^*_j + f(Q_jt_j)\n\n  Q_j+1 = Q_j + Delta t  rkB_j1  dQ_j + rkB_j2  dR_j \n\n  dR_j+1 = dR_j + rkA_j+12  dQ_j\n\n  dQ^*_j+1 = rkA_j+11  dQ_j\n\nThe available concrete implementations are:\n\nLS3NRK44Classic\nLS3NRK33Heuns\n\nReferences\n\n@article{Fyfe1966,\n   title = {Economical Evaluation of Runge-Kutta Formulae},\n   author = {Fyfe, David J.},\n   journal = {Mathematics of Computation},\n   volume = {20},\n   pages = {392--398},\n   year = {1966}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LS3NRK44Classic","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LS3NRK44Classic","text":"LS3NRK44Classic(f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta3N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the classic 4-stage, fourth-order Runge–Kutta scheme in the low-storage implementation of Blum (1962)\n\nReferences\n\n@article {Blum1962,\n   title = {A Modification of the Runge-Kutta Fourth-Order Method}\n   author = {Blum, E. K.},\n   journal = {Mathematics of Computation},\n   volume = {16},\n   pages = {176-187},\n   year = {1962}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LS3NRK33Heuns","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LS3NRK33Heuns","text":"LS3NRK33Heuns(f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta3N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis method uses the 3-stage, third-order Heun's Runge–Kutta scheme.\n\nReferences\n\n@article {Heun1900,\n   title = {Neue Methoden zur approximativen Integration der\n   Differentialgleichungen einer unabh\"{a}ngigen Ver\"{a}nderlichen}\n   author = {Heun, Karl},\n   journal = {Z. Math. Phys},\n   volume = {45},\n   pages = {23--38},\n   year = {1900}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Strong-Stability-Preserving-RungeKutta-methods","page":"ODESolvers","title":"Strong Stability Preserving RungeKutta methods","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.StrongStabilityPreservingRungeKutta\nODESolvers.SSPRK33ShuOsher\nODESolvers.SSPRK34SpiteriRuuth","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.StrongStabilityPreservingRungeKutta","page":"ODESolvers","title":"ClimateMachine.ODESolvers.StrongStabilityPreservingRungeKutta","text":"StrongStabilityPreservingRungeKutta(f, RKA, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds a strong-stability-preserving Runge–Kutta scheme based on the provided RKA, RKB and RKC coefficient arrays.\n\nThe available concrete implementations are:\n\nSSPRK33ShuOsher\nSSPRK34SpiteriRuuth\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.SSPRK33ShuOsher","page":"ODESolvers","title":"ClimateMachine.ODESolvers.SSPRK33ShuOsher","text":"SSPRK33ShuOsher(f, Q; dt, t0 = 0)\n\nThis function returns a StrongStabilityPreservingRungeKutta time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the third-order, 3-stage, strong-stability-preserving, Runge–Kutta scheme of Shu and Osher (1988)\n\nReferences\n\n@article{shu1988efficient,\n  title={Efficient implementation of essentially non-oscillatory shock-capturing schemes},\n  author={Shu, Chi-Wang and Osher, Stanley},\n  journal={Journal of computational physics},\n  volume={77},\n  number={2},\n  pages={439--471},\n  year={1988},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.SSPRK34SpiteriRuuth","page":"ODESolvers","title":"ClimateMachine.ODESolvers.SSPRK34SpiteriRuuth","text":"SSPRK34SpiteriRuuth(f, Q; dt, t0 = 0)\n\nThis function returns a StrongStabilityPreservingRungeKutta time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the third-order, 4-stage, strong-stability-preserving, Runge–Kutta scheme of Spiteri and Ruuth (1988)\n\nReferences\n\n@article{spiteri2002new,\n  title={A new class of optimal high-order strong-stability-preserving time discretization methods},\n  author={Spiteri, Raymond J and Ruuth, Steven J},\n  journal={SIAM Journal on Numerical Analysis},\n  volume={40},\n  number={2},\n  pages={469--491},\n  year={2002},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Additive-Runge-Kutta-methods","page":"ODESolvers","title":"Additive Runge Kutta methods","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.AdditiveRungeKutta\nODESolvers.ARK1ForwardBackwardEuler\nODESolvers.ARK2ImplicitExplicitMidpoint\nODESolvers.ARK2GiraldoKellyConstantinescu\nODESolvers.ARK548L2SA2KennedyCarpenter\nODESolvers.ARK437L2SA1KennedyCarpenter\nODESolvers.SSPRK22Ralstons\nODESolvers.SSPRK22Heuns\nODESolvers.LSRKEulerMethod","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.AdditiveRungeKutta","page":"ODESolvers","title":"ClimateMachine.ODESolvers.AdditiveRungeKutta","text":"AdditiveRungeKutta(f, l, backward_euler_solver, RKAe, RKAi, RKB, RKC, Q;\n                   split_explicit_implicit, variant, dt, t0 = 0)\n\nThis is a time stepping object for implicit-explicit time stepping of a decomposed differential equation. When split_explicit_implicit == false the equation is assumed to be decomposed as\n\n  dotQ = l(Q t) + f(Q t) - l(Q t)\n\nwhere Q is the state, f is the full tendency and l is the chosen implicit operator. When split_explicit_implicit == true the assumed decomposition is\n\n  dotQ = l(Q t) + f(Q t)\n\nwhere f is now only the nonlinear tendency. For both decompositions the implicit operator l is integrated implicitly whereas the remaining part is integrated explicitly. Other arguments are the required time step size dt and the optional initial time t0. The resulting backward Euler type systems are solved using the provided backward_euler_solver. This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds an additive Runge–Kutta scheme based on the provided RKAe, RKAi, RKB and RKC coefficient arrays.  Additionally variant specifies which of the analytically equivalent but numerically different formulations of the scheme is used.\n\nThe available concrete implementations are:\n\nARK1ForwardBackwardEuler\nARK2ImplicitExplicitMidpoint\nARK2GiraldoKellyConstantinescu\nARK548L2SA2KennedyCarpenter\nARK437L2SA1KennedyCarpenter\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.ARK1ForwardBackwardEuler","page":"ODESolvers","title":"ClimateMachine.ODESolvers.ARK1ForwardBackwardEuler","text":"ARK1ForwardBackwardEuler(f, l, backward_euler_solver, Q; dt, t0,\n                         split_explicit_implicit, variant)\n\nThis function returns an AdditiveRungeKutta time stepping object, see the documentation of AdditiveRungeKutta for arguments definitions. This time stepping object is intended to be passed to the solve! command.\n\nThis uses a first-order-accurate two-stage additive Runge–Kutta scheme by combining a forward Euler explicit step with a backward Euler implicit correction.\n\nReferences\n\n@article{Ascher1997,\n  title = {Implicit-explicit Runge-Kutta methods for time-dependent\n           partial differential equations},\n  author = {Uri M. Ascher and Steven J. Ruuth and Raymond J. Spiteri},\n  volume = {25},\n  number = {2-3},\n  pages = {151--167},\n  year = {1997},\n  journal = {Applied Numerical Mathematics},\n  publisher = {Elsevier {BV}}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.ARK2ImplicitExplicitMidpoint","page":"ODESolvers","title":"ClimateMachine.ODESolvers.ARK2ImplicitExplicitMidpoint","text":"ARK2ImplicitExplicitMidpoint(f, l, backward_euler_solver, Q; dt, t0,\n                             split_explicit_implicit, variant)\n\nThis function returns an AdditiveRungeKutta time stepping object, see the documentation of AdditiveRungeKutta for arguments definitions. This time stepping object is intended to be passed to the solve! command.\n\nThis uses a second-order-accurate two-stage additive Runge–Kutta scheme by combining the implicit and explicit midpoint methods.\n\nReferences\n\n@article{Ascher1997,\n  title = {Implicit-explicit Runge-Kutta methods for time-dependent\n           partial differential equations},\n  author = {Uri M. Ascher and Steven J. Ruuth and Raymond J. Spiteri},\n  volume = {25},\n  number = {2-3},\n  pages = {151--167},\n  year = {1997},\n  journal = {Applied Numerical Mathematics},\n  publisher = {Elsevier {BV}}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.ARK2GiraldoKellyConstantinescu","page":"ODESolvers","title":"ClimateMachine.ODESolvers.ARK2GiraldoKellyConstantinescu","text":"ARK2GiraldoKellyConstantinescu(f, l, backward_euler_solver, Q; dt, t0,\n                               split_explicit_implicit, variant, paperversion)\n\nThis function returns an AdditiveRungeKutta time stepping object, see the documentation of AdditiveRungeKutta for arguments definitions. This time stepping object is intended to be passed to the solve! command.\n\npaperversion=true uses the coefficients from the paper, paperversion=false uses coefficients that make the scheme (much) more stable but less accurate\n\nThis uses the second-order-accurate 3-stage additive Runge–Kutta scheme of Giraldo, Kelly and Constantinescu (2013).\n\nReferences\n\n@article{giraldo2013implicit,\n  title={Implicit-explicit formulations of a three-dimensional\n         nonhydrostatic unified model of the atmosphere ({NUMA})},\n  author={Giraldo, Francis X and Kelly, James F and Constantinescu, Emil M},\n  journal={SIAM Journal on Scientific Computing},\n  volume={35},\n  number={5},\n  pages={B1162--B1194},\n  year={2013},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.ARK548L2SA2KennedyCarpenter","page":"ODESolvers","title":"ClimateMachine.ODESolvers.ARK548L2SA2KennedyCarpenter","text":"ARK548L2SA2KennedyCarpenter(f, l, backward_euler_solver, Q; dt, t0,\n                            split_explicit_implicit, variant)\n\nThis function returns an AdditiveRungeKutta time stepping object, see the documentation of AdditiveRungeKutta for arguments definitions. This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fifth-order-accurate 8-stage additive Runge–Kutta scheme of Kennedy and Carpenter (2013).\n\nReferences\n\n@article{kennedy2019higher,\n  title={Higher-order additive Runge--Kutta schemes for ordinary\n         differential equations},\n  author={Kennedy, Christopher A and Carpenter, Mark H},\n  journal={Applied Numerical Mathematics},\n  volume={136},\n  pages={183--205},\n  year={2019},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.ARK437L2SA1KennedyCarpenter","page":"ODESolvers","title":"ClimateMachine.ODESolvers.ARK437L2SA1KennedyCarpenter","text":"ARK437L2SA1KennedyCarpenter(f, l, backward_euler_solver, Q; dt, t0,\n                            split_explicit_implicit, variant)\n\nThis function returns an AdditiveRungeKutta time stepping object, see the documentation of AdditiveRungeKutta for arguments definitions. This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order-accurate 7-stage additive Runge–Kutta scheme of Kennedy and Carpenter (2013).\n\nReferences\n\n@article{kennedy2019higher,\n  title={Higher-order additive Runge--Kutta schemes for ordinary\n         differential equations},\n  author={Kennedy, Christopher A and Carpenter, Mark H},\n  journal={Applied Numerical Mathematics},\n  volume={136},\n  pages={183--205},\n  year={2019},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.SSPRK22Ralstons","page":"ODESolvers","title":"ClimateMachine.ODESolvers.SSPRK22Ralstons","text":"SSPRK22Ralstons(f, Q; dt, t0 = 0)\n\nThis function returns a StrongStabilityPreservingRungeKutta time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the second-order, 2-stage, strong-stability-preserving, Runge–Kutta scheme of Shu and Osher (1988) (also known as Ralstons's method.) Exact choice of coefficients from wikipedia page for Heun's method :)\n\nReferences\n\n@article{shu1988efficient,\n  title={Efficient implementation of essentially non-oscillatory shock-capturing schemes},\n  author={Shu, Chi-Wang and Osher, Stanley},\n  journal={Journal of computational physics},\n  volume={77},\n  number={2},\n  pages={439--471},\n  year={1988},\n  publisher={Elsevier}\n}\n@article{ralston1962runge,\n  title={Runge-Kutta methods with minimum error bounds},\n  author={Ralston, Anthony},\n  journal={Mathematics of computation},\n  volume={16},\n  number={80},\n  pages={431--437},\n  year={1962},\n  doi={10.1090/S0025-5718-1962-0150954-0}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.SSPRK22Heuns","page":"ODESolvers","title":"ClimateMachine.ODESolvers.SSPRK22Heuns","text":"SSPRK22Heuns(f, Q; dt, t0 = 0)\n\nThis function returns a StrongStabilityPreservingRungeKutta time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the second-order, 2-stage, strong-stability-preserving, Runge–Kutta scheme of Shu and Osher (1988) (also known as Heun's method.) Exact choice of coefficients from wikipedia page for Heun's method :)\n\nReferences\n\n@article{shu1988efficient,\n  title={Efficient implementation of essentially non-oscillatory shock-capturing schemes},\n  author={Shu, Chi-Wang and Osher, Stanley},\n  journal={Journal of computational physics},\n  volume={77},\n  number={2},\n  pages={439--471},\n  year={1988},\n  publisher={Elsevier}\n}\n@article {Heun1900,\n   title = {Neue Methoden zur approximativen Integration der\n   Differentialgleichungen einer unabh\"{a}ngigen Ver\"{a}nderlichen}\n   author = {Heun, Karl},\n   journal = {Z. Math. Phys},\n   volume = {45},\n   pages = {23--38},\n   year = {1900}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LSRKEulerMethod","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LSRKEulerMethod","text":"LSRKEulerMethod(f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta2N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis method uses the LSRK2N framework to implement a simple Eulerian forward time stepping scheme for the use of debugging.\n\nReferences\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Multi-rate-Runge-Kutta-Methods","page":"ODESolvers","title":"Multi-rate Runge Kutta Methods","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.MultirateRungeKutta","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MultirateRungeKutta","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MultirateRungeKutta","text":"MultirateRungeKutta(slow_solver, fast_solver; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f_fast(Q t) + f_slow(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds a multirate Runge-Kutta scheme using two different RK solvers. This is based on\n\nCurrently only the low storage RK methods can be used as slow solvers\n\nReferences\n\n@article{SchlegelKnothArnoldWolke2012,\n  title={Implementation of multirate time integration methods for air\n         pollution modelling},\n  author={Schlegel, M and Knoth, O and Arnold, M and Wolke, R},\n  journal={Geoscientific Model Development},\n  volume={5},\n  number={6},\n  pages={1395--1405},\n  year={2012},\n  publisher={Copernicus GmbH}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Split-explicit-methods","page":"ODESolvers","title":"Split-explicit methods","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.SplitExplicitSolver","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.SplitExplicitSolver","page":"ODESolvers","title":"ClimateMachine.ODESolvers.SplitExplicitSolver","text":"SplitExplicitSolver(slow_solver, fast_solver; dt, t0 = 0, coupled = true)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ_fast = f_fast(Q_fast Q_slow t)\n  dotQ_slow = f_slow(Q_slow Q_fast t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis method performs an operator splitting to timestep the vertical average of the model at a faster rate than the full model. This results in a first- order time stepper.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#GARK-methods","page":"ODESolvers","title":"GARK methods","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.MRIGARKESDIRK46aSandu\nODESolvers.MRIGARKIRK21aSandu\nODESolvers.MRIGARKESDIRK24LSA\nODESolvers.MRIGARKESDIRK34aSandu\nODESolvers.MRIGARKERK45aSandu\nODESolvers.MRIGARKExplicit\nODESolvers.MRIGARKESDIRK23LSA\nODESolvers.MRIGARKERK33aSandu\nODESolvers.MRIGARKDecoupledImplicit","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKESDIRK46aSandu","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKESDIRK46aSandu","text":"MRIGARKESDIRK46aSandu(f!, fastsolver, Q; dt, t0=0)\n\nThe 4th order, 6 stage decoupled implicit scheme from Sandu (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKIRK21aSandu","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKIRK21aSandu","text":"MRIGARKIRK21aSandu(f!, fastsolver, Q; dt, t0 = 0)\n\nThe 2rd order, 2 stage implicit scheme from Sandu (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKESDIRK24LSA","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKESDIRK24LSA","text":"MRIGARKESDIRK24LSA(f!,\n                   fastsolver,\n                   Q;\n                   dt,\n                   t0 = 0,\n                   γ = 0.2,\n                   c3 = (2γ + 1) / 2,\n                   a32 = 0.2,\n                   α = -0.1,\n                   β1 = c3 / 10,\n                   β2 = c3 / 10,\n                   )\n\nA 2nd order, 4 stage decoupled implicit scheme. It is based on an L-Stable, stiffly-accurate ESDIRK.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKESDIRK34aSandu","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKESDIRK34aSandu","text":"MRIGARKESDIRK34aSandu(f!, fastsolver, Q; dt, t0=0)\n\nThe 3rd order, 4 stage decoupled implicit scheme from Sandu (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKERK45aSandu","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKERK45aSandu","text":"MRIGARKERK45aSandu(f!, fastsolver, Q; dt, t0 = 0)\n\nThe 4th order, 5 stage scheme from Sandu (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKExplicit","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKExplicit","text":"MRIGARKExplicit(f!, fastsolver, Γs, γ̂s, Q, Δt, t0)\n\nConstruct an explicit MultiRate Infinitesimal General-structure Additive Runge–Kutta (MRI-GARK) scheme to solve\n\n    doty = f(y t) + g(y t)\n\nwhere f is the slow tendency function and g is the fast tendency function; see Sandu (2019).\n\nThe fast tendency is integrated using the fastsolver and the slow tendency using the MRI-GARK scheme. Namely, at each stage the scheme solves\n\n               v(T_i) = Y_i \n             dotv = f(v t) + sum_j=1^i barγ_ij(t) R_j \n    barγ_ijk(t) = sum_k=0^NΓ-1 γ_ijk τ(t)^k  Δc_s \n                 τ(t) = (t - t_s)  Δt \n              Y_i+1 = v(T_i + c_s * Δt)\n\nwhere Y_1 = y_n and y_n+1 = Y_Nstages+1.\n\nHere R_j = g(Y_j t_0 + c_j * Δt) is the tendency for stage j, γ_ijk are the GARK coupling coefficients, NΓ is the number of sets of GARK coupling coefficients there are Δc_s = sum_j=1^Nstages γ_sj1 = c_s+1 - c_s is the scaling increment between stage times. The ODE for v(t) is solved using the fastsolver.  Note that this form of the scheme is based on Definition 2.2 of Sandu (2019), but ODE for v(t) is written to go from t_s to T_i + c_s * Δt as opposed to 0 to 1.\n\nCurrently only LowStorageRungeKutta2N schemes are supported for fastsolver\n\nThe coefficients defined by γ̂s can be used for an embedded scheme (only the last stage is different).\n\nThe available concrete implementations are:\n\nMRIGARKERK33aSandu\nMRIGARKERK45aSandu\n\nReferences\n\n@article{Sandu2019,\n    title={A class of multirate infinitesimal gark methods},\n    author={Sandu, Adrian},\n    journal={SIAM Journal on Numerical Analysis},\n    volume={57},\n    number={5},\n    pages={2300--2327},\n    year={2019},\n    publisher={SIAM},\n    doi={10.1137/18M1205492}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKESDIRK23LSA","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKESDIRK23LSA","text":"MRIGARKESDIRK23LSA(f!, fastsolver, Q; dt, t0 = 0, δ = 0\n\nA 2nd order, 3 stage decoupled implicit scheme. It is based on L-Stable, stiffly-accurate ESDIRK scheme of Bank et al (1985); see also Kennedy and Carpenter (2016).\n\nThe free parameter δ can take any values for accuracy.\n\nReferences\n\n@article{Bank1985,\n    title={Transient simulation of silicon devices and circuits},\n    author={R. E. Bank and W. M. Coughran and W. Fichtner and\n            E. H. Grosse and D. J. Rose and R. K. Smith},\n    journal={IEEE Transactions on Computer-Aided Design of Integrated\n             Circuits and Systems},\n    volume={4},\n    number={4},\n    pages={436-451},\n    year={1985},\n    publisher={IEEE},\n    doi={10.1109/TCAD.1985.1270142}\n}\n\n@techreport{KennedyCarpenter2016,\n    title = {Diagonally implicit Runge-Kutta methods for ordinary\n             differential equations. A review},\n             author = {C. A. Kennedy and M. H. Carpenter},\n    institution = {National Aeronautics and Space Administration},\n    year = {2016},\n    number = {NASA/TM–2016–219173},\n    address = {Langley Research Center, Hampton, VA}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKERK33aSandu","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKERK33aSandu","text":"MRIGARKERK33aSandu(f!, fastsolver, Q; dt, t0 = 0, δ = -1 // 2)\n\nThe 3rd order, 3 stage scheme from Sandu (2019). The parameter δ defaults to the value suggested by Sandu, but can be varied.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.MRIGARKDecoupledImplicit","page":"ODESolvers","title":"ClimateMachine.ODESolvers.MRIGARKDecoupledImplicit","text":"MRIGARKDecoupledImplicit(f!, backward_euler_solver, fastsolver, Γs, γ̂s, Q,\n                         Δt, t0)\n\nConstruct a decoupled implicit MultiRate Infinitesimal General-structure Additive Runge–Kutta (MRI-GARK) scheme to solve\n\n    doty = f(y t) + g(y t)\n\nwhere f is the slow tendency function and g is the fast tendency function; see Sandu (2019).\n\nThe fast tendency is integrated using the fastsolver and the slow tendency using the MRI-GARK scheme. Since this is a decoupled, implicit MRI-GARK there is no implicit coupling between the fast and slow tendencies.\n\nThe backward_euler_solver should be of type AbstractBackwardEulerSolver or LinearBackwardEulerSolver, and is used to perform the backward Euler solves for y given the slow tendency function, namely\n\n   y = z + α f(y t p)\n\nCurrently only LowStorageRungeKutta2N schemes are supported for fastsolver\n\nThe coefficients defined by γ̂s can be used for an embedded scheme (only the last stage is different).\n\nThe available concrete implementations are:\n\nMRIGARKIRK21aSandu\nMRIGARKESDIRK34aSandu\nMRIGARKESDIRK46aSandu\n\nReferences\n\n@article{Sandu2019,\n    title={A class of multirate infinitesimal gark methods},\n    author={Sandu, Adrian},\n    journal={SIAM Journal on Numerical Analysis},\n    volume={57},\n    number={5},\n    pages={2300--2327},\n    year={2019},\n    publisher={SIAM},\n    doi={10.1137/18M1205492}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Euler-methods","page":"ODESolvers","title":"Euler methods","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.LinearBackwardEulerSolver\nODESolvers.AbstractBackwardEulerSolver\nODESolvers.NonLinearBackwardEulerSolver","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LinearBackwardEulerSolver","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LinearBackwardEulerSolver","text":"LinearBackwardEulerSolver(::AbstractSystemSolver; isadjustable = false)\n\nHelper type for specifying building a backward Euler solver with a linear solver.  If isadjustable == true then the solver can be updated with a new time step size.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.AbstractBackwardEulerSolver","page":"ODESolvers","title":"ClimateMachine.ODESolvers.AbstractBackwardEulerSolver","text":"AbstractBackwardEulerSolver\n\nAn abstract backward Euler method\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.NonLinearBackwardEulerSolver","page":"ODESolvers","title":"ClimateMachine.ODESolvers.NonLinearBackwardEulerSolver","text":"struct NonLinearBackwardEulerSolver{NLS}\n    nlsolver::NLS\n    isadjustable::Bool\n    preconditioner_update_freq::Int64\nend\n\nHelper type for specifying building a nonlinear backward Euler solver with a nonlinear solver.\n\nArguments\n\nnlsolver: iterative nonlinear solver, i.e., JacobianFreeNewtonKrylovSolver\nisadjustable: TODO not used, might use for updating preconditioner\npreconditioner_update_freq:  relavent to Jacobian free -1: no preconditioner;                            positive number, update every freq times\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Differential-Equations","page":"ODESolvers","title":"Differential Equations","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.DiffEqJLIMEXSolver\nODESolvers.DiffEqJLSolver","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.DiffEqJLIMEXSolver","page":"ODESolvers","title":"ClimateMachine.ODESolvers.DiffEqJLIMEXSolver","text":"DiffEqJLSolver(f, RKA, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f_I(Q t) + f_E(Q t)\n\nvia a DifferentialEquations.jl DEAlgorithm, which includes support for OrdinaryDiffEq.jl, Sundials.jl, and more.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.DiffEqJLSolver","page":"ODESolvers","title":"ClimateMachine.ODESolvers.DiffEqJLSolver","text":"DiffEqJLSolver(f, RKA, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nvia a DifferentialEquations.jl DEAlgorithm, which includes support for OrdinaryDiffEq.jl, Sundials.jl, and more.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ODE-Solvers","page":"ODESolvers","title":"ODE Solvers","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.solve!\nODESolvers.updatedt!\nODESolvers.gettime\nODESolvers.getsteps","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.solve!","page":"ODESolvers","title":"ClimateMachine.ODESolvers.solve!","text":"solve!(Q, solver::AbstractODESolver; timeend,\n       stopaftertimeend=true, numberofsteps, callbacks)\n\nSolves an ODE using the solver starting from a state Q. The state Q is updated inplace. The final time timeend or numberofsteps must be specified.\n\nA series of optional callback functions can be specified using the tuple callbacks; see the GenericCallbacks module.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.updatedt!","page":"ODESolvers","title":"ClimateMachine.ODESolvers.updatedt!","text":"updatedt!(solver::AbstractODESolver, dt)\n\nChange the time step size to dt for the ODE solver solver.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.gettime","page":"ODESolvers","title":"ClimateMachine.ODESolvers.gettime","text":"gettime(solver::AbstractODESolver)\n\nReturns the current simulation time of the ODE solver solver\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.getsteps","page":"ODESolvers","title":"ClimateMachine.ODESolvers.getsteps","text":"getsteps(solver::AbstractODESolver)\n\nReturns the number of completed time steps of the ODE solver solver\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#Generic-Callbacks","page":"ODESolvers","title":"Generic Callbacks","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/","page":"ODESolvers","title":"ODESolvers","text":"GenericCallbacks\nGenericCallbacks.AtInit\nGenericCallbacks.AtInitAndFini\nGenericCallbacks.EveryXWallTimeSeconds\nGenericCallbacks.EveryXSimulationTime\nGenericCallbacks.EveryXSimulationSteps","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks","text":"GenericCallbacks\n\nThis module defines interfaces and wrappers for callbacks to be used with an AbstractODESolver.\n\nA callback cb defines three methods:\n\nGenericCallbacks.init!(cb, solver, Q, param, t), to be called at solver initialization.\nGenericCallbacks.call!(cb, solver, Q, param, t), to be called after each time step: the return value dictates what action should be taken:\n0 or nothing: continue time stepping as usual\n1: stop time stepping after all callbacks have been executed\n2: stop time stepping immediately\nGenericCallbacks.fini!(cb, solver, Q, param, t), to be called at solver finish.\n\nAdditionally, wrapper callbacks can be used to execute the callbacks under certain conditions:\n\nAtInit\nAtInitAndFini\nEveryXWallTimeSeconds\nEveryXSimulationTime\nEveryXSimulationSteps\n\nFor convenience, the following objects can also be used as callbacks:\n\nA Function object f, init! and fini! are no-ops, and call! will call f(), and ignore the return value.\nA Tuple object will call init!, call! and fini! on each element of the tuple.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks.AtInit","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks.AtInit","text":"AtInit(callback) <: AbstractCallback\n\nA wrapper callback to execute callback at initialization as well as after each interval.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks.AtInitAndFini","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks.AtInitAndFini","text":"AtInitAndFini(callback) <: AbstractCallback\n\nA wrapper callback to execute callback at initialization and at finish as well as after each interval.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks.EveryXWallTimeSeconds","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks.EveryXWallTimeSeconds","text":"EveryXWallTimeSeconds(callback, Δtime, mpicomm)\n\nA wrapper callback to execute callback every Δtime wallclock time seconds. mpicomm is used to syncronize runtime across MPI ranks.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks.EveryXSimulationTime","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks.EveryXSimulationTime","text":"EveryXSimulationTime(f, Δtime)\n\nA wrapper callback to execute callback every time simulation time seconds.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks.EveryXSimulationSteps","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks.EveryXSimulationSteps","text":"EveryXSimulationSteps(callback, Δsteps)\n\nA wrapper callback to execute callback every nsteps of the time stepper.\n\n\n\n\n\n","category":"type"},{"location":"DevDocs/VariableList/#ClimateMachine-Variable-List","page":"Variable list","title":"ClimateMachine Variable List","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"This document is currently for collaborators within the project with access to the Overleaf CliMA-Atmos docs. The purpose of this page is to unify the naming conventions used in the Overleaf document in a manner useful for coding. This document suggests 'reserved' variable names in <property>_<species> format with the default working fluid (no-subscript) being moist air. Contributors to the CliMA repository are welcome to suggest changes when necessary.","category":"page"},{"location":"DevDocs/VariableList/#Type-parameters","page":"Variable list","title":"Type parameters","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"The Julia code typically uses T as a type parameter, however this conflicts with the typical usage for temperature. Instead, good choices are:","category":"page"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"FT for floating point values","category":"page"},{"location":"DevDocs/VariableList/#Names-reserved-for-debug-variables","page":"Variable list","title":"Names reserved for debug variables","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"dummy\nscratch","category":"page"},{"location":"DevDocs/VariableList/#.1-Working-Fluid-and-Equation-of-State","page":"Variable list","title":"2.1  Working Fluid and Equation of State","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"q_dry = dry air mass fraction\nq_vap = specific humidity, vapour\nq_liq = specific humidity, liquid\nq_ice = specific humidity, ice\nq_con = specific humidity, condensate\nq_tot = specific humidity, total\n\nP_<species>     = pressure, species (no subscript == default working fluid moist air)\nρ_<species>     = density, species (no subscript == default working fluid moist air)\nR_m             = gas constant, moist\nR_d             = gas constant, dry\nR_v             = gas constant, water vapour\nT               = temperature, moist air\nT_<species>     = temperature, species","category":"page"},{"location":"DevDocs/VariableList/#.2-Mass-Balance","page":"Variable list","title":"2.2 Mass Balance","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"dt              = time increment\nu               = x-velocity\nv               = y-velocity\nw               = z-velocity\nU               = x-momentum\nV               = y-momentum\nW               = z=momentum","category":"page"},{"location":"DevDocs/VariableList/#.3-Moisture-balances","page":"Variable list","title":"2.3 Moisture balances","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"source_qt           = local source/sink of water mass [S_qt]\ndiffusiveflux_vap   = diffusive flux, water vapour\ndiffusiveflux_liq   = diffusive flux, cloud liquid\ndiffusiveflux_ice   = diffusive flux, cloud ice\ndiffusiveflux_tot   = diffusive flux, total","category":"page"},{"location":"DevDocs/VariableList/#.4-Momentum-balances","page":"Variable list","title":"2.4 Momentum balances","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"U               = x-momentum\nV               = y-momentum\nW               = z-momentum (2D/3D: this is the vertical coordinate)\nΩ_x             = x-angular momentum\nΩ_y             = y-angular momentum\nΩ_z             = z-angular momentum\nτ_xx            = stress tensor ((1,1) component)\nτ_<ij>          = replace ij with combination of x/y/z to recover appropriate value\nλ_stokes        = Stokes parameter","category":"page"},{"location":"DevDocs/VariableList/#.5-Energy-balance","page":"Variable list","title":"2.5 Energy balance","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"<Lower case e_<type> suggests specific (per unit mass) quantities>\ne_kin_<spe>      = specific energy per unit volume, kinetic\ne_pot_<spe>      = specific energy per unit volume, potential\ne_int_<spe>      = specific energy per unit volume, internal\ne_tot_<spe>      = specific energy per unit volume, total\n\nE_kin_<spe>      = energy, kinetic\nE_pot_<spe>      = energy, potential\nE_int_<spe>      = energy, internal\nE_tot_<spe>      = energy, total\n\ncv_m             = isochoric specific heat, moist air\ncv_d             = isochoric specific heat, dry air\ncv_l             = isochoric specific heat, liquid water\ncv_v             = isochoric specific heat, water vapour\ncv_i             = isochoric specific heat, ice\n\ncp_m             = isobaric specific heat, moist air\ncp_d             = isobaric specific heat, dry air\ncp_l             = isobaric specific heat, liquid water\ncp_v             = isobaric specific heat, water vapour\ncp_i             = isobaric specific heat, ice","category":"page"},{"location":"DevDocs/VariableList/#.6-Microphysics","page":"Variable list","title":"2.6 Microphysics","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"q_rai = specific humidity, rain [kg/kg]\n\nterminal_velocity = mass weighted average rain fall speed [m/s]\n\nconv_q_vap_to_q_liq      = tendency to q_liq and q_ice due to\n                           condensation/evaporation and\n                           sublimation/resublimation from q_vap [1/s]\nconv_q_liq_to_q_rai_acnv = tendency to q_rai due to autoconversion from q_liq [1/s]\nconv_q_liq_to_q_rai_accr = tendency to q_rai due to accretion from q_liq [1/s]\nconv_q_rai_to_q_vap      = tendency to q_vap due to evaporation from q_rai [1/s]","category":"page"},{"location":"DevDocs/VariableList/#.7-Diagnostics","page":"Variable list","title":"2.7 Diagnostics","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"Please see the diagnostic variable list.","category":"page"},{"location":"DevDocs/VariableList/#TODO","page":"Variable list","title":"TODO","text":"","category":"section"},{"location":"DevDocs/VariableList/","page":"Variable list","title":"Variable list","text":"Update with list of additional parameters / source terms as necessary","category":"page"},{"location":"Theory/Common/Turbulence/#Turbulence-Closures-docs","page":"Turbulence Closures","title":"Turbulence Closures","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"Module TurbulenceClosures.jl currently supports  pointwise models of the eddy viscosity/eddy diffusivity type.","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"Supported constructors include are:\nConstantDynamicViscosity\nSmagorinskyLilly\nVreman\nAnisoMinDiss\n","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"note: Note\nUsage: This is a quick-ref guide to using turbulence models as a subcomponent of AtmosModel \nnu is the kinematic viscosity, C_smag is the Smagorinsky Model coefficient,turbulence=ConstantDynamicViscosity(ν)\n\nturbulence=SmagorinskyLilly(C_smag)\n\nturbulence=Vreman(C_smag)\n\nturbulence=AnisoMinDiss(C_poincare)","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"using DocStringExtensions\nusing CLIMAParameters.Atmos.SubgridScale: inv_Pr_turb\nexport ConstantDynamicViscosity, SmagorinskyLilly, Vreman, AnisoMinDiss\nexport turbulence_tensors","category":"page"},{"location":"Theory/Common/Turbulence/#Abstract-Type","page":"Turbulence Closures","title":"Abstract Type","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"We define a TurbulenceClosure abstract type and default functions for the generic turbulence closure which will be overloaded with model specific functions. Minimally, overloaded functions for the following stubs must be defined for a turbulence model.","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"abstract type TurbulenceClosure end\n\n\nvars_state(::TurbulenceClosure, ::AbstractStateType, FT) = @vars()\n\nfunction atmos_init_aux!(\n    ::TurbulenceClosure,\n    ::AtmosModel,\n    aux::Vars,\n    geom::LocalGeometry,\n) end\nfunction compute_gradient_argument!(\n    ::TurbulenceClosure,\n    transform::Vars,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n) end\nfunction compute_gradient_flux!(\n    ::TurbulenceClosure,\n    ::Orientation,\n    diffusive,\n    ∇transform,\n    state,\n    aux,\n    t,\n) end","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"The following may need to be addressed if turbulence models require additional state variables or auxiliary variable updates (e.g. TKE based models)","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"vars_state(::TurbulenceClosure, ::Prognostic, FT) = @vars()\nfunction atmos_nodal_update_auxiliary_state!(\n    ::TurbulenceClosure,\n    ::AtmosModel,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n) end","category":"page"},{"location":"Theory/Common/Turbulence/#Eddy-viscosity-Models","page":"Turbulence Closures","title":"Eddy-viscosity Models","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"The following function provides an example of a stub for an eddy-viscosity model.  Currently, scalar and diagonal tensor viscosities and diffusivities are supported.","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"Generic math functions for use within the turbulence closures such as the principal tensor invariants, symmetric tensors and tensor norms have been included.","category":"page"},{"location":"Theory/Common/Turbulence/#tensor-invariants","page":"Turbulence Closures","title":"Pricipal Invariants","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"textitI_1 = mathrmtr(X) \ntextitI_2 = (mathrmtr(X)^2 - mathrmtr(X)^2)  2 \ntextitI_3 = mathrmdet(X) ","category":"page"},{"location":"Theory/Common/Turbulence/#symmetric-tensors","page":"Turbulence Closures","title":"Symmetrize","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"fracmathrmX + mathrmX^T2 ","category":"page"},{"location":"Theory/Common/Turbulence/#tensor-norms","page":"Turbulence Closures","title":"2-Norm","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"Given a tensor X, return the tensor dot product","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"sum_ij S_ij^2","category":"page"},{"location":"Theory/Common/Turbulence/#strain-rate-magnitude","page":"Turbulence Closures","title":"Strain-rate Magnitude","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"By definition, the strain-rate magnitude, as defined in standard turbulence modelling is computed such that","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"mathrmS = sqrt2 sum_ij mathrmS_ij^2","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"where","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"vecS(vecu) = frac12  left(nablavecu +  left( nablavecu right)^T right)","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"\\mathrm{S} is the rate-of-strain tensor. (Symmetric component of the velocity gradient). Note that the skew symmetric component (rate-of-rotation) is not currently computed.","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"\"\"\"\n    strain_rate_magnitude(S)\nGiven the rate-of-strain tensor `S`, computes its magnitude.\n\"\"\"\nfunction strain_rate_magnitude(S::SHermitianCompact{3, FT, 6}) where {FT}\n    return sqrt(2 * norm2(S))\nend","category":"page"},{"location":"Theory/Common/Turbulence/#constant-viscosity","page":"Turbulence Closures","title":"Constant Viscosity Model","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"ConstantDynamicViscosity requires a user to specify the constant viscosity (kinematic) and appropriately computes the turbulent stress tensor based on this term. Diffusivity can be computed using the turbulent Prandtl number for the appropriate problem regime.","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"tau =\n    begincases\n    - 2 nu mathrmS  mathrmWithoutDivergence\n    - 2 nu mathrmS + frac23 nu mathrmtr(S) I_3  mathrmWithDivergence\n    endcases","category":"page"},{"location":"Theory/Common/Turbulence/#smagorinsky-lilly","page":"Turbulence Closures","title":"Smagorinsky-Lilly","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"The Smagorinsky turbulence model, with Lilly's correction to stratified atmospheric flows, is included in ClimateMachine. The input parameter to this model is the Smagorinsky coefficient. For atmospheric flows, the coefficient C_smag typically takes values between 0.15 and 0.23. Flow dependent C_smag are currently not supported (e.g. Germano's extension). The Smagorinsky-Lilly model does not contain explicit filtered terms.","category":"page"},{"location":"Theory/Common/Turbulence/#Equations","page":"Turbulence Closures","title":"Equations","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"nu = (C_s mathrmf_b Delta)^2 sqrtmathrmS","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"with the stratification correction term","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"f_b =\n   begincases\n   1  mathrmRi leq 0 \n   max(0 1 - mathrmRi  mathrmPr_t)^14  mathrmRi  0 \n   endcases","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"mathrmRi =  fracN^2S^2","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"N = left( fracgtheta_v fracpartial theta_vpartial zright)^12","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"Here, mathrmRi and mathrmPr_t are the Richardson and turbulent Prandtl numbers respectively.  Delta is the mixing length in the relevant coordinate direction. We use the DG metric terms to determine the local effective resolution (see src/Mesh/Geometry.jl), and modify the vertical lengthscale by the stratification correction factor mathrmf_b so that Delta_vert = Delta z f_b.","category":"page"},{"location":"Theory/Common/Turbulence/#vreman","page":"Turbulence Closures","title":"Vreman Model","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"Vreman's turbulence model for anisotropic flows, which provides a less dissipative solution (specifically in the near-wall and transitional regions) than the Smagorinsky-Lilly method. This model relies of first derivatives of the velocity vector (i.e., the gradient tensor).  By design, the Vreman model handles transitional as well as fully turbulent flows adequately. The input parameter to this model is the Smagorinsky coefficient - the coefficient is modified within the model functions to account for differences in model construction.","category":"page"},{"location":"Theory/Common/Turbulence/#Equations-2","page":"Turbulence Closures","title":"Equations","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"nu_t = 25 C_s^2 sqrtfracB_betau_iju_ij","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"where (ij m = (123))","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"beginalign\nB_beta = beta_11beta_22 + beta_11beta_33 + beta_22beta_33 - (beta_13^2 + beta_12^2 + beta_23^2) \nbeta_ij = Delta_m^2 u_i m u_j m \nu_ij = fracpartial u_ipartial x_j\nendalign","category":"page"},{"location":"Theory/Common/Turbulence/#aniso-min-diss","page":"Turbulence Closures","title":"Anisotropic Minimum Dissipation","text":"","category":"section"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"This method is based Vreugdenhil and Taylor's minimum-dissipation eddy-viscosity model.  The principles of the Rayleigh quotient minimizer are applied to the energy dissipation terms in the conservation equations, resulting in a maximum dissipation bound, and a model for eddy viscosity and eddy diffusivity.","category":"page"},{"location":"Theory/Common/Turbulence/","page":"Turbulence Closures","title":"Turbulence Closures","text":"nu_e = (mathrmCdelta)^2  mathrmmaxleft0 - frachatpartial_k hatu_i hatpartial_k hatu_j mathrmhatS_ijhatpartial_p hatu_q hatpartial_p hatu_q right","category":"page"},{"location":"GettingStarted/Atmos/#Atmosphere-model-configurations","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"","category":"section"},{"location":"GettingStarted/Atmos/","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"The struct AtmosModel defines a specific subtype of a balance law (i.e. conservation equations) specific to atmospheric modeling. A complete description of a model is provided by the fields listed below. In this implementation of the AtmosModel we concern ourselves with the conservative form of the compressible equations of moist fluid motion given a set of initial, boundary and forcing(source) conditions.","category":"page"},{"location":"GettingStarted/Atmos/#LES-Configuration-(with-defaults)","page":"Atmosphere model configurations","title":"LES Configuration (with defaults)","text":"","category":"section"},{"location":"GettingStarted/Atmos/","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"Default field values for the LES AtmosModel definition are included below. Users are directed to the model subcomponent pages to view the possible options for each subcomponent.","category":"page"},{"location":"GettingStarted/Atmos/","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"    ::Type{AtmosLESConfigType},\n    param_set::AbstractParameterSet;\n    orientation::O = FlatOrientation(),\n    ref_state::RS = HydrostaticState(DecayingTemperatureProfile{FT}(param_set),)\n    turbulence::T = SmagorinskyLilly{FT}(0.21),\n    hyperdiffusion::HD = NoHyperDiffusion(),\n    moisture::M = EquilMoist{FT}(),\n    precipitation::P = NoPrecipitation(),\n    radiation::R = NoRadiation(),\n    source::S = (Gravity(), Coriolis(), GeostrophicForcing{FT}(7.62e-5, 0, 0)),\n    tracers::TR = NoTracers(),\n    boundarycondition::BC = AtmosBC(),\n    init_state_prognostic::IS = nothing,\n    data_config::DC = nothing,","category":"page"},{"location":"GettingStarted/Atmos/","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"note: Note\nMost AtmosModel subcomponents are common to both LES / GCM configurations.  Equation sets are written in vector-invariant form and solved in Cartesian coordinates.  The component orientation determines whether the problem is solved in a box (LES) or a sphere (GCM))","category":"page"},{"location":"GettingStarted/Atmos/#GCM-Configuration-(with-defaults)","page":"Atmosphere model configurations","title":"GCM Configuration (with defaults)","text":"","category":"section"},{"location":"GettingStarted/Atmos/","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"Default field values for the GCM AtmosModel definition are included below. Users are directed to the model subcomponent pages to view the possible options for each subcomponent.","category":"page"},{"location":"GettingStarted/Atmos/","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"    ::Type{AtmosGCMConfigType},\n    param_set::AbstractParameterSet;\n    orientation::O = SphericalOrientation(),\n    ref_state::RS = HydrostaticState(DecayingTemperatureProfile{FT}(param_set),)\n    turbulence::T = SmagorinskyLilly{FT}(C_smag(param_set)),\n    hyperdiffusion::HD = NoHyperDiffusion(),\n    moisture::M = EquilMoist{FT}(),\n    precipitation::P = NoPrecipitation(),\n    radiation::R = NoRadiation(),\n    source::S = (Gravity(), Coriolis()),\n    tracers::TR = NoTracers(),\n    boundarycondition::BC = AtmosBC(),\n    init_state_prognostic::IS = nothing,\n    data_config::DC = nothing,","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Diagnostics/Debug/StateCheck.jl\"","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/#State-debug-statistics","page":"State Statistics Regression","title":"State debug statistics","text":"","category":"section"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"This page shows how to use the StateCheck functions to get basic statistics for nodal values of fields held in ClimateMachine MPIStateArray data structures. The StateCheck functions can be used to","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Generate statistics on MPIStateArray holding the state of a ClimateMachine experiment.\nand to\nCompare against saved reference statistics from ClimateMachine MPIStateArray variables. This can enable simple automated regression test checks for detecting unexpected changes introduced into numerical experiments by code updates.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"These two cases are shown below:","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/#.-Generating-statistics-for-a-set-of-MPIStateArrays","page":"State Statistics Regression","title":"1. Generating statistics for a set of MPIStateArrays","text":"","category":"section"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Here we create a callback that can generate statistics for an arbitrary set of the MPIStateArray type variables of the sort that hold persistent state for ClimateMachine models. We then invoke the call back to show the statistics.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"In regular use the MPIStateArray variables will come from model configurations. Here we create a dummy set of MPIStateArray variables for use in stand alone examples.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/#Create-a-dummy-set-of-MPIStateArrays","page":"State Statistics Regression","title":"Create a dummy set of MPIStateArrays","text":"","category":"section"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"First we set up two MPIStateArray variables. This need a few packages to be in placeT, and utilizes some utility functions to create the array and add named persistent state variables. This is usually handled automatically as part of model definition in regular ClimateMachine activity. Calling ClimateMachine.init() includes initializing GPU CUDA and MPI parallel processing options that match the hardware/software system in use.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Set up a basic environment","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"using MPI\nusing StaticArrays\nusing Random\nusing ClimateMachine\nusing ClimateMachine.VariableTemplates\nusing ClimateMachine.MPIStateArrays\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.StateCheck\n\nClimateMachine.init()\nFT = Float64","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Define some dummy vector and tensor abstract variables with associated types and dimensions","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"F1 = @vars begin\n    ν∇u::SMatrix{3, 2, FT, 6}\n    κ∇θ::SVector{3, FT}\nend\nF2 = @vars begin\n    u::SVector{2, FT}\n    θ::SVector{1, FT}\nend\nnothing # hide","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Create MPIStateArray variables with arrays to hold elements of the vectors and tensors","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Q1 = MPIStateArray{Float32, F1}(\n    MPI.COMM_WORLD,\n    ClimateMachine.array_type(),\n    4,\n    9,\n    8,\n)\nQ2 = MPIStateArray{Float64, F2}(\n    MPI.COMM_WORLD,\n    ClimateMachine.array_type(),\n    4,\n    3,\n    8,\n)\nnothing # hide","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/#Create-a-call-back","page":"State Statistics Regression","title":"Create a call-back","text":"","category":"section"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Now we can create a StateCheck call-back, cb, tied to the MPIStateArray variables Q1 and Q2. Each MPIStateArray in the array of MPIStateArray variables tracked is paired with a label to identify it. The call-back is also given a frequency (in time step numbers) and precision for printing summary tables.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"cb = ClimateMachine.StateCheck.sccreate(\n    [(Q1, \"My gradients\"), (Q2, \"My fields\")],\n    1;\n    prec = 15,\n)\nGenericCallbacks.init!(cb, nothing, nothing, nothing, nothing)\nnothing # hide","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/#Invoke-the-call-back","page":"State Statistics Regression","title":"Invoke the call-back","text":"","category":"section"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"The call-back is of type ClimateMachine.GenericCallbacks.EveryXSimulationSteps and in regular use is designed to be passed to a ClimateMachine timestepping solver e.g.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"typeof(cb)","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Here, for demonstration purposes, we can invoke the call-back after simply initializing the MPIStateArray fields to a random set of values e.g.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Q1.data .= rand(MersenneTwister(0), Float32, size(Q1.data))\nQ2.data .= rand(MersenneTwister(0), Float64, size(Q2.data))\nGenericCallbacks.call!(cb, nothing, nothing, nothing, nothing)","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/#.-Comparing-to-reference-values","page":"State Statistics Regression","title":"2. Comparing to reference values","text":"","category":"section"},{"location":"generated/Diagnostics/Debug/StateCheck/#Generate-arrays-of-reference-values","page":"State Statistics Regression","title":"Generate arrays of reference values","text":"","category":"section"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"StateCheck functions can generate text that can be used to set the value of stored arrays that can be used in a reference test for subsequent regression testing. This involves 3 steps.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Step 1. First a reference array setting program code is generated from the latest state of a given callback e.g.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"ClimateMachine.StateCheck.scprintref(cb)","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Step 2. Next the array setting program code is executed (see below). At this stage the parr[] array context may be hand edited. The parr[] array sets a target number of decimal places for matching against reference values in varr[]. For different experiments and different fields the degree of precision that constitutes failing a regression test may vary. Choosing the parr[] values requires some sense as to the stability of the particular numerical and physical scenario an experiment represents. In the example below some precision settings have been hand edited from the default of 16 to illustrate the process.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"#! format: off\nvarr = [\n [ \"My gradients\", \"ν∇u[1]\",  1.34348869323730468750e-04,  9.84732866287231445313e-01,  5.23545503616333007813e-01,  3.08209930764271777814e-01 ],\n [ \"My gradients\", \"ν∇u[2]\",  1.16317868232727050781e-01,  9.92088317871093750000e-01,  4.83800649642944335938e-01,  2.83350456014221541157e-01 ],\n [ \"My gradients\", \"ν∇u[3]\",  1.05845928192138671875e-03,  9.51775908470153808594e-01,  4.65474426746368408203e-01,  2.73615551085745090099e-01 ],\n [ \"My gradients\", \"ν∇u[4]\",  5.97668886184692382813e-02,  9.68048095703125000000e-01,  5.42618036270141601563e-01,  2.81570862027933854765e-01 ],\n [ \"My gradients\", \"ν∇u[5]\",  8.31030607223510742188e-02,  9.35931921005249023438e-01,  5.05405902862548828125e-01,  2.46073509972619536290e-01 ],\n [ \"My gradients\", \"ν∇u[6]\",  3.09681892395019531250e-02,  9.98341441154479980469e-01,  4.54375565052032470703e-01,  3.09461067853178561915e-01 ],\n [ \"My gradients\", \"κ∇θ[1]\",  8.47448110580444335938e-02,  9.94180679321289062500e-01,  5.27157366275787353516e-01,  2.92455951648181833313e-01 ],\n [ \"My gradients\", \"κ∇θ[2]\",  1.20514631271362304688e-02,  9.93527650833129882813e-01,  4.71063584089279174805e-01,  2.96449027197666359346e-01 ],\n [ \"My gradients\", \"κ∇θ[3]\",  8.14980268478393554688e-02,  9.55443382263183593750e-01,  5.05038917064666748047e-01,  2.77201022741208891187e-01 ],\n [    \"My fields\",   \"u[1]\",  4.31410233294131639781e-02,  9.97140933049696531754e-01,  4.62139750850942054861e-01,  3.23076684924287371725e-01 ],\n [    \"My fields\",   \"u[2]\",  1.01416659908237782872e-02,  9.14712023896926407218e-01,  4.76160523012988778913e-01,  2.71443440757963339038e-01 ],\n [    \"My fields\",   \"θ[1]\",  6.58965491052394547467e-02,  9.73216404386510802738e-01,  4.60007166313864512830e-01,  2.87310472114545079059e-01 ],\n]\nparr = [\n [ \"My gradients\", \"ν∇u[1]\",    16,     7,    16,     0 ],\n [ \"My gradients\", \"ν∇u[2]\",    16,     7,    16,     0 ],\n [ \"My gradients\", \"ν∇u[3]\",    16,     7,    16,     0 ],\n [ \"My gradients\", \"ν∇u[4]\",    16,     7,    16,     0 ],\n [ \"My gradients\", \"ν∇u[5]\",    16,     7,    16,     0 ],\n [ \"My gradients\", \"ν∇u[6]\",    16,     7,    16,     0 ],\n [ \"My gradients\", \"κ∇θ[1]\",    16,    16,    16,     0 ],\n [ \"My gradients\", \"κ∇θ[2]\",    16,    16,    16,     0 ],\n [ \"My gradients\", \"κ∇θ[3]\",    16,    16,    16,     0 ],\n [    \"My fields\",   \"u[1]\",    16,    16,    16,     0 ],\n [    \"My fields\",   \"u[2]\",    16,    16,    16,     0 ],\n [    \"My fields\",   \"θ[1]\",    16,    16,    16,     0 ],\n]\n#! format: on","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Step 3. Finally a call-back stored value can be compared for consistency to with parr[] decimal places","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"ClimateMachine.StateCheck.scdocheck(cb, (varr, parr))\nnothing # hide","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"In this trivial case the match is guaranteed. The function will return true to the calling routine and this can be passed to an @test block.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"However we can modify the reference test values to see the effect of a mismatch e.g.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"varr[1][3] = varr[1][3] * 10.0\nClimateMachine.StateCheck.scdocheck(cb, (varr, parr))\nnothing # hide","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"Here the mis-matching field is highlighted with N(0) indicating that the precision was not met and actual match length was (in this case) 0. If any field fails the test returns false for use in any regression testing control logic.","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"","category":"page"},{"location":"generated/Diagnostics/Debug/StateCheck/","page":"State Statistics Regression","title":"State Statistics Regression","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Common/Spectra/#Spectra","page":"Spectra","title":"Spectra","text":"","category":"section"},{"location":"APIs/Common/Spectra/","page":"Spectra","title":"Spectra","text":"CurrentModule = ClimateMachine.Spectra","category":"page"},{"location":"APIs/Common/Spectra/#Methods","page":"Spectra","title":"Methods","text":"","category":"section"},{"location":"APIs/Common/Spectra/","page":"Spectra","title":"Spectra","text":"power_spectrum_1d\npower_spectrum_2d\npower_spectrum_3d","category":"page"},{"location":"APIs/Common/Spectra/#ClimateMachine.Spectra.power_spectrum_1d","page":"Spectra","title":"ClimateMachine.Spectra.power_spectrum_1d","text":"power_spectrum_1d(::AtmosGCMConfigType, var_grid, z, lat, lon, weight)\n\nCalculates the 1D (zonal) power spectra using the fourier transform at each latitude and level from a 3D velocity field. The snapshots of these spectra should be averaged to obtain a time-average. The input velocities must be interpolated to a Gaussian grid.\n\nReferences\n\nA. Wiin-Nielsen (1967) On the annual variation and spectral distribution of atmospheric energy, Tellus, 19:4, 540-559, DOI: 10.3402/tellusa.v19i4.9822\nKoshyk, J. N., and K. Hamilton, 2001: The Horizontal Kinetic Energy Spectrum and Spectral Budget Simulated by a High-Resolution Troposphere–Stratosphere–Mesosphere GCM. J. Atmos. Sci., 58, 329–348, https://doi.org/10.1175/1520-0469(2001)058<0329:THKESA>2.0.CO;2.\n\nArguments\n\nvar_grid: variable (typically u or v) on a Gausian (lon, lat, z) grid to be transformed\nz: vertical coordinate (height or pressure)\nlat: latitude\nlon: longitude\nmass_weight: for mass-weighted calculations\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Spectra/#ClimateMachine.Spectra.power_spectrum_2d","page":"Spectra","title":"ClimateMachine.Spectra.power_spectrum_2d","text":"power_spectrum_2d(::AtmosGCMConfigType, var_grid, mass_weight)\n\ntransform variable on grid to the 2d spectral space using fft on latitude circles\n\n(as for the 1D spectrum) and Legendre polynomials for meridians, and calculate spectra\n\nArguments\n\nvar_grid: variable (typically u or v) on a Gausian (lon, lat, z) grid to be transformed\nmass_weight: weight for mass-weighted calculations\n\nReferences\n\nBaer, F., 1972: An Alternate Scale Representation of Atmospheric Energy Spectra. J. Atmos. Sci., 29, 649–664, https://doi.org/10.1175/1520-0469(1972)029<0649:AASROA>2.0.CO;2\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Spectra/#ClimateMachine.Spectra.power_spectrum_3d","page":"Spectra","title":"ClimateMachine.Spectra.power_spectrum_3d","text":"power_spectrum_3d(::AtmosLESConfigType, u, v, w, L, dim, nor)\n\nCalculates the Powerspectrum from the 3D velocity fields u, v, w. Inputs need to be equi-spaced and the domain is assumed to be the same size and have the same number of points in all directions.\n\nArguments\n\nL: size domain\ndim: number of points\nnor: normalization factor\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#Soil-Heat-Parameterizations","page":"Soil Heat Parameterizations","title":"Soil Heat Parameterizations","text":"","category":"section"},{"location":"APIs/Land/SoilHeatParameterizations/","page":"Soil Heat Parameterizations","title":"Soil Heat Parameterizations","text":"CurrentModule = ClimateMachine.Land.SoilHeatParameterizations","category":"page"},{"location":"APIs/Land/SoilHeatParameterizations/#Heat-functions","page":"Soil Heat Parameterizations","title":"Heat functions","text":"","category":"section"},{"location":"APIs/Land/SoilHeatParameterizations/","page":"Soil Heat Parameterizations","title":"Soil Heat Parameterizations","text":"volumetric_heat_capacity\nvolumetric_internal_energy\nsaturated_thermal_conductivity\nthermal_conductivity\nrelative_saturation\nkersten_number\nk_solid\nk_dry\nksat_unfrozen\nksat_frozen\nvolumetric_internal_energy_liq\ntemperature_from_ρe_int","category":"page"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.volumetric_heat_capacity","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.volumetric_heat_capacity","text":"volumetric_heat_capacity(\n    θ_l::FT,\n    θ_i::FT,\n    ρc_ds::FT,\n    param_set::AbstractParameterSet\n) where {FT}\n\nCompute the expression for volumetric heat capacity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.volumetric_internal_energy","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.volumetric_internal_energy","text":"volumetric_internal_energy(\n    θ_i::FT,\n    ρc_s::FT,\n    T::FT,\n    param_set::AbstractParameterSet\n) where {FT}\n\nCompute the expression for volumetric internal energy.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.saturated_thermal_conductivity","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.saturated_thermal_conductivity","text":"saturated_thermal_conductivity(\n    θ_l::FT,\n    θ_i::FT,\n    κ_sat_unfrozen::FT,\n    κ_sat_frozen::FT\n) where {FT}\n\nCompute the expression for saturated thermal conductivity of soil matrix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.thermal_conductivity","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.thermal_conductivity","text":"thermal_conductivity(\n    κ_dry::FT,\n    K_e::FT,\n    κ_sat::FT\n) where {FT}\n\nCompute the expression for thermal conductivity of soil matrix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.relative_saturation","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.relative_saturation","text":"relative_saturation(\n        θ_l::FT,\n        θ_i::FT,\n        porosity::FT\n) where {FT}\n\nCompute the expression for relative saturation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.kersten_number","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.kersten_number","text":"kersten_number(\n    θ_i::FT,\n    S_r::FT,\n    soil_param_functions::PS\n) where {FT, PS}\n\nCompute the expression for the Kersten number.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.k_solid","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.k_solid","text":"function k_solid(\n    ν_ss_om::FT,\n    ν_ss_quartz::FT,\n    κ_quartz::FT,\n    κ_minerals::FT,\n    κ_om::FT,\n) where {FT}\n\nComputes the thermal conductivity of the solid material in soil. The _ss_ subscript denotes that the volumetric fractions of the soil components are referred to the soil solid components, not including the pore space.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.k_dry","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.k_dry","text":"function k_dry(\n    param_set::AbstractParameterSet\n    soil_param_functions::PS,\n) where {PS}\n\nComputes the thermal conductivity of dry soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.ksat_unfrozen","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.ksat_unfrozen","text":"function ksat_unfrozen(\n    κ_solid::FT,\n    porosity::FT,\n    κ_l::FT\n) where {FT}\n\nComputes the thermal conductivity for saturated unfrozen soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.ksat_frozen","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.ksat_frozen","text":"function ksat_frozen(\n    κ_solid::FT,\n    porosity::FT,\n    κ_ice::FT\n) where {FT}\n\nComputes the thermal conductivity for saturated frozen soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.volumetric_internal_energy_liq","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.volumetric_internal_energy_liq","text":"volumetric_internal_energy_liq(\n    T::FT,\n    T_ref::FT,\n) where {FT}\n\nCompute the expression for the volumetric internal energy of liquid water.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/SoilHeatParameterizations/#ClimateMachine.Land.SoilHeatParameterizations.temperature_from_ρe_int","page":"Soil Heat Parameterizations","title":"ClimateMachine.Land.SoilHeatParameterizations.temperature_from_ρe_int","text":"function temperature_from_ρe_int(\n    ρe_int::FT,\n    θ_i::FT,\n    ρc_s::FT,\n    param_set::AbstractParameterSet\n) where {FT}\n\nComputes the temperature of soil given θ_i and volumetric internal energy ρe_int.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGMethods/Courant/#Discontinuous-Galerkin-Methods","page":"Courant","title":"Discontinuous Galerkin Methods","text":"","category":"section"},{"location":"APIs/Numerics/DGMethods/Courant/","page":"Courant","title":"Courant","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Numerics/DGMethods/Courant/#Functions","page":"Courant","title":"Functions","text":"","category":"section"},{"location":"APIs/Numerics/DGMethods/Courant/","page":"Courant","title":"Courant","text":"Courant\nCourant.advective_courant\nCourant.diffusive_courant\nCourant.nondiffusive_courant","category":"page"},{"location":"APIs/Numerics/DGMethods/Courant/#ClimateMachine.Courant","page":"Courant","title":"ClimateMachine.Courant","text":"Courant\n\nContains stubs for advective, diffusive, and nondiffusive courant number calculations to be used in ClimateMachine.DGMethods.courant. Models should provide concrete implementations if they wish to use these functions.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Numerics/DGMethods/Courant/#ClimateMachine.Courant.advective_courant","page":"Courant","title":"ClimateMachine.Courant.advective_courant","text":"advective_courant(::HBModel)\n\ncalculates the CFL condition due to advection\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGMethods/Courant/#ClimateMachine.Courant.diffusive_courant","page":"Courant","title":"ClimateMachine.Courant.diffusive_courant","text":"diffusive_courant(::HBModel)\n\ncalculates the CFL condition due to temperature diffusivity factor of 1000 is for convective adjustment\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGMethods/Courant/#ClimateMachine.Courant.nondiffusive_courant","page":"Courant","title":"ClimateMachine.Courant.nondiffusive_courant","text":"nondiffusive_courant(::HBModel)\n\ncalculates the CFL condition due to gravity waves\n\n\n\n\n\n","category":"function"},{"location":"HowToGuides/Atmos/AtmosReferenceState/#Atmospheric-temperature-profiles","page":"Reference profiles","title":"Atmospheric temperature profiles","text":"","category":"section"},{"location":"HowToGuides/Atmos/AtmosReferenceState/","page":"Reference profiles","title":"Reference profiles","text":"Here, we plot the atmospheric reference state profiles for a few different polynomial orders and number of elements.","category":"page"},{"location":"HowToGuides/Atmos/AtmosReferenceState/","page":"Reference profiles","title":"Reference profiles","text":"using ClimateMachine\nconst clima_dir = dirname(dirname(pathof(ClimateMachine)));\nusing Plots\ninclude(joinpath(clima_dir, \"docs\", \"plothelpers.jl\"));\ninclude(joinpath(clima_dir, \"test\", \"Atmos\", \"Model\", \"get_atmos_ref_states.jl\"));\n\nfunction export_ref_state_plot(nelem_vert, N_poly)\n    solver_config = get_atmos_ref_states(nelem_vert, N_poly, 0.5)\n    z = get_z(solver_config.dg.grid)\n    all_data = dict_of_nodal_states(solver_config)\n    T = all_data[\"ref_state.T\"]\n    ρ = all_data[\"ref_state.ρ\"]\n    p = all_data[\"ref_state.p\"]\n    ρe = all_data[\"ref_state.ρe\"]\n    p1 = plot(T, z./10^3, xlabel=\"Temperature [K]\");\n    p2 = plot(ρ, z./10^3, xlabel=\"Density [kg/m^3]\");\n    p3 = plot(p./10^3, z./10^3, xlabel=\"Pressure [kPa]\");\n    p4 = plot(ρe./10^3, z./10^3, xlabel=\"Total energy [kJ]\");\n    plot(p1, p2, p3, p4, layout=(1,4), ylabel=\"z [km]\")\n    savefig(\"N_poly_$(N_poly).png\")\nend\n\nexport_ref_state_plot(80, 1)\nexport_ref_state_plot(40, 2)\nexport_ref_state_plot(20, 4)","category":"page"},{"location":"HowToGuides/Atmos/AtmosReferenceState/#Polynomial-order-1,-80-elements","page":"Reference profiles","title":"Polynomial order 1, 80 elements","text":"","category":"section"},{"location":"HowToGuides/Atmos/AtmosReferenceState/","page":"Reference profiles","title":"Reference profiles","text":"(Image: )","category":"page"},{"location":"HowToGuides/Atmos/AtmosReferenceState/#Polynomial-order-2,-40-elements","page":"Reference profiles","title":"Polynomial order 2, 40 elements","text":"","category":"section"},{"location":"HowToGuides/Atmos/AtmosReferenceState/","page":"Reference profiles","title":"Reference profiles","text":"(Image: )","category":"page"},{"location":"HowToGuides/Atmos/AtmosReferenceState/#Polynomial-order-4,-20-elements","page":"Reference profiles","title":"Polynomial order 4, 20 elements","text":"","category":"section"},{"location":"HowToGuides/Atmos/AtmosReferenceState/","page":"Reference profiles","title":"Reference profiles","text":"(Image: )","category":"page"},{"location":"APIs/Atmos/Microphysics/#Microphysics","page":"Microphysics","title":"Microphysics","text":"","category":"section"},{"location":"APIs/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Microphysics","category":"page"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics","page":"Microphysics","title":"ClimateMachine.Microphysics","text":"One-moment bulk microphysics scheme, which includes:\n\nterminal velocity of precipitation\ncondensation and evaporation of cloud liquid water and deposition and sublimation of cloud ice (relaxation to equilibrium)\nautoconversion of cloud liquid water into rain and of cloud ice into snow\naccretion due to collisions between categories of condensed species\nevaporation and sublimation of hydrometeors\nmelting of snow into rain\n\n\n\n\n\n","category":"module"},{"location":"APIs/Atmos/Microphysics/#Methods","page":"Microphysics","title":"Methods","text":"","category":"section"},{"location":"APIs/Atmos/Microphysics/","page":"Microphysics","title":"Microphysics","text":"Microphysics.v0_rai\nMicrophysics.n0_sno\nMicrophysics.τ_relax\nMicrophysics.lambda\nMicrophysics.unpack_params\nMicrophysics.G_func\nMicrophysics.terminal_velocity\nMicrophysics.conv_q_vap_to_q_liq_ice\nMicrophysics.conv_q_liq_to_q_rai\nMicrophysics.conv_q_ice_to_q_sno\nMicrophysics.accretion\nMicrophysics.accretion_rain_sink\nMicrophysics.accretion_snow_rain\nMicrophysics.evaporation_sublimation\nMicrophysics.snow_melt","category":"page"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.v0_rai","page":"Microphysics","title":"ClimateMachine.Microphysics.v0_rai","text":"v0_rai(param_set, ρ)\n\nparam_set - abstract set with earth parameters\nρ air density\n\nReturns the proportionality coefficient in terminal velocity(r/r0).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.n0_sno","page":"Microphysics","title":"ClimateMachine.Microphysics.n0_sno","text":"n0_sno(snow_param_set, q_sno, ρ)\n\nsnow_param_set - abstract set with snow parameters\nq_sno -  snow specific humidity\nρ - air density\n\nReturns the intercept parameter of the assumed Marshall-Palmer distribution of snow particles.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.τ_relax","page":"Microphysics","title":"ClimateMachine.Microphysics.τ_relax","text":"τ_relax(liquid_param_set)\nτ_relax(ice_param_set)\n\nliquid_param_set - abstract set with cloud liquid water parameters\nice_param_set - abstract set with cloud ice parameters\n\nReturns the relaxation timescale for condensation and evaporation of cloud liquid water or the relaxation timescale for sublimation and deposition of cloud ice.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.lambda","page":"Microphysics","title":"ClimateMachine.Microphysics.lambda","text":"lambda(q, ρ, n0, m0, me, r0, χm, Δm)\n\nq - specific humidity of rain, ice or snow\nρ - air density\nn0 - size distribution parameter\nm0, me, χm, Δm, r0 - mass(radius) parameters\n\nReturns the rate parameter of the assumed size distribution of particles (rain drops, ice crystals, snow crystals).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.unpack_params","page":"Microphysics","title":"ClimateMachine.Microphysics.unpack_params","text":"unpack_params(param_set, microphysics_param_set, ρ, q_)\n\nparam_set - abstract set with earth parameters\nmicrophysics_param_set - abstract set with microphysics parameters\nq_ - specific humidity\nρ - air density\n\nUtility function that unpacks microphysics parameters.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.G_func","page":"Microphysics","title":"ClimateMachine.Microphysics.G_func","text":"G_func(param_set, T, Liquid())\nG_func(param_set, T, Ice())\n\nparam_set - abstract set with earth parameters\nT - air temperature\nLiquid(), Ice() - liquid or ice phase to dispatch over.\n\nUtility function combining thermal conductivity and vapor diffusivity effects.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.terminal_velocity","page":"Microphysics","title":"ClimateMachine.Microphysics.terminal_velocity","text":"terminal_velocity(param_set, precip_param_set, ρ, q_)\n\nparam_set - abstract set with earth parameters\nprecip_param_set - abstract set with rain or snow parameters\nρ - air density\nq_ - rain or snow specific humidity\n\nReturns the mass weighted average terminal velocity assuming a Marshall-Palmer (1948) distribution of rain drops and snow crystals.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.conv_q_vap_to_q_liq_ice","page":"Microphysics","title":"ClimateMachine.Microphysics.conv_q_vap_to_q_liq_ice","text":"conv_q_vap_to_q_liq_ice(liquid_param_set::ALPS, q_sat, q)\nconv_q_vap_to_q_liq_ice(ice_param_set::AIPS, q_sat, q)\n\nliquid_param_set - abstract set with cloud water parameters\nice_param_set - abstract set with cloud ice parameters\nq_sat - PhasePartition at equilibrium\nq - current PhasePartition\n\nReturns the cloud water tendency due to condensation and evaporation or cloud ice tendency due to sublimation and vapor deposition. The tendency is obtained assuming a relaxation to equilibrium with a constant timescale.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.conv_q_liq_to_q_rai","page":"Microphysics","title":"ClimateMachine.Microphysics.conv_q_liq_to_q_rai","text":"conv_q_liq_to_q_rai(rain_param_set, q_liq)\n\nrain_param_set - abstract set with rain microphysics parameters\nq_liq - liquid water specific humidity\n\nReturns the q_rai tendency due to collisions between cloud droplets (autoconversion), parametrized following Kessler (1995).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.conv_q_ice_to_q_sno","page":"Microphysics","title":"ClimateMachine.Microphysics.conv_q_ice_to_q_sno","text":"conv_q_ice_to_q_sno(param_set, ice_param_set, q, ρ, T)\n\nparam_set - abstract set with earth parameters\nice_param_set - abstract set with ice microphysics parameters\nq - phase partition\nρ - air density\nT - air temperature\n\nReturns the q_sno tendency due to autoconversion from ice. Parameterized following Harrington et al. (1996) and Kaul et al. (2015).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.accretion","page":"Microphysics","title":"ClimateMachine.Microphysics.accretion","text":"accretion(param_set, cloud_param_set, precip_param_set, q_clo, q_pre, ρ)\n\nparam_set - abstract set with earth parameters\ncloud_param_set - abstract set with cloud water or cloud ice parameters\nprecip_param_set - abstract set with rain or snow parameters\nq_clo - cloud water or cloud ice specific humidity\nq_pre - rain water or snow specific humidity\nρ - rain water or snow specific humidity\n\nReturns the sink of cloud water (liquid or ice) due to collisions with precipitating water (rain or snow).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.accretion_rain_sink","page":"Microphysics","title":"ClimateMachine.Microphysics.accretion_rain_sink","text":"accretion_rain_sink(param_set, ice_param_set, rain_param_set,\n                    q_ice, q_rai, ρ)\n\nparam_set - abstract set with earth parameters\nice_param_set - abstract set with cloud ice parameters\nrain_param_set - abstract set with rain parameters\nq_ice - cloud ice specific humidity\nq_rai - rain water specific humidity\nρ - air density\n\nReturns the sink of rain water (partial source of snow) due to collisions with cloud ice.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.accretion_snow_rain","page":"Microphysics","title":"ClimateMachine.Microphysics.accretion_snow_rain","text":"accretion_snow_rain(param_set, i_param_set, j_param_set, q_i, q_j, ρ)\n\ni - snow for temperatures below freezing       or rain for temperatures above freezing\nj - rain for temperatures below freezing       or rain for temperatures above freezing\nparam_set - abstract set with earth parameters\ni_param_set, j_param_set - abstract set with snow or rain  microphysics parameters\nq_ - specific humidity of snow or rain\nρ - air density\n\nReturns the accretion rate between rain and snow. Collisions between rain and snow result in snow at temperatures below freezing and in rain at temperatures above freezing.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.evaporation_sublimation","page":"Microphysics","title":"ClimateMachine.Microphysics.evaporation_sublimation","text":"evaporation_sublimation(param_set, rain_param_set, q, q_rai, ρ, T)\nevaporation_sublimation(param_set, snow_param_set, q, q_sno, ρ, T)\n\nparam_set - abstract set with earth parameters\nrain_param_set - abstract set with rain microphysics parameters\nsnow_param_set - abstract set with snow microphysics parameters\nq - phase partition\nq_rai - rain specific humidity\nq_sno - snow specific humidity\nρ - air density\nT - air temperature\n\nReturns the tendency due to rain evaporation or snow sublimation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.snow_melt","page":"Microphysics","title":"ClimateMachine.Microphysics.snow_melt","text":"snow_melt(param_set, snow_param_set, q_sno, ρ, T)\n\nparam_set - abstract set with earth parameters\nsnow_param_set - abstract set with snow microphysics parameters\nq_sno - snow water specific humidity\nρ - air density\nT - air temperature\n\nReturns the tendency due to snow melt.\n\n\n\n\n\n","category":"function"},{"location":"HowToGuides/Land/#Land","page":"Land","title":"Land","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/#AtmosModel-docs","page":"AtmosModel","title":"AtmosModel","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Atmos/AtmosModel/#AtmosProblem","page":"AtmosModel","title":"AtmosProblem","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.AtmosProblem","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.AtmosProblem","page":"AtmosModel","title":"ClimateMachine.Atmos.AtmosProblem","text":"AtmosProblem\n\nThe default problem definition (initial and boundary conditions) for AtmosModel.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#AtmosModel-balance-law","page":"AtmosModel","title":"AtmosModel balance law","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.AtmosModel","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.AtmosModel","page":"AtmosModel","title":"ClimateMachine.Atmos.AtmosModel","text":"AtmosModel <: BalanceLaw\n\nA BalanceLaw for atmosphere modeling. Users may over-ride prescribed default values for each field.\n\nUsage\n\nAtmosModel(\n    param_set,\n    problem,\n    orientation,\n    ref_state,\n    turbulence,\n    hyperdiffusion,\n    spongelayer,\n    moisture,\n    radiation,\n    source,\n    tracers,\n    data_config,\n)\n\nFields\n\nparam_set\nParameter Set (type to dispatch on, e.g., planet parameters. See CLIMAParameters.jl package)\nproblem\nProblem (initial and boundary conditions)\norientation\nAn orientation model\nref_state\nReference State (For initial conditions, or for linearisation when using implicit solvers)\nturbulence\nTurbulence Closure (Equations for dynamics of under-resolved turbulent flows)\nturbconv\nTurbulence Convection Closure (e.g., EDMF)\nhyperdiffusion\nHyperdiffusion Model (Equations for dynamics of high-order spatial wave attenuation)\nviscoussponge\nViscous sponge layers\nmoisture\nMoisture Model (Equations for dynamics of moist variables)\nprecipitation\nPrecipitation Model (Equations for dynamics of precipitating species)\nradiation\nRadiation Model (Equations for radiative fluxes)\nsource\nSource Terms (Problem specific source terms)\ntracers\nTracer Terms (Equations for dynamics of active and passive tracers)\ndata_config\nData Configuration (Helper field for experiment configuration)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#AtmosModel-methods","page":"AtmosModel","title":"AtmosModel methods","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.BalanceLaws.flux_first_order!(m::AtmosModel, flux::Grad, state::Vars, aux::Vars, t::Real, direction)\nClimateMachine.BalanceLaws.flux_second_order!(atmos::AtmosModel, flux::Grad, state::Vars, diffusive::Vars, hyperdiffusive::Vars, aux::Vars, t::Real)\nClimateMachine.BalanceLaws.init_state_auxiliary!(m::AtmosModel, state_auxiliary::MPIStateArray, grid, direction)\nClimateMachine.BalanceLaws.source!(m::AtmosModel, source::Vars, state::Vars, diffusive::Vars, aux::Vars, t::Real, direction)\nClimateMachine.BalanceLaws.init_state_prognostic!(m::AtmosModel, state::Vars, aux::Vars, localgeo, t, args...)","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.BalanceLaws.flux_first_order!-Tuple{ClimateMachine.Atmos.AtmosModel,ClimateMachine.VariableTemplates.Grad,ClimateMachine.VariableTemplates.Vars,ClimateMachine.VariableTemplates.Vars,Real,Any}","page":"AtmosModel","title":"ClimateMachine.BalanceLaws.flux_first_order!","text":"flux_first_order!(\n    m::AtmosModel,\n    flux::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real\n)\n\nComputes and assembles non-diffusive fluxes in the model equations.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.BalanceLaws.flux_second_order!-Tuple{ClimateMachine.Atmos.AtmosModel,ClimateMachine.VariableTemplates.Grad,ClimateMachine.VariableTemplates.Vars,ClimateMachine.VariableTemplates.Vars,ClimateMachine.VariableTemplates.Vars,ClimateMachine.VariableTemplates.Vars,Real}","page":"AtmosModel","title":"ClimateMachine.BalanceLaws.flux_second_order!","text":"flux_second_order!(\n    atmos::AtmosModel,\n    flux::Grad,\n    state::Vars,\n    diffusive::Vars,\n    hyperdiffusive::Vars,\n    aux::Vars,\n    t::Real\n)\n\nDiffusive fluxes in AtmosModel. Viscosity, diffusivity are calculated in the turbulence subcomponent and accessed within the diffusive flux function. Contributions from subcomponents are then assembled (pointwise).\n\n\n\n\n\n","category":"method"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.BalanceLaws.init_state_auxiliary!-Tuple{ClimateMachine.Atmos.AtmosModel,ClimateMachine.MPIStateArrays.MPIStateArray,Any,Any}","page":"AtmosModel","title":"ClimateMachine.BalanceLaws.init_state_auxiliary!","text":"init_state_auxiliary!(\n    m::AtmosModel,\n    aux::Vars,\n    grid,\n    direction\n)\n\nInitialise auxiliary variables for each AtmosModel subcomponent. Store Cartesian coordinate information in aux.coord.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.BalanceLaws.source!-Tuple{ClimateMachine.Atmos.AtmosModel,ClimateMachine.VariableTemplates.Vars,ClimateMachine.VariableTemplates.Vars,ClimateMachine.VariableTemplates.Vars,ClimateMachine.VariableTemplates.Vars,Real,Any}","page":"AtmosModel","title":"ClimateMachine.BalanceLaws.source!","text":"source!(\n    m::AtmosModel,\n    source::Vars,\n    state::Vars,\n    diffusive::Vars,\n    aux::Vars,\n    t::Real,\n    direction::Direction,\n)\n\nComputes (and assembles) source terms S(Y) in:\n\n∂Y\n-- = - ∇ • F + S(Y)\n∂t\n\n\n\n\n\n","category":"method"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.BalanceLaws.init_state_prognostic!-Tuple{ClimateMachine.Atmos.AtmosModel,ClimateMachine.VariableTemplates.Vars,ClimateMachine.VariableTemplates.Vars,Any,Any,Vararg{Any,N} where N}","page":"AtmosModel","title":"ClimateMachine.BalanceLaws.init_state_prognostic!","text":"init_state_prognostic!(\n    m::AtmosModel,\n    state::Vars,\n    aux::Vars,\n    localgeo,\n    t,\n    args...,\n)\n\nInitialise state variables. args... provides an option to include configuration data (current use cases include problem constants, spline-interpolants).\n\n\n\n\n\n","category":"method"},{"location":"APIs/Atmos/AtmosModel/#Reference-states","page":"AtmosModel","title":"Reference states","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.HydrostaticState\nClimateMachine.Atmos.InitStateBC\nClimateMachine.Atmos.ReferenceState\nClimateMachine.Atmos.NoReferenceState","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.HydrostaticState","page":"AtmosModel","title":"ClimateMachine.Atmos.HydrostaticState","text":"HydrostaticState{P,T} <: ReferenceState\n\nA hydrostatic state specified by a virtual temperature profile and relative humidity.\n\nBy default, this is a dry hydrostatic reference state.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.InitStateBC","page":"AtmosModel","title":"ClimateMachine.Atmos.InitStateBC","text":"InitStateBC\n\nSet the value at the boundary to match the init_state_prognostic! function. This is mainly useful for cases where the problem has an explicit solution.\n\nTODO: This should be fixed later once BCs are figured out (likely want\n\ndifferent things here?)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.ReferenceState","page":"AtmosModel","title":"ClimateMachine.Atmos.ReferenceState","text":"ReferenceState\n\nHydrostatic reference state, for example, used as initial condition or for linearization.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.NoReferenceState","page":"AtmosModel","title":"ClimateMachine.Atmos.NoReferenceState","text":"NoReferenceState <: ReferenceState\n\nNo reference state used\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#Thermodynamics","page":"AtmosModel","title":"Thermodynamics","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.recover_thermo_state\nClimateMachine.Atmos.new_thermo_state","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.recover_thermo_state","page":"AtmosModel","title":"ClimateMachine.Atmos.recover_thermo_state","text":"recover_thermo_state(atmos::AtmosModel, state::Vars, aux::Vars)\n\nAn atmospheric thermodynamic state.\n\nwarn: Warn\nWhile recoverthermostate is an ideal long-term solution, right now we are directly calling newthermostate to avoid inconsistent aux states in kernels where the aux states are out of sync with the boundary state.\n\nTODO:\n\n- Allow a safe way to call\n`recover_thermo_state(state, moist::EquilMoist, ...)`\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.new_thermo_state","page":"AtmosModel","title":"ClimateMachine.Atmos.new_thermo_state","text":"new_thermo_state(atmos::AtmosModel, state::Vars, aux::Vars)\n\nCreate a new thermodynamic state, based on the state, and not the aux state.\n\nnote: Note\nThis method calls the iterative saturation adjustment procedure for EquilMoist models.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/AtmosModel/#Moisture","page":"AtmosModel","title":"Moisture","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.DryModel\nClimateMachine.Atmos.EquilMoist\nClimateMachine.Atmos.NonEquilMoist\nClimateMachine.Atmos.NoPrecipitation\nClimateMachine.Atmos.Rain","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.DryModel","page":"AtmosModel","title":"ClimateMachine.Atmos.DryModel","text":"DryModel\n\nAssumes the moisture components is in the dry limit.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.EquilMoist","page":"AtmosModel","title":"ClimateMachine.Atmos.EquilMoist","text":"EquilMoist\n\nAssumes the moisture components are computed via thermodynamic equilibrium.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.NonEquilMoist","page":"AtmosModel","title":"ClimateMachine.Atmos.NonEquilMoist","text":"NonEquilMoist\n\nDoes not assume that the moisture components are in equilibrium.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.NoPrecipitation","page":"AtmosModel","title":"ClimateMachine.Atmos.NoPrecipitation","text":"NoPrecipitation <: PrecipitationModel\n\nNo precipitation.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.Rain","page":"AtmosModel","title":"ClimateMachine.Atmos.Rain","text":"Rain <: PrecipitationModel\n\nPrecipitation model with rain only.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#Stabilization","page":"AtmosModel","title":"Stabilization","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.RayleighSponge","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.RayleighSponge","page":"AtmosModel","title":"ClimateMachine.Atmos.RayleighSponge","text":"RayleighSponge{FT} <: Source\n\nRayleigh Damping (Linear Relaxation) for top wall momentum components Assumes laterally periodic boundary conditions for LES flows. Momentum components are relaxed to reference values (zero velocities) at the top boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#BCs","page":"AtmosModel","title":"BCs","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.AtmosBC\nClimateMachine.Atmos.DragLaw\nClimateMachine.Atmos.Impermeable\nClimateMachine.Atmos.PrescribedMoistureFlux\nClimateMachine.Atmos.BulkFormulaMoisture\nClimateMachine.Atmos.FreeSlip\nClimateMachine.Atmos.PrescribedTemperature\nClimateMachine.Atmos.PrescribedEnergyFlux\nClimateMachine.Atmos.BulkFormulaEnergy\nClimateMachine.Atmos.ImpermeableTracer\nClimateMachine.Atmos.Impenetrable\nClimateMachine.Atmos.Insulating\nClimateMachine.Atmos.NoSlip\nClimateMachine.Atmos.average_density","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.AtmosBC","page":"AtmosModel","title":"ClimateMachine.Atmos.AtmosBC","text":"AtmosBC(momentum = Impenetrable(FreeSlip())\n        energy   = Insulating()\n        moisture = Impermeable()\n        tracer  = ImpermeableTracer())\n\nThe standard boundary condition for AtmosModel. The default options imply a \"no flux\" boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.DragLaw","page":"AtmosModel","title":"ClimateMachine.Atmos.DragLaw","text":"DragLaw(fn) :: MomentumDragBC\n\nDrag law for momentum parallel to the boundary. The drag coefficient is C = fn(state, aux, t, normu_int_tan), where normu_int_tan is the internal speed parallel to the boundary. _int refers to the first interior node.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.Impermeable","page":"AtmosModel","title":"ClimateMachine.Atmos.Impermeable","text":"Impermeable() :: MoistureBC\n\nNo moisture flux.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.PrescribedMoistureFlux","page":"AtmosModel","title":"ClimateMachine.Atmos.PrescribedMoistureFlux","text":"PrescribedMoistureFlux(fn) :: MoistureBC\n\nPrescribe the net inward moisture flux across the boundary by fn, a function with signature fn(state, aux, t), returning the flux (in kg/m^2).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.BulkFormulaMoisture","page":"AtmosModel","title":"ClimateMachine.Atmos.BulkFormulaMoisture","text":"BulkFormulaMoisture(fn) :: MoistureBC\n\nCalculate the net inward moisture flux across the boundary using the bulk formula. The drag coefficient is C_q = fn_C_q(state, aux, t, normu_int_tan). The surface qtot at the boundary is `qtot = fnqtot(state, aux, t)`.\n\nReturn the flux (in kg m^-2 s^-1).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.FreeSlip","page":"AtmosModel","title":"ClimateMachine.Atmos.FreeSlip","text":"FreeSlip() :: MomentumDragBC\n\nNo surface drag on momentum parallel to the boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.PrescribedTemperature","page":"AtmosModel","title":"ClimateMachine.Atmos.PrescribedTemperature","text":"PrescribedTemperature(fn) :: EnergyBC\n\nPrescribe the temperature at the boundary by fn, a function with signature fn(state, aux, t) returning the temperature (in K).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.PrescribedEnergyFlux","page":"AtmosModel","title":"ClimateMachine.Atmos.PrescribedEnergyFlux","text":"PrescribedEnergyFlux(fn) :: EnergyBC\n\nPrescribe the net inward energy flux across the boundary by fn, a function with signature fn(state, aux, t), returning the flux (in W/m^2).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.BulkFormulaEnergy","page":"AtmosModel","title":"ClimateMachine.Atmos.BulkFormulaEnergy","text":"BulkFormulaEnergy(fn) :: EnergyBC\n\nCalculate the net inward energy flux across the boundary. The drag coefficient is C_h = fn_C_h(state, aux, t, normu_int_tan). The surface temperature and qtot are `T, qtot = fnTandqtot(state, aux, t)`.\n\nReturn the flux (in W m^-2).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.ImpermeableTracer","page":"AtmosModel","title":"ClimateMachine.Atmos.ImpermeableTracer","text":"ImpermeableTracer() :: TracerBC\n\nNo tracer diffusion across boundary\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.Impenetrable","page":"AtmosModel","title":"ClimateMachine.Atmos.Impenetrable","text":"Impenetrable(drag::MomentumDragBC) :: MomentumBC\n\nDefines an impenetrable wall model for momentum. This implies:\n\nno flow in the direction normal to the boundary, and\nflow parallel to the boundary is subject to the drag condition.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.Insulating","page":"AtmosModel","title":"ClimateMachine.Atmos.Insulating","text":"Insulating() :: EnergyBC\n\nNo energy flux across the boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.NoSlip","page":"AtmosModel","title":"ClimateMachine.Atmos.NoSlip","text":"NoSlip() :: MomentumDragBC\n\nZero momentum at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.average_density","page":"AtmosModel","title":"ClimateMachine.Atmos.average_density","text":"average_density(ρ_sfc, ρ_int)\n\nAverage density between the surface and the interior point, given\n\nρ_sfc density at the surface\nρ_int density at the interior point\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/AtmosModel/#Sources","page":"AtmosModel","title":"Sources","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.RemovePrecipitation\nClimateMachine.Atmos.CreateClouds","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.RemovePrecipitation","page":"AtmosModel","title":"ClimateMachine.Atmos.RemovePrecipitation","text":"RemovePrecipitation{FT} <: Source\n\nA sink to q_tot when cloud condensate is exceeding a threshold. The threshold is defined either in terms of condensate or supersaturation. The removal rate is implemented as a relaxation term in the Microphysics_0M module. The default thresholds and timescale are defined in CLIMAParameters.jl.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.CreateClouds","page":"AtmosModel","title":"ClimateMachine.Atmos.CreateClouds","text":"CreateClouds{FT} <: Source\n\nA source/sink to q_liq and q_ice implemented as a relaxation towards equilibrium in the Microphysics module. The default relaxation timescales are defined in CLIMAParameters.jl.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Diagnostics/StateCheck/#State-Check","page":"State Check","title":"State Check","text":"","category":"section"},{"location":"APIs/Diagnostics/StateCheck/","page":"State Check","title":"State Check","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Diagnostics/StateCheck/","page":"State Check","title":"State Check","text":"ClimateMachine.StateCheck","category":"page"},{"location":"APIs/Diagnostics/StateCheck/#ClimateMachine.StateCheck","page":"State Check","title":"ClimateMachine.StateCheck","text":"StateCheck\n\nModule with a minimal set of functions for getting statistics and basic I/O from ClimateMachine DG state arrays (MPIStateArray type). Created for regression testing and code change tracking and debugging. StateCheck functions iterate over named variables in an MPIStateArray, calculate and report their statistics and/or write values for all or some subset of points at a fixed frequency.\n\nFunctions\n\nsccreate Create a StateCheck call back variable.\nscdocheck Check StateCheck variable values against reference values.\nscprintref Print StateCheck variable in format for creating reference values.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Diagnostics/StateCheck/#Methods","page":"State Check","title":"Methods","text":"","category":"section"},{"location":"APIs/Diagnostics/StateCheck/","page":"State Check","title":"State Check","text":"ClimateMachine.StateCheck.sccreate\nClimateMachine.StateCheck.scdocheck\nClimateMachine.StateCheck.scprintref","category":"page"},{"location":"APIs/Diagnostics/StateCheck/#ClimateMachine.StateCheck.sccreate","page":"State Check","title":"ClimateMachine.StateCheck.sccreate","text":"sccreate(\n    io::IO,\n    fields::Array{<:Tuple{<:MPIStateArray, String}},\n    nt_freq::Int = 10;\n    prec = 15\n)\n\nCreate a \"state check\" call-back for one or more MPIStateArray variables that will report basic statistics for the fields in the array.\n\nio an IO stream to use for printed output\nfields a required first argument that is an array of one or more                     MPIStateArray variable and label string pair tuples.                     State array statistics will be reported for the named symbols                     in each MPIStateArray labeled with the label string.\nnt_freq an optional second argument with default value of                     10 that sets how frequently (in time-step counts) the                     statistics are reported.\nprec a named argument that sets number of decimal places to print for                     statistics, defaults to 15.\n\nExamples\n\nusing ClimateMachine.VariableTemplates\nusing StaticArrays\nusing ClimateMachine.MPIStateArrays\nusing MPI\nMPI.Init()\nFT=Float64\nF1=@vars begin; ν∇u::SMatrix{3, 2, FT, 6}; κ∇θ::SVector{3, FT}; end\nF2=@vars begin; u::SVector{2, FT}; θ::SVector{1, FT}; end\nQ1=MPIStateArray{Float32,F1}(MPI.COMM_WORLD,ClimateMachine.array_type(),4,9,8);\nQ2=MPIStateArray{Float64,F2}(MPI.COMM_WORLD,ClimateMachine.array_type(),4,6,8);\ncb=ClimateMachine.StateCheck.sccreate([(Q1,\"My gradients\"),(Q2,\"My fields\")],1; prec=15);\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/StateCheck/#ClimateMachine.StateCheck.scdocheck","page":"State Check","title":"ClimateMachine.StateCheck.scdocheck","text":"scdocheck(cb, ref_dat)\n\nCompare a current State check call-back set of values with a reference set and match precision table pair.\n\ncb StateCheck call-back variables\nref_dat an array of reference values and precision to match tables.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/StateCheck/#ClimateMachine.StateCheck.scprintref","page":"State Check","title":"ClimateMachine.StateCheck.scprintref","text":"scprintref(cb)\n\nPrint out a \"state check\" call-back table of values in a format suitable for use as a set of reference numbers for CI comparison.\n\ncb callback variable of type ClimateMachine.GenericCallbacks.Every*\n\n\n\n\n\n","category":"function"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Numerics/SystemSolvers/cg.jl\"","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/#Conjugate-Gradient","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"In this tutorial we describe the basics of using the conjugate gradient iterative solvers At the end you should be able to","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Use Conjugate Gradient to solve a linear system\nKnow when to not use it\nContruct a column-wise linear solver with Conjugate Gradient","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/#What-is-it?","page":"Conjugate Gradient","title":"What is it?","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Conjugate Gradient is an iterative method for solving special kinds of linear systems:","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":" Ax = b","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"via iterative methods.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"warning: Warning\nThe linear operator need to be symmetric positive definite and the preconditioner must be symmetric.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"See the wikipedia for more details.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/#Basic-Example","page":"Conjugate Gradient","title":"Basic Example","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"First we must load a few things","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"using ClimateMachine\nusing ClimateMachine.SystemSolvers\nusing LinearAlgebra, Random","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Next we define a 3x3 symmetric positive definite linear system. (In the ClimateMachine code a symmetric positive definite system could arise from treating diffusion implicitly.)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"A = [\n    2.0 -1.0 0.0\n    -1.0 2.0 -1.0\n    0.0 -1.0 2.0\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We define the matrix A here as a global variable for convenience later.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We can see that it is symmetric. We can check that it is positive definite by checking the spectrum","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"eigvals(A)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The linear operators that are passed into the abstract iterative solvers need to be defined as functions that act on vectors. Let us do that with our matrix. We are using function closures for type stability.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"function closure_linear_operator!(A)\n    function linear_operator!(x, y)\n        mul!(x, A, y)\n    end\n    return linear_operator!\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We now define our linear operator using the function closure","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linear_operator! = closure_linear_operator!(A)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We now define our b in the linear system","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"b = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The exact solution to the system Ax = b is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"x_exact = [1.5, 2.0, 1.5];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we can set up the ConjugateGradient struct","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linearsolver = ConjugateGradient(b);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"and an initial guess for the iterative solver.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"x = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"To solve the linear system we just need to pass to the linearsolve! function","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters = linearsolve!(linear_operator!, nothing, linearsolver, x, b)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The variable x gets overwritten during the linear solve The norm of the error is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(x - x_exact) / norm(x_exact)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The relative norm of the residual is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(A * x - b) / norm(b)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The number of iterations is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Conjugate Gradient is guaranteed to converge in 3 iterations with perfect arithmetic in this case.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/#Non-Example","page":"Conjugate Gradient","title":"Non-Example","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Conjugate Gradient is not guaranteed to converge with nonsymmetric matrices. Consider","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"A = [\n    2.0 -1.0 0.0\n    0.0 2.0 -1.0\n    0.0 0.0 2.0\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We define the matrix A here as a global variable for convenience later.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We can see that it is not symmetric, but it does have all positive eigenvalues","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"eigvals(A)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The linear operators that are passed into the abstract iterative solvers need to be defined as functions that act on vectors. Let us do that with our matrix. We are using function closures for type stability.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"function closure_linear_operator!(A)\n    function linear_operator!(x, y)\n        mul!(x, A, y)\n    end\n    return linear_operator!\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We define the linear operator using our function closure","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linear_operator! = closure_linear_operator!(A)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We now define our b in the linear system","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"b = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The exact solution to the system Ax = b is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"x_exact = [0.875, 0.75, 0.5];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we can set up the ConjugateGradient struct","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linearsolver = ConjugateGradient(b, max_iter = 100);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We also passed in the keyword argument \"max_iter\" for the maximum number of iterations of the iterative solver. By default it is assumed to be the size of the vector. As before we need to define an initial guess","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"x = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"To (not) solve the linear system we just need to pass to the linearsolve! function","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters = linearsolve!(linear_operator!, nothing, linearsolver, x, b)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The variable x gets overwitten during the linear solve The norm of the error is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(x - x_exact) / norm(x_exact)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The relative norm of the residual is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(A * x - b) / norm(b)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The number of iterations is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Conjugate Gradient is guaranteed to converge in 3 iterations with perfect arithmetic for a symmetric positive definite matrix. Here we see that the matrix is not symmetric and it didn't converge even after 100 iterations.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/#More-Complex-Example","page":"Conjugate Gradient","title":"More Complex Example","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Here we show how to construct a column-wise iterative solver similar to what is is in the ClimateMachine code. The following is not for the faint of heart. We must first define a linear operator that acts like one in the ClimateMachine","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"function closure_linear_operator!(A, tup)\n    function linear_operator!(y, x)\n        alias_x = reshape(x, tup)\n        alias_y = reshape(y, tup)\n        for i6 in 1:tup[6]\n            for i4 in 1:tup[4]\n                for i2 in 1:tup[2]\n                    for i1 in 1:tup[1]\n                        tmp = alias_x[i1, i2, :, i4, :, i6][:]\n                        tmp2 = A[i1, i2, i4, i6] * tmp\n                        alias_y[i1, i2, :, i4, :, i6] .=\n                            reshape(tmp2, (tup[3], tup[5]))\n                    end\n                end\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now that we have this function, we can define a linear system that we will solve columnwise First we define the structure of our array as tup in a manner that is similar to a stacked brick topology","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"tup = (3, 4, 7, 2, 20, 2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"where","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"tup[1] is the number of Gauss–Lobatto points in the x-direction\ntup[2] is the number of Gauss–Lobatto points in the y-direction\ntup[3] is the number of Gauss–Lobatto points in the z-direction\ntup[4] is the number of states\ntup[5] is the number of elements in the vertical direction\ntup[6] is the number of elements in the other directions","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we define our linear operator as a random matrix.","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Random.seed!(1235);\nB = [\n    randn(tup[3] * tup[5], tup[3] * tup[5])\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_A = [\n    B[i1, i2, i4, i6] * B[i1, i2, i4, i6]' + 10I\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_inv_A = [\n    inv(columnwise_A[i1, i2, i4, i6])\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_linear_operator! = closure_linear_operator!(columnwise_A, tup);\ncolumnwise_inverse_linear_operator! =\n    closure_linear_operator!(columnwise_inv_A, tup);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We define our x and b with matrix structures similar to an MPIStateArray","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"mpi_tup = (tup[1] * tup[2] * tup[3], tup[4], tup[5] * tup[6]);\nb = randn(mpi_tup);\nx = randn(mpi_tup);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we solve the linear system columnwise","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linearsolver = ConjugateGradient(\n    x,\n    max_iter = tup[3] * tup[5],\n    dims = (3, 5),\n    reshape_tuple = tup,\n);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The keyword arguments dims is the reduction dimension for the linear solver. In this case dims = (3,5) are the ones associated with a column. The reshape_tuple argument is to convert the shapes of the array x in the a form that is more easily usable for reductions in the linear solver","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we can solve it","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters = linearsolve!(columnwise_linear_operator!, nothing, linearsolver, x, b);\nx_exact = copy(x);\ncolumnwise_inverse_linear_operator!(x_exact, b);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The norm of the error is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(x - x_exact) / norm(x_exact)","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The number of iterations is","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The algorithm converges within tup[3]*tup[5] = 140 iterations","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/#Tips","page":"Conjugate Gradient","title":"Tips","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The convergence criteria should be changed, machine precision is too small and the maximum iterations is often too large\nUse a preconditioner if possible\nMake sure that the linear system really is symmetric and positive-definite","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"","category":"page"},{"location":"generated/Numerics/SystemSolvers/cg/","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Land/Soil/Water/hydraulic_functions.jl\"","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/#Hydraulic-functions","page":"Hydraulic Functions","title":"Hydraulic functions","text":"","category":"section"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"This tutorial shows how to specify the hydraulic functions used in Richard's equation. In particular, we show how to choose the formalism for matric potential and hydraulic conductivity, and how to make the hydraulic conductivity account for the presence of ice as well as the temperature dependence of the viscosity of liquid water.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"ClimateMachine's Land model allows the user to pick between two hydraulics models, that of van Genuchten [1] or that of Brooks and Corey [2, 3]. The same model is consistently used for the matric potential and hydraulic conductivity.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/#Preliminary-setup","page":"Hydraulic Functions","title":"Preliminary setup","text":"","category":"section"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"External modules","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"using Plots","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"ClimateMachine modules","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"using ClimateMachine\nusing ClimateMachine.Land\nusing ClimateMachine.Land.SoilWaterParameterizations\n\nFT = Float32;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/#Specifying-a-hydraulics-model","page":"Hydraulic Functions","title":"Specifying a  hydraulics model","text":"","category":"section"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The van Genuchten model requires two free parameters, α and n. A third parameter, m, is computed from n. Of these, only α carries units, of inverse meters. The Brooks and Corey model also uses two free parameters, ψ_b, the magnitude of the matric potential at saturation,  and a constant M. ψ_b carries units of meters. The hydraulic conductivity requires an additional parameter, Ksat (m/s), which is the hydraulic conductivity in saturated soil. This parameter is the same between the two models for a given soil type, and is not stored in the hydraulics model, but rather as part of the SoilParamFunctions.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Below we show how to create two concrete examples of these hydraulics models, for sandy loam [1]. Note that the parameters chosen are a function of soil type.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"vg_α = FT(7.5) # m^-1\nvg_n = FT(1.89)\nhydraulics = vanGenuchten{FT}(α = vg_α, n = vg_n)\n\nψ_sat = 0.09 # m\nMval = 0.228\nhydraulics_bc = BrooksCorey{FT}(ψb = ψ_sat, m = Mval);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/#Matric-Potential","page":"Hydraulic Functions","title":"Matric Potential","text":"","category":"section"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The matric potential ψ represents how much water clings to soil. Drier soil holds onto water more tightly, making diffusion more difficult. As soil becomes wetter, the matric potential decreases in magnitude, making diffusion easier.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The van Genuchten expression for matric potential is ψ = -frac1α S_l^-1(nm)times (1-S_l^1m)^1n","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"and the Brooks and Corey expression is ψ = -ψ_b S_l^-M","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Here S_l is the effective saturation of liquid water, θ_l/ν, where ν is porosity of the soil. We neglect the residual pore space in the CliMA model.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"In the CliMA code, we use multiple dispatch. With multiple dispatch, a function can have many ways of executing (called methods), depending on the type of the variables passed in. A simple example of multiple dispatch is the division operation. Integer division takes two numbers as input, and returns an integer - ignoring the decimal. Float division takes two numbers as input, and returns a floating point number, including the decimal. In Julia, we might write these as:","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"function division(a::Int, b::Int)\n     return floor(Int, a/b)\nend","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"function division(a::Float64, b::Float64)\n     return a/b\nend","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"We can see that division is now a function with two methods.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"julia> division\ndivision (generic function with 2 methods)","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Now, using the same function signature, we can carry out integer division or floating point division, depending on the types of the arguments:","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"julia> division(1,2)\n0\n\njulia> division(1.0,2.0)\n0.5","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Here is a more pertinent example: hydraulics is of type vanGenuchten{Float32} based on our choice of FT:","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"julia> typeof(hydraulics)\nvanGenuchten{Float32}","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"but meanwhile,","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"julia> typeof(hydraulics_bc)\nBrooksCorey{Float32}","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The function matric_potential will execute different methods depending on if we pass a hydraulics model of type vanGenuchten or BrooksCorey. In both cases, it will return the correct value for ψ.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Let's plot the matric potential as a function of the effective saturation S_l = θ_l/ν, which can range from zero to one.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"S_l = FT.(0.01:0.01:0.99)\nψ = matric_potential.(Ref(hydraulics), S_l)\nψ_bc = matric_potential.(Ref(hydraulics_bc), S_l)\nplot(\n    S_l,\n    log10.(-ψ),\n    xlabel = \"effective saturation\",\n    ylabel = \"Log10(|ψ|)\",\n    label = \"van Genuchten\",\n)\nplot!(S_l, log10.(-ψ_bc), label = \"Brooks and Corey\")\nsavefig(\"bc_vg_matric_potential.png\")","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"(Image: )","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The steep slope in ψ near saturated and completely dry soil are part of the reason why Richard's equation is such a challenging numerical problem.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/#Hydraulic-conductivity","page":"Hydraulic Functions","title":"Hydraulic conductivity","text":"","category":"section"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The hydraulic conductivity is a more complex function than the matric potential, as it depends on the temperature of the water, the volumetric ice fraction, and the volumetric liquid water fraction. It also depends on the hydraulics model chosen.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"We represent the hydraulic conductivity K as the product of four factors: Ksat, an impedance_factor (which accounts for the effect of ice on conductivity) a viscosity_factor (which accounts for the effect of temperature on the viscosity of liquid water, and how that in turn affects conductivity) and a moisture_factor (which accounts for the effect of liquid water, and is determined by the hydraulics model).","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Let's start with ice and temperature independence, but moisture dependence. Below we choose additional parameters, consistent with the hydraulics parameters for sandy loam [1].","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"ν = FT(0.41)\nKsat = FT(4.42 / (3600 * 100))\nmoisture_choice = MoistureDependent{FT}()\nviscosity_choice = ConstantViscosity{FT}()\nimpedance_choice = NoImpedance{FT}();\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"We are going to calculate K = Ksat × viscosity_factor × impedance_factor × moisture_factor. In the code, each of these factors is a function with multiple methods, except for Ksat.  Our function hydraulic_conductivity calls each of these functions in turn, and these functions use multiple dispatch to provide the correct value for K.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Like we defined new type classes for vanGenuchten{FT} and BrooksCorey{FT}, we also created new type classes for the impedance choice, the viscosity choice, and the moisture choice.  For example, the function called viscosity_factor, when passed an object of type ConstantViscosity{FT}, executes a method that always returns 1. The same is true for the function impedance_factor, using the type NoImpedance{FT}, and for moisture_factor, using the type MoistureIndependent{FT}.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"In the case where the moisture_factor = MoistureDependent{FT}(), either the van Genuchten or Brooks and Corey expression is used based on the type of hydraulics model passed.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The moisture_factor for the van Genuchten model is (denoting it as K_m)","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"K_m = sqrtS_l1-(1-S_l^1m)^m^2","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"for S_l  1,","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"and for the Brooks and Corey model it is","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"K_m = S_l^2M+3","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"also for S_l1. When S_lgeq 1, K_m = 1 for each model.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"One side effect of this flexibility is that hydraulic_conductivity requires all the arguments it could possibly need passed to it, which is why here we must supply a value T and θ_i, even though they are not used in this particular example.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"T = FT(0.0)\nθ_i = FT(0.0)\n\nK =\n    Ksat .*\n    hydraulic_conductivity.(\n        Ref(impedance_choice),\n        Ref(viscosity_choice),\n        Ref(moisture_choice),\n        Ref(hydraulics),\n        Ref(θ_i),\n        Ref(ν),\n        Ref(T),\n        S_l,\n    );\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Let's also compute K when we include the effects of temperature and ice on the hydraulic conductivity. In the cases where a TemperatureDependentViscosity{FT} or IceImpedance{FT} type is passed, the correct factors are calculated, based on the temperature T and volumetric ice fraction θ_i. In these cases, the viscosity_factor, denoted here as K_v, evaluates as:","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"K_v = e^gamma(T-T_ref)","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"where gamma = 00264 mboxK^-1 is an empirical factor, and T_ref = 288 K, and the impedance_factor, denoted K_i, evaluates as:","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"K_i = 10^-Omega f_i","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"where Omega = 7 is an empirical factor and f_i is the ratio of the volumetric ice fraction to total volumetric water fraction [5].","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"viscosity_choice_T = TemperatureDependentViscosity{FT}()\nT = FT(300.0)\nK_T =\n    Ksat .*\n    hydraulic_conductivity.(\n        Ref(impedance_choice),\n        Ref(viscosity_choice_T),\n        Ref(moisture_choice),\n        Ref(hydraulics),\n        Ref(θ_i),\n        Ref(ν),\n        Ref(T),\n        S_l,\n    )\nice_impedance_I = IceImpedance{FT}()\nθ_i = FT(0.1)\nS_i = θ_i / ν;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The total volumetric water fraction cannot exceed unity, so the effective liquid water saturation should have a max of 1-S_i.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"S_l_accounting_for_ice = FT.(0.01:0.01:(0.99 - S_i))\nK_i =\n    Ksat .*\n    hydraulic_conductivity.(\n        Ref(ice_impedance_I),\n        Ref(viscosity_choice),\n        Ref(moisture_choice),\n        Ref(hydraulics),\n        Ref(θ_i),\n        Ref(ν),\n        Ref(T),\n        S_l_accounting_for_ice,\n    )\nplot(\n    S_l,\n    log10.(K),\n    xlabel = \"total effective saturation, (θ_i+θ_l)/ν\",\n    ylabel = \"Log10(K)\",\n    label = \"Base case\",\n    legend = :bottomright,\n)\nplot!(S_l, log10.(K_T), label = \"Temperature Dependent Viscosity; no ice\")\nplot!(\n    S_l_accounting_for_ice .+ S_i,\n    log10.(K_i),\n    label = \"Ice Impedance; S_i=0.24\",\n)\nsavefig(\"T_ice_K.png\")","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"(Image: )","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"If the user is not considering phase transitions and does not add in Freeze/Thaw source terms, the default is for zero ice in the model, for all time and space. In this case the ice impedance factor evaluates to 1 regardless of which type is passed.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"We can also look and see how the Brooks and Corey moisture factor differs from the van Genuchten moisture factor by changing the hydraulics model passed:","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"T = FT(0.0)\nθ_i = FT(0.0)\n\nK_bc =\n    Ksat .*\n    hydraulic_conductivity.(\n        Ref(impedance_choice),\n        Ref(viscosity_choice),\n        Ref(moisture_choice),\n        Ref(hydraulics_bc),\n        Ref(θ_i),\n        Ref(ν),\n        Ref(T),\n        S_l,\n    )\nplot(\n    S_l,\n    log10.(K),\n    xlabel = \"effective saturation\",\n    ylabel = \"Log10(K)\",\n    label = \"van Genuchten\",\n)\nplot!(\n    S_l,\n    log10.(K_bc),\n    xlabel = \"effective saturation\",\n    ylabel = \"Log10(K)\",\n    label = \"Brooks and Corey\",\n)\nsavefig(\"bc_vg_k.png\")","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"(Image: )","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/#Other-features","page":"Hydraulic Functions","title":"Other features","text":"","category":"section"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"The user also has the choice of making the conductivity constant by choosing MoistureIndependent{FT}() along with ConstantViscosity{FT}() and NoImpedance{FT}() . This is useful for debugging!","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"no_moisture_dependence = MoistureIndependent{FT}()\nK_constant =\n    Ksat .*\n    hydraulic_conductivity.(\n        Ref(impedance_choice),\n        Ref(viscosity_choice),\n        Ref(no_moisture_dependence),\n        Ref(hydraulics),\n        Ref(θ_i),\n        Ref(ν),\n        Ref(T),\n        S_l,\n    );\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"julia> unique(K_constant)\n1-element Array{Float32,1}:\n 1.2277777f-5","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"Note that choosing this option does not mean the matric potential is constant, as a hydraulics model is still required and employed.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"And, lastly, you might be wondering why we left Ksat out of the function for hydraulic_conductivity. It turns out it is also useful for debugging to be able to turn off the diffusion of water, by setting Ksat = 0.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/#References","page":"Hydraulic Functions","title":"References","text":"","category":"section"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"[1] van Genuchten, M. T. (1980), A closed-form equation for predicting the hydraulic conductivity of unsaturated soils, Soil Sci. Soc. Amer. J., pp. 892–898.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"[2] Brooks, R. J., and A. T. Corey (1964), Hydraulic properties of porous media.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"[3] Corey, A. T. (1977), Mechanics of Heterogeneous Fluids in Porous Media, Water Resources Publication, Fort Collins, CO.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"[4] Bonan, G. (2019), Climate Change and Terrestrial Ecoystem Modeling, Cambridge Univ. Press, Cambridge, UK, and New York, NY, USA. Chapter 8, Page 120","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"[5] Lundin, L.-C. (1990), Hydraulic properties in an operational model of frozen soil, J. Hydrol., 118, 289–310.","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"","category":"page"},{"location":"generated/Land/Soil/Water/hydraulic_functions/","page":"Hydraulic Functions","title":"Hydraulic Functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/agnesi_hs_lin.jl\"","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/#EX-LIN_HS-docs","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear HS mountain waves (Topography)","text":"","category":"section"},{"location":"generated/Atmos/agnesi_hs_lin/#Description-of-experiment","page":"Linear Hydrostatic Mountain (Topography)","title":"Description of experiment","text":"","category":"section"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"Dry linear Hydrostatic Mountain Waves","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"The atmosphere is dry and the flow impinges against a witch of Agnesi mountain of heigh h_m=1m and base parameter a=10000m and centered on x_c = 120km in a 2D domain Omega = 240km times 50km. The mountain is defined as","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"z = frach_m1 + fracx - x_ca","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"The 2D problem is setup in 3D by using 1 element in the y direction. To damp the upward moving gravity waves, a Reyleigh absorbing layer is added at z = 15000 m.","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"The initial atmosphere is defined such that it has a stability frequency N=gsqrtc_p T_0, where","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"T_0 = 250 K","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"so that","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"theta = theta_0 = T_0","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"pi = 1 + fracg^2c_p theta_0 N^2left(expleft(frac-N^2 zg right)right)","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"where theta_0 = T_0 K.","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"so that","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"ρ = fracp_sfcR_gasthetapi^c_vR_gas","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"and","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"T = theta pi","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"Boundaries\nImpenetrable(FreeSlip()) - Top and bottom: no momentum flux, no mass flux through walls.\nImpermeable() - non-porous walls, i.e. no diffusive fluxes through  walls.\nAgnesi topography built via meshwarp.\nLaterally periodic\nDomain - 240,000 m (horizontal) x 4000 m (horizontal) x 30,000m (vertical)\nResolution - 1000m X 240 m effective resolution\nTotal simulation time - 15,000 s\nOverrides defaults for\nCPU Initialisation\nTime integrator\nSources","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"note: Note\nThis experiment setup assumes that you have installed the ClimateMachine according to the instructions on the landing page. We assume the users' familiarity with the conservative form of the equations of motion for a compressible fluid (see the AtmosModel page).The following topics are covered in this exampleDefining the initial conditions\nApplying source terms\nAdd an idealized topography defined by a warping function","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/#Boilerplate-(Using-Modules)","page":"Linear Hydrostatic Mountain (Topography)","title":"Boilerplate (Using Modules)","text":"","category":"section"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"The setup of this problem is taken from Case 6 of: @article{giraldoRestelli2008a,   author = {{Giraldo},F.~X. and {Restelli},M.},   title = {A study of spectral element and discontinuous {G}alerkin methods for the {Navier-Stokes} equations in nonhydrostatic mesoscale atmospheric modeling: {E}quation sets and test cases},   journal = {J. Comput. Phys.},   year  = {2008},   volume = {227},   pages  = {3849-3877}, },","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"using ClimateMachine\nClimateMachine.init(parse_clargs = true)","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"Setting parse_clargs=true allows the use of command-line arguments (see API > Driver docs) to control simulation update and output intervals.","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"using ClimateMachine.Atmos\nusing ClimateMachine.Orientations\nusing ClimateMachine.ConfigTypes\nusing ClimateMachine.Diagnostics\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.Mesh.Filters\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.TemperatureProfiles\nusing ClimateMachine.Thermodynamics\nusing ClimateMachine.TurbulenceClosures\nusing ClimateMachine.VariableTemplates\nusing StaticArrays\nusing Test\n\nusing CLIMAParameters\nusing CLIMAParameters.Atmos.SubgridScale: C_smag\nusing CLIMAParameters.Planet: R_d, cp_d, cv_d, MSLP, grav\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/#init","page":"Linear Hydrostatic Mountain (Topography)","title":"Initial Conditions","text":"","category":"section"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"note: Note\nThe following variables are assigned in the initial conditionstate.ρ = Scalar quantity for initial density profile\nstate.ρu= 3-component vector for initial momentum profile\nstate.ρe= Scalar quantity for initial total-energy profile humidity","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"function init_agnesi_hs_lin!(problem, bl, state, aux, localgeo, t)\n    (x, y, z) = localgeo.coord\n\n    # Problem float-type\n    FT = eltype(state)\n\n    # Unpack constant parameters\n    R_gas::FT = R_d(bl.param_set)\n    c_p::FT = cp_d(bl.param_set)\n    c_v::FT = cv_d(bl.param_set)\n    p0::FT = MSLP(bl.param_set)\n    _grav::FT = grav(bl.param_set)\n    γ::FT = c_p / c_v\n\n    c::FT = c_v / R_gas\n    c2::FT = R_gas / c_p\n\n    Tiso::FT = 250.0\n    θ0::FT = Tiso\n\n    # Calculate the Brunt-Vaisaila frequency for an isothermal field\n    Brunt::FT = _grav / sqrt(c_p * Tiso)\n    Brunt2::FT = Brunt * Brunt\n    g2::FT = _grav * _grav\n\n    π_exner::FT = exp(-_grav * z / (c_p * Tiso))\n    θ::FT = θ0 * exp(Brunt2 * z / _grav)\n    ρ::FT = p0 / (R_gas * θ) * (π_exner)^c\n\n    # Compute perturbed thermodynamic state:\n    T = θ * π_exner\n    e_int = internal_energy(bl.param_set, T)\n    ts = PhaseDry(bl.param_set, e_int, ρ)\n\n    # initial velocity\n    u = FT(20.0)\n\n    # State (prognostic) variable assignment\n    e_kin = FT(0)                                       # kinetic energy\n    e_pot = gravitational_potential(bl.orientation, aux)# potential energy\n    ρe_tot = ρ * total_energy(e_kin, e_pot, ts)         # total energy\n\n    state.ρ = ρ\n    state.ρu = SVector{3, FT}(ρ * u, 0, 0)\n    state.ρe = ρe_tot\nend","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"Define a setmax method","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"function setmax(f, xmax, ymax, zmax)\n    function setmaxima(xin, yin, zin)\n        return f(xin, yin, zin; xmax = xmax, ymax = ymax, zmax = zmax)\n    end\n    return setmaxima\nend","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"Define a warping function to build an analytic topography:","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"function warp_agnesi(xin, yin, zin; xmax = 1000.0, ymax = 1000.0, zmax = 1000.0)\n\n    FT = eltype(xin)\n\n    ac = FT(10000)\n    hm = FT(1)\n    xc = FT(0.5) * xmax\n    zdiff = hm / (FT(1) + ((xin - xc) / ac)^2)\n\n    # Linear relaxation towards domain maximum height\n    x, y, z = xin, yin, zin + zdiff * (zmax - zin) / zmax\n    return x, y, z\nend","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/#config-helper","page":"Linear Hydrostatic Mountain (Topography)","title":"Model Configuration","text":"","category":"section"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"We define a configuration function to assist in prescribing the physical model. The purpose of this is to populate the AtmosLESConfiguration with arguments appropriate to the problem being considered.","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"function config_agnesi_hs_lin(FT, N, resolution, xmax, ymax, zmax)\n    #\n    # Explicit Rayleigh damping:\n    #\n    # ``\n    #   \\tau_s = \\alpha * \\sin\\left(0.5\\pi \\frac{z - z_s}{zmax - z_s} \\right)^2,\n    # ``\n    # where\n    # ``sponge_ampz`` is the wave damping coefficient (1/s)\n    # ``z_s`` is the level where the Rayleigh sponge starts\n    # ``zmax`` is the domain top\n    #\n    # Setup the parameters for the gravity wave absorbing layer\n    # at the top of the domain\n    #\n    # u_relaxation(xvelo, vvelo, wvelo) contains the background velocity values to which\n    # the sponge relaxes the vertically moving wave\n    u_relaxation = SVector(FT(20), FT(0), FT(0))\n\n    # Wave damping coefficient (1/s)\n    sponge_ampz = FT(0.5)\n\n    # Vertical level where the absorbing layer starts\n    z_s = FT(25000.0)\n\n    # Pass the sponge parameters to the sponge calculator\n    rayleigh_sponge =\n        RayleighSponge{FT}(zmax, z_s, sponge_ampz, u_relaxation, 2)\n\n    # Define the time integrator:\n    # We chose an explicit single-rate LSRK144 for this problem\n    ode_solver = ClimateMachine.ExplicitSolverType(\n        solver_method = LSRK144NiegemannDiehlBusch,\n    )\n\n    # Setup the source terms for this problem:\n    source = (Gravity(), rayleigh_sponge)\n\n    # Define the reference state:\n    T_virt = FT(250)\n    temp_profile_ref = IsothermalProfile(param_set, T_virt)\n    ref_state = HydrostaticState(temp_profile_ref)\n    nothing # hide\n\n    _C_smag = FT(0.21)\n    model = AtmosModel{FT}(\n        AtmosLESConfigType,\n        param_set;\n        init_state_prognostic = init_agnesi_hs_lin!,\n        ref_state = ref_state,\n        turbulence = Vreman(_C_smag),\n        moisture = DryModel(),\n        source = source,\n        tracers = NoTracers(),\n    )\n\n    config = ClimateMachine.AtmosLESConfiguration(\n        \"Agnesi_HS_LINEAR\",      # Problem title [String]\n        N,                       # Polynomial order [Int]\n        resolution,              # (Δx, Δy, Δz) effective resolution [m]\n        xmax,                    # Domain maximum size [m]\n        ymax,                    # Domain maximum size [m]\n        zmax,                    # Domain maximum size [m]\n        param_set,               # Parameter set.\n        init_agnesi_hs_lin!,     # Function specifying initial condition\n        solver_type = ode_solver,# Time-integrator type\n        model = model,           # Model type\n        meshwarp = setmax(warp_agnesi, xmax, ymax, zmax),\n    )\n\n    return config\nend","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"Define a main method (entry point)","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"function main()\n\n    FT = Float64\n\n    # Define the polynomial order and effective grid spacings:\n    N = 4\n\n    # Define the domain size and spatial resolution\n    Nx = 20\n    Ny = 20\n    Nz = 20\n    xmax = FT(244000)\n    ymax = FT(4000)\n    zmax = FT(50000)\n    Δx = xmax / FT(Nx)\n    Δy = ymax / FT(Ny)\n    Δz = zmax / FT(Nz)\n    resolution = (Δx, Δy, Δz)\n\n    t0 = FT(0)\n    timeend = FT(150) #FT(hrs * 60 * 60)\n\n    # Define the max Courant for the time time integrator (ode_solver).\n    # The default value is 1.7 for LSRK144:\n    CFL = FT(1.5)\n\n    # Assign configurations so they can be passed to the `invoke!` function\n    driver_config = config_agnesi_hs_lin(FT, N, resolution, xmax, ymax, zmax)\n    solver_config = ClimateMachine.SolverConfiguration(\n        t0,\n        timeend,\n        driver_config,\n        init_on_cpu = true,\n        Courant_number = CFL,\n    )\n\n    # Set up the spectral filter to remove the solutions spurious modes\n    # Define the order of the exponential filter: use 32 or 64 for this problem.\n    # The larger the value, the less dissipation you get:\n    filterorder = 64\n    filter = ExponentialFilter(solver_config.dg.grid, 0, filterorder)\n    cbfilter = GenericCallbacks.EveryXSimulationSteps(1) do\n        Filters.apply!(\n            solver_config.Q,\n            AtmosFilterPerturbations(driver_config.bl),\n            solver_config.dg.grid,\n            filter,\n            state_auxiliary = solver_config.dg.state_auxiliary,\n        )\n        nothing\n    end\n    # End exponential filter\n\n    # Invoke solver (calls `solve!` function for time-integrator),\n    # pass the driver, solver and diagnostic config information.\n    result = ClimateMachine.invoke!(\n        solver_config;\n        user_callbacks = (cbfilter,),\n        check_euclidean_distance = true,\n    )\n\n    # Check that the solution norm is reasonable.\n    @test isapprox(result, FT(1); atol = 1.5e-3)\nend","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"Call main","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"main()","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"","category":"page"},{"location":"generated/Atmos/agnesi_hs_lin/","page":"Linear Hydrostatic Mountain (Topography)","title":"Linear Hydrostatic Mountain (Topography)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Land/Soil/Heat/bonan_heat_tutorial.jl\"","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Solving-the-heat-equation-in-soil","page":"Soil Heat Equation","title":"Solving the heat equation in soil","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"This tutorial shows how to use CliMA code to solve the heat equation in soil. For background on the heat equation in general, and how to solve it using CliMA code, please see the heat_equation.jl tutorial.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The version of the heat equation we are solving here assumes no sources or sinks and no diffusion of liquid water. It takes the form","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"frac ρe_int t =    κ(θ_l θ_i ν ) T","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Here","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"t is the time (s),","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"z is the location in the vertical (m),","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ρe_int is the volumetric internal energy of the soil (J/m^3),","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"T is the temperature of the soil (K),","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"κ is the thermal conductivity (W/m/K),","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ϑ_l is the augmented volumetric liquid water fraction,","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"θ_i is the volumetric ice fraction, and","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ν  denotes parameters relating to soil type, such as porosity.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"We will solve this equation in an effectively 1-d domain with z  -10, and with the following boundary and initial conditions:","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"T(t=0 z) = 27715^circ K","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"T(t z = 0) = 28815^circ K","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"-κ T(t z = -1) = 0 z","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The temperature T and volumetric internal energy ρe_int are related as","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ρe_int = ρc_s (θ_l θ_i ν ) (T - T_0) - θ_i ρ_i LH_f0","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"where","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ρc_s is the volumetric heat capacity of the soil (J/m^3/K),","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"T_0 is the freezing temperature of water,","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ρ_i is the density of ice (kg/m^3), and","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"LH_f0 is the latent heat of fusion at T_0.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"In this tutorial, we will use a PrescribedWaterModel. This option allows the user to specify a function for the spatial and temporal behavior of θ_i and θ_l; it does not solve Richard's equation for the evolution of moisture. Please see the tutorials in the Soil/Coupled/ folder or the Soil/Water/ folder for information on solving Richard's equation, either coupled or uncoupled from the heat equation, respectively.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Import-necessary-modules","page":"Soil Heat Equation","title":"Import necessary modules","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"External (non - CliMA) modules","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"using MPI\nusing OrderedCollections\nusing StaticArrays\nusing Statistics\nusing Dierckx\nusing Plots\nusing DelimitedFiles","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"CliMA Parameters","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"using CLIMAParameters\nusing CLIMAParameters.Planet: ρ_cloud_liq, ρ_cloud_ice, cp_l, cp_i, T_0, LH_f0","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ClimateMachine modules","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"using ClimateMachine\nusing ClimateMachine.Land\nusing ClimateMachine.Land.SoilWaterParameterizations\nusing ClimateMachine.Land.SoilHeatParameterizations\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.DGMethods\nusing ClimateMachine.DGMethods.NumericalFluxes\nusing ClimateMachine.DGMethods: BalanceLaw, LocalGeometry\nusing ClimateMachine.MPIStateArrays\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.VariableTemplates\nusing ClimateMachine.SingleStackUtils\nusing ClimateMachine.BalanceLaws:\n    BalanceLaw, Prognostic, Auxiliary, Gradient, GradientFlux, vars_state\nimport ClimateMachine.DGMethods: calculate_dt\nusing ClimateMachine.ArtifactWrappers","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Preliminary-set-up","page":"Soil Heat Equation","title":"Preliminary set-up","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Get the parameter set, which holds constants used across CliMA models.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"struct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet();\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Initialize and pick a floating point precision.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ClimateMachine.init()\nFT = Float32;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Load a function that will create an interpolation of the simulation output, to be used in plotting:","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"const clima_dir = dirname(dirname(pathof(ClimateMachine)));\ninclude(joinpath(\n    clima_dir,\n    \"tutorials\",\n    \"Land\",\n    \"Soil\",\n    \"interpolation_helper.jl\",\n));\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Determine-soil-parameters","page":"Soil Heat Equation","title":"Determine soil parameters","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Below are the soil component fractions for various soil texture classes,  from Cosby et al. (1984) [1, 5]. Note that these fractions are volumetric fractions, relative to other soil solids, i.e. not including pore space. These are denoted ν_ss_i; the CliMA Land Documentation uses the symbol ν_i to denote the volumetric fraction of a soil component i relative to the soil, including pore space.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ν_ss_silt_array =\n    FT.(\n        [5.0, 12.0, 32.0, 70.0, 39.0, 15.0, 56.0, 34.0, 6.0, 47.0, 20.0] ./\n        100.0,\n    )\nν_ss_quartz_array =\n    FT.(\n        [92.0, 82.0, 58.0, 17.0, 43.0, 58.0, 10.0, 32.0, 52.0, 6.0, 22.0] ./\n        100.0,\n    )\nν_ss_clay_array =\n    FT.(\n        [3.0, 6.0, 10.0, 13.0, 18.0, 27.0, 34.0, 34.0, 42.0, 47.0, 58.0] ./\n        100.0,\n    )\nporosity_array =\n    FT.([\n        0.395,\n        0.410,\n        0.435,\n        0.485,\n        0.451,\n        0.420,\n        0.477,\n        0.476,\n        0.426,\n        0.492,\n        0.482,\n    ]);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The soil types that correspond to array elements above are, in order, sand, loamy sand, sandy loam, silty loam, loam, sandy clay loam, silty clay loam, clay loam, sandy clay, silty clay, and clay.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Here we choose the soil type to be sandy. The soil column is uniform in space and time.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"soil_type_index = 1\nν_ss_minerals =\n    ν_ss_clay_array[soil_type_index] + ν_ss_silt_array[soil_type_index]\nν_ss_quartz = ν_ss_quartz_array[soil_type_index]\nporosity = porosity_array[soil_type_index];\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"This tutorial additionally compares the output of a ClimateMachine simulation with that of Supplemental Program 2, Chapter 5, of Bonan (2019) [1].  We found this useful as it allows us compare results from our code against a published version.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The simulation code of [1] employs a formalism for the thermal conductivity κ based on Johansen, 1975, [2]. It assumes no organic matter, and only requires the volumetric fraction of soil solids for quartz and other minerals. ClimateMachine employs the formalism of Balland and Arp (2005)[3], which requires the fraction of soil solids for quartz, gravel, organic matter, and other minerals. Dai (2019)[4] found model [3] to better match measured soil properties across a range of soil types.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"To compare the output of the two simulations, we set the organic matter content and gravel content to zero in the CliMA model. The remaining soil components (quartz and other minerals) match between the two. We also run the simulation for relatively wet soil (water content at 80% of porosity). Under these conditions, the two formulations for κ, though taking different functional forms, are relatively consistent. The differences between models are important for soil with organic material and for soil that is relatively dry.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ν_ss_om = FT(0.0)\nν_ss_gravel = FT(0.0);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"We next calculate a few intermediate quantities needed for the determination of the thermal conductivity [3]. These include the conductivity of the solid material, the conductivity of saturated soil, and the conductivity of frozen saturated soil.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"κ_quartz = FT(7.7) # W/m/K\nκ_minerals = FT(2.5) # W/m/K\nκ_om = FT(0.25) # W/m/K\nκ_liq = FT(0.57) # W/m/K\nκ_ice = FT(2.29); # W/m/K\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The particle density of soil solids in moisture-free soil is taken as a constant, across soil types, as in [1]. This is a good estimate for organic material free soil. The user is referred to [3] for a more general expression.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ρp = FT(2700) # kg/m^3\nκ_solid = k_solid(ν_ss_om, ν_ss_quartz, κ_quartz, κ_minerals, κ_om)\nκ_sat_frozen = ksat_frozen(κ_solid, porosity, κ_ice)\nκ_sat_unfrozen = ksat_unfrozen(κ_solid, porosity, κ_liq);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The thermal conductivity of dry soil is also required, but this is calculated internally using the expression of [3].","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The volumetric specific heat of dry soil is chosen so as to match Bonan's simulation. The user could instead compute this using a volumetric fraction weighted average across soil components.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ρc_ds = FT((1 - porosity) * 1.926e06) # J/m^3/K","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Finally, we store the soil-specific parameters and functions in a place where they will be accessible to the model during integration.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"soil_param_functions = SoilParamFunctions{FT}(\n    porosity = porosity,\n    ν_ss_gravel = ν_ss_gravel,\n    ν_ss_om = ν_ss_om,\n    ν_ss_quartz = ν_ss_quartz,\n    ρc_ds = ρc_ds,\n    ρp = ρp,\n    κ_solid = κ_solid,\n    κ_sat_unfrozen = κ_sat_unfrozen,\n    κ_sat_frozen = κ_sat_frozen,\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Initial-and-Boundary-conditions","page":"Soil Heat Equation","title":"Initial and Boundary conditions","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"We will be using a PrescribedWaterModel, where the user supplies the augmented liquid fraction and ice fraction as functions of space and time. Since we are not implementing phase changes, it makes sense to either have entirely liquid or frozen water. This tutorial shows liquid water.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Because the two models for thermal conductivity agree well for wetter soil, we'll choose that here. However, the user could also explore how they differ by choosing drier soil.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Please note that if the user uses a mix of liquid and frozen water, that they must ensure that the total water content does not exceed porosity.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"prescribed_augmented_liquid_fraction = FT(porosity * 0.8)\nprescribed_volumetric_ice_fraction = FT(0.0);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Choose boundary and initial conditions for heat that will not lead to freezing of water:","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"heat_surface_state = (aux, t) -> eltype(aux)(288.15)\nheat_bottom_flux = (aux, t) -> eltype(aux)(0.0)\nT_init = (aux) -> eltype(aux)(275.15);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"We also need to define a function init_soil!, which initializes all of the prognostic variables (here, we only have ρe_int, the volumetric internal energy). The initialization is based on user-specified initial conditions. Note that the user provides initial conditions for heat based on the temperature - init_soil! also converts between T and ρe_int.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"function init_soil!(land, state, aux, localgeo, time)\n    ϑ_l, θ_i = get_water_content(land.soil.water, aux, state, time)\n    θ_l = volumetric_liquid_fraction(ϑ_l, land.soil.param_functions.porosity)\n    ρc_ds = land.soil.param_functions.ρc_ds\n    ρc_s = volumetric_heat_capacity(θ_l, θ_i, ρc_ds, land.param_set)\n\n    state.soil.heat.ρe_int = volumetric_internal_energy(\n        θ_i,\n        ρc_s,\n        land.soil.heat.initialT(aux),\n        land.param_set,\n    )\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Create-the-model-structure","page":"Soil Heat Equation","title":"Create the model structure","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"soil_water_model = PrescribedWaterModel(\n    (aux, t) -> prescribed_augmented_liquid_fraction,\n    (aux, t) -> prescribed_volumetric_ice_fraction,\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The boundary value problem in this case, with two spatial derivatives, requires a boundary condition at the top of the domain and the bottom. This gives four possible combinations of boundary conditions - top Dirichlet and bottom either Neumann or Dirichlet, or top Neumann and bottom either Dirichlet or Neumann. The user should set the unused fields to nothing to indicate that they do not want to supply a boundary condition of that type. For example, below we indicate that we are applying (and supplying!) a Dirichlet condition at the top of the domain, and a Neumann condition at the bottom.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"soil_heat_model = SoilHeatModel(\n    FT;\n    initialT = T_init,\n    dirichlet_bc = Dirichlet(\n        surface_state = heat_surface_state,\n        bottom_state = nothing,\n    ),\n    neumann_bc = Neumann(\n        surface_flux = nothing,\n        bottom_flux = heat_bottom_flux,\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The full soil model requires a heat model and a water model, as well as the soil parameter functions:","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"m_soil = SoilModel(soil_param_functions, soil_water_model, soil_heat_model);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The equations being solved in this tutorial have no sources or sinks:","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"sources = ();\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Finally, we create the LandModel. In more complex land models, this would include the canopy, carbon state of the soil, etc.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"m = LandModel(\n    param_set,\n    m_soil;\n    source = sources,\n    init_state_prognostic = init_soil!,\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Specify-the-numerical-details","page":"Soil Heat Equation","title":"Specify the numerical details","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"These include the resolution, domain boundaries, integration time, Courant number, and ODE solver.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"N_poly = 1\nnelem_vert = 100\n\nzmax = FT(0)\nzmin = FT(-1)\n\ndriver_config = ClimateMachine.SingleStackConfiguration(\n    \"LandModel\",\n    N_poly,\n    nelem_vert,\n    zmax,\n    param_set,\n    m;\n    zmin = zmin,\n    numerical_flux_first_order = CentralNumericalFluxFirstOrder(),\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"In this tutorial, we determine a timestep based on a Courant number ( also called a Fourier number in the context of the heat equation). In short, we can use the parameters of the model (κ and ρc_s), along with with the size of elements of the grid used for discretizing the PDE, to estimate a natural timescale for heat transfer across a grid cell. Because we are using an explicit ODE solver, the timestep should be a fraction of this in order to resolve the dynamics.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"This allows us to automate, to a certain extent, choosing a value for the timestep, even as we switch between soil types.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"function calculate_dt(dg, model::LandModel, Q, Courant_number, t, direction)\n    Δt = one(eltype(Q))\n    CFL = DGMethods.courant(diffusive_courant, dg, model, Q, Δt, t, direction)\n    return Courant_number / CFL\nend\n\nfunction diffusive_courant(\n    m::LandModel,\n    state::Vars,\n    aux::Vars,\n    diffusive::Vars,\n    Δx,\n    Δt,\n    t,\n    direction,\n)\n    soil = m.soil\n    ϑ_l, θ_i = get_water_content(soil.water, aux, state, t)\n    θ_l = volumetric_liquid_fraction(ϑ_l, soil.param_functions.porosity)\n    κ_dry = k_dry(m.param_set, soil.param_functions)\n    S_r = relative_saturation(θ_l, θ_i, soil.param_functions.porosity)\n    kersten = kersten_number(θ_i, S_r, soil.param_functions)\n    κ_sat = saturated_thermal_conductivity(\n        θ_l,\n        θ_i,\n        soil.param_functions.κ_sat_unfrozen,\n        soil.param_functions.κ_sat_frozen,\n    )\n    κ = thermal_conductivity(κ_dry, kersten, κ_sat)\n    ρc_ds = soil.param_functions.ρc_ds\n    ρc_s = volumetric_heat_capacity(θ_l, θ_i, ρc_ds, m.param_set)\n    return Δt * κ / (Δx * Δx * ρc_ds)\nend\n\n\nt0 = FT(0)\ntimeend = FT(60 * 60 * 3)\nCourant_number = FT(0.5) # much bigger than this leads to domain errors\n\nsolver_config = ClimateMachine.SolverConfiguration(\n    t0,\n    timeend,\n    driver_config;\n    Courant_number = Courant_number,\n    CFL_direction = VerticalDirection(),\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Run-the-integration","page":"Soil Heat Equation","title":"Run the integration","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"ClimateMachine.invoke!(solver_config);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#Plot-results-and-comparison-data-from-[1]","page":"Soil Heat Equation","title":"Plot results and comparison data from [1]","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"We can pull out the z and T values on the DG grid, but these will be multi-valued at boundaries. We'll create an additional cartesian grid , create an interpolation of the DG output, and evaluate on this second grid. T and z are stored in aux:","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"aux = solver_config.dg.state_auxiliary;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Specify interpolation grid:","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"zres = FT(0.02)\nboundaries = [\n    FT(0) FT(0) zmin\n    FT(1) FT(1) zmax\n]\nresolution = (FT(2), FT(2), zres)\nthegrid = solver_config.dg.grid\nintrp_brck = create_interpolation_grid(boundaries, resolution, thegrid);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"Smooth output, and look at T vs z:","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"iaux = interpolate_variables([(aux)], intrp_brck)\niaux = iaux[1]\nz_ind = varsindex(vars_state(m, Auxiliary(), FT), :z)\niz = Array(iaux[:, z_ind, :][:])\nz = Array(aux[:, z_ind, :][:])\nT_ind = varsindex(vars_state(m, Auxiliary(), FT), :soil, :heat, :T)\niT = Array(iaux[:, T_ind, :][:])\n\nplot(\n    iT,\n    iz,\n    label = \"ClimateMachine\",\n    ylabel = \"z (m)\",\n    xlabel = \"T (K)\",\n    title = \"Heat transfer in sand\",\n)\nplot!(T_init.(z), z, label = \"Initial condition\")\nfilename = \"bonan_heat_data.csv\"\nconst clima_dir = dirname(dirname(pathof(ClimateMachine)));\nbonan_dataset = ArtifactWrapper(\n    joinpath(clima_dir, \"tutorials\", \"Land\", \"Soil\", \"Artifacts.toml\"),\n    \"bonan_soil_heat\",\n    ArtifactFile[ArtifactFile(\n        url = \"https://caltech.box.com/shared/static/99vm8q8tlyoulext6c35lnd3355tx6bu.csv\",\n        filename = filename,\n    ),],\n)\nbonan_dataset_path = get_data_folder(bonan_dataset)\ndata = joinpath(bonan_dataset_path, filename)\nds_bonan = readdlm(data, ',')\nbonan_T = reverse(ds_bonan[:, 2])\nbonan_z = reverse(ds_bonan[:, 1])\nbonan_T_continuous = Spline1D(bonan_z, bonan_T)\nbonan_at_clima_z = bonan_T_continuous.(z)\nplot!(bonan_at_clima_z, z, label = \"Bonan simulation\")\nplot!(legend = :bottomleft)\nsavefig(\"thermal_conductivity_comparison.png\")","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"(Image: )","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"The plot shows that the temperature at the top of the soil is gradually increasing. This is because the surface temperature is held fixed at a value larger than the initial temperature. If we ran this for longer, we would see that the bottom of the domain would also increase in temperature because there is no heat leaving the bottom (due to zero heat flux specified in the boundary condition).","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/#References","page":"Soil Heat Equation","title":"References","text":"","category":"section"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"[1] Bonan, G. Climate Change and Terrestrial Ecosystem Modeling (2019), Cambridge University Press","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"[2] Johansen, O. 1975. Thermal conductivity of soils. Ph.D. thesis, Trondheim, Norway. Cold Regions Research and Engineering Laboratory Draft Translation 637, 1977, ADA 044002.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"[3] Balland, V., and P. A. Arp (2005), Modeling soil thermal conductivities over a wide range of conditions, J. Env. Eng. Sci., 4, 549–558.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"[4] Dai, Y., N. W. amd Hua Yuan, S. Zhang, W. Shangguan, S. Liu, X. Lu, and Y. Xin (2019a), Evaluation of soil thermal conductivity schemes for use in land surface modeling, J. Adv. Model. Earth Sys., 11, 3454–3473.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"[5] Cosby, B. J., Hornberger, G. M., Clapp, R. B., and Ginn, T. R. (1984). A statistical exploration of the relationships of soil moisture characteristics to the physical properties of soils. Water Resources Research, 20, 682–690.","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"","category":"page"},{"location":"generated/Land/Soil/Heat/bonan_heat_tutorial/","page":"Soil Heat Equation","title":"Soil Heat Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/heldsuarez.jl\"","category":"page"},{"location":"generated/Atmos/heldsuarez/#Dry-atmosphere-GCM-with-Held-Suarez-forcing","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry atmosphere GCM with Held-Suarez forcing","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"The Held-Suarez setup (Held and Suarez, 1994) is a textbook example for a simplified atmospheric global circulation model configuration which has been used as a benchmark experiment for development of the dynamical cores (i.e., GCMs without continents, moisture or parametrization schemes of the physics) for atmospheric models.  It is forced by a thermal relaxation to a reference state and damped by linear (Rayleigh) friction. This example demonstrates how","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"to set up a ClimateMachine-Atmos GCM configuration;\nto select and save GCM diagnostics output.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"To begin, we load ClimateMachine and a few miscellaneous useful Julia packages.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"using Distributions\nusing Random\nusing StaticArrays","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"ClimateMachine specific modules needed to make this example work (e.g., we will need spectral filters, etc.).","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"using ClimateMachine\nusing ClimateMachine.Atmos\nusing ClimateMachine.Orientations\nusing ClimateMachine.ConfigTypes\nusing ClimateMachine.Diagnostics\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.Mesh.Filters\nusing ClimateMachine.TemperatureProfiles\nusing ClimateMachine.SystemSolvers\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.Thermodynamics\nusing ClimateMachine.TurbulenceClosures\nusing ClimateMachine.VariableTemplates\nimport ClimateMachine.Atmos: atmos_source!","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"ClimateMachine parameters are needed to have access to Earth's physical parameters.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"using CLIMAParameters\nusing CLIMAParameters.Planet: MSLP, R_d, day, grav, cp_d, cv_d, planet_radius","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"We need to load the physical parameters for Earth to have an Earth-like simulation :).","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"struct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet();\n\nstruct HeldSuarezForcingTutorial <: Source end","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"Construct the Held-Suarez forcing function. We can view this as part the right-hand-side of our governing equations. It forces the total energy field in a way that the resulting steady-state velocity and temperature fields of the simulation resemble those of an idealized dry planet.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"function atmos_source!(\n    ::HeldSuarezForcingTutorial,\n    balance_law::AtmosModel,\n    source::Vars,\n    state::Vars,\n    diffusive::Vars,\n    aux::Vars,\n    t::Real,\n    direction,\n)\n    FT = eltype(state)\n\n    # Parameters\n    T_ref::FT = 255 # reference temperature for Held-Suarez forcing (K)\n\n    # Extract the state\n    ρ = state.ρ\n    ρu = state.ρu\n    ρe = state.ρe\n\n    ts = recover_thermo_state(balance_law, state, aux)\n    e_int = internal_energy(ts)\n    T = air_temperature(ts)\n    _R_d = FT(R_d(balance_law.param_set))\n    _day = FT(day(balance_law.param_set))\n    _grav = FT(grav(balance_law.param_set))\n    _cp_d = FT(cp_d(balance_law.param_set))\n    _cv_d = FT(cv_d(balance_law.param_set))\n    _p0 = FT(MSLP(balance_law.param_set))\n\n    # Held-Suarez parameters\n    k_a = FT(1 / (40 * _day))\n    k_f = FT(1 / _day)\n    k_s = FT(1 / (4 * _day))\n    ΔT_y = FT(60)\n    Δθ_z = FT(10)\n    T_equator = FT(315)\n    T_min = FT(200)\n    σ_b = FT(7 / 10)\n\n    # Held-Suarez forcing\n    φ = latitude(balance_law, aux)\n    p = air_pressure(ts)\n\n    #TODO: replace _p0 with dynamic surface pressure in Δσ calculations to account\n    #for topography, but leave unchanged for calculations of σ involved in T_equil\n    σ = p / _p0\n    exner_p = σ^(_R_d / _cp_d)\n    Δσ = (σ - σ_b) / (1 - σ_b)\n    height_factor = max(0, Δσ)\n    T_equil = (T_equator - ΔT_y * sin(φ)^2 - Δθ_z * log(σ) * cos(φ)^2) * exner_p\n    T_equil = max(T_min, T_equil)\n    k_T = k_a + (k_s - k_a) * height_factor * cos(φ)^4\n    k_v = k_f * height_factor\n\n    # Apply Held-Suarez forcing\n    source.ρu -= k_v * projection_tangential(balance_law, aux, ρu)\n    source.ρe -= k_T * ρ * _cv_d * (T - T_equil)\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-initial-condition","page":"Dry Idealized GCM (Held-Suarez)","title":"Set initial condition","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"When using ClimateMachine, we need to define a function that sets the initial state of our model run. In our case, we use the reference state of the simulation (defined below) and add a little bit of noise. Note that the initial states includes a zero initial velocity field.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"function init_heldsuarez!(problem, balance_law, state, aux, localgeo, time)\n    FT = eltype(state)\n\n    # Set initial state to reference state with random perturbation\n    rnd = FT(1 + rand(Uniform(-1e-3, 1e-3)))\n    state.ρ = aux.ref_state.ρ\n    state.ρu = SVector{3, FT}(0, 0, 0)\n    state.ρe = rnd * aux.ref_state.ρe\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Initialize-ClimateMachine","page":"Dry Idealized GCM (Held-Suarez)","title":"Initialize ClimateMachine","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"Before we do anything further, we need to initialize ClimateMachine. Among other things, this will initialize the MPI us.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"ClimateMachine.init();\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Setting-the-floating-type-precision","page":"Dry Idealized GCM (Held-Suarez)","title":"Setting the floating-type precision","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"ClimateMachine allows us to run a model with different floating-type precisions, with lower precision we get our results faster, and with higher precision, we may get more accurate results, depending on the questions we are after.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"FT = Float32;\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Setup-model-configuration","page":"Dry Idealized GCM (Held-Suarez)","title":"Setup model configuration","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"Now that we have defined our forcing and initialization functions, and have initialized ClimateMachine, we can set up the model.","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-a-reference-state","page":"Dry Idealized GCM (Held-Suarez)","title":"Set up a reference state","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"We start by setting up a reference state. This is simply a vector field that we subtract from the solutions to the governing equations to both improve numerical stability of the implicit time stepper and enable faster model spin-up. The reference state assumes hydrostatic balance and ideal gas law, with a pressure p_r(z) and density rho_r(z) that only depend on altitude z and are in hydrostatic balance with each other.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"In this example, the reference temperature field smoothly transitions from a linearly decaying profile near the surface to a constant temperature profile at the top of the domain.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"temp_profile_ref = DecayingTemperatureProfile{FT}(param_set)\nref_state = HydrostaticState(temp_profile_ref);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-a-Rayleigh-sponge-layer","page":"Dry Idealized GCM (Held-Suarez)","title":"Set up a Rayleigh sponge layer","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"To avoid wave reflection at the top of the domain, the model applies a sponge layer that linearly damps the momentum equations.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"domain_height = FT(30e3)               # height of the computational domain (m)\nz_sponge = FT(12e3)                    # height at which sponge begins (m)\nα_relax = FT(1 / 60 / 15)              # sponge relaxation rate (1/s)\nexponent = FT(2)                       # sponge exponent for squared-sinusoid profile\nu_relax = SVector(FT(0), FT(0), FT(0)) # relaxation velocity (m/s)\nsponge = RayleighSponge(domain_height, z_sponge, α_relax, u_relax, exponent);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-turbulence-models","page":"Dry Idealized GCM (Held-Suarez)","title":"Set up turbulence models","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"In order to produce a stable simulation, we need to dissipate energy and enstrophy at the smallest scales of the developed flow field. To achieve this we set up diffusive forcing functions.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"c_smag = FT(0.21);   # Smagorinsky constant\nτ_hyper = FT(4 * 3600); # hyperdiffusion time scale\nturbulence_model = SmagorinskyLilly(c_smag);\nhyperdiffusion_model = DryBiharmonic(FT(4 * 3600));\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Instantiate-the-model","page":"Dry Idealized GCM (Held-Suarez)","title":"Instantiate the model","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"The Held Suarez setup was designed to produce an equilibrated state that is comparable to the zonal mean of the Earth’s atmosphere.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"model = AtmosModel{FT}(\n    AtmosGCMConfigType,\n    param_set;\n    init_state_prognostic = init_heldsuarez!,\n    ref_state = ref_state,\n    turbulence = turbulence_model,\n    hyperdiffusion = hyperdiffusion_model,\n    moisture = DryModel(),\n    source = (Gravity(), Coriolis(), HeldSuarezForcingTutorial(), sponge),\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"This concludes the setup of the physical model!","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-the-driver","page":"Dry Idealized GCM (Held-Suarez)","title":"Set up the driver","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"We just need to set up a few parameters that define the resolution of the discontinuous Galerkin method and for how long we want to run our model setup.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"poly_order = 5;                        ## discontinuous Galerkin polynomial order\nn_horz = 2;                            ## horizontal element number\nn_vert = 2;                            ## vertical element number\nresolution = (n_horz, n_vert)\nn_days = 0.1;                          ## experiment day number\ntimestart = FT(0);                     ## start time (s)\ntimeend = FT(n_days * day(param_set)); ## end time (s);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"The next lines set up the spatial grid.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"driver_config = ClimateMachine.AtmosGCMConfiguration(\n    \"HeldSuarez\",\n    poly_order,\n    resolution,\n    domain_height,\n    param_set,\n    init_heldsuarez!;\n    model = model,\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"The next lines set up the time stepper. Since the resolution in the vertical is much finer than in the horizontal, the 'stiff' parts of the PDE will be in the vertical. Setting splitting_type = HEVISplitting() will treat vertical acoustic waves implicitly, while all other dynamics are treated explicitly.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"ode_solver_type = ClimateMachine.IMEXSolverType(\n    splitting_type = HEVISplitting(),\n    implicit_model = AtmosAcousticGravityLinearModel,\n    implicit_solver = ManyColumnLU,\n    solver_method = ARK2GiraldoKellyConstantinescu,\n);\n\nsolver_config = ClimateMachine.SolverConfiguration(\n    timestart,\n    timeend,\n    driver_config,\n    Courant_number = FT(0.1),\n    ode_solver_type = ode_solver_type,\n    init_on_cpu = true,\n    CFL_direction = HorizontalDirection(),\n    diffdir = HorizontalDirection(),\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-spectral-exponential-filter","page":"Dry Idealized GCM (Held-Suarez)","title":"Set up spectral exponential filter","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"After every completed time step we apply a spectral filter to remove remaining small-scale noise introduced by the numerical procedures. This assures that our run remains stable.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"filterorder = 10;\nfilter = ExponentialFilter(solver_config.dg.grid, 0, filterorder);\ncbfilter = GenericCallbacks.EveryXSimulationSteps(1) do\n    Filters.apply!(\n        solver_config.Q,\n        AtmosFilterPerturbations(model),\n        solver_config.dg.grid,\n        filter,\n        state_auxiliary = solver_config.dg.state_auxiliary,\n    )\n    nothing\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Setup-diagnostic-output","page":"Dry Idealized GCM (Held-Suarez)","title":"Setup diagnostic output","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"Choose frequency and resolution of output, and a diagnostics group (dgngrp) which defines output variables. This needs to be defined in Diagnostics.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"interval = \"1000steps\";\n_planet_radius = FT(planet_radius(param_set));\ninfo = driver_config.config_info;\nboundaries = [\n    FT(-90.0) FT(-180.0) _planet_radius\n    FT(90.0) FT(180.0) FT(_planet_radius + info.domain_height)\n];\nresolution = (FT(10), FT(10), FT(1000)); # in (deg, deg, m)\ninterpol = ClimateMachine.InterpolationConfiguration(\n    driver_config,\n    boundaries,\n    resolution,\n);\n\ndgngrps = [\n    setup_dump_state_diagnostics(\n        AtmosGCMConfigType(),\n        interval,\n        driver_config.name,\n        interpol = interpol,\n    ),\n    setup_dump_aux_diagnostics(\n        AtmosGCMConfigType(),\n        interval,\n        driver_config.name,\n        interpol = interpol,\n    ),\n];\ndgn_config = ClimateMachine.DiagnosticsConfiguration(dgngrps);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Run-the-model","page":"Dry Idealized GCM (Held-Suarez)","title":"Run the model","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"Finally, we can run the model using the physical setup and solvers from above. We use the spectral filter in our callbacks after every time step, and collect the diagnostics output.","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"result = ClimateMachine.invoke!(\n    solver_config;\n    diagnostics_config = dgn_config,\n    user_callbacks = (cbfilter,),\n    check_euclidean_distance = true,\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#References","page":"Dry Idealized GCM (Held-Suarez)","title":"References","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"Held, I.M. and M.J. Suarez, 1994: A Proposal for the Intercomparison","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"the Dynamical Cores of Atmospheric General Circulation Models. Bull. # Amer. Meteor. Soc., 75, 1825–1830, https://doi.org/10.1175/1520-0477(1994)075<1825:APFTIO>2.0.CO;2","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"","category":"page"},{"location":"generated/Atmos/heldsuarez/","page":"Dry Idealized GCM (Held-Suarez)","title":"Dry Idealized GCM (Held-Suarez)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Atmos-Model","page":"AtmosModel","title":"Atmos Model","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"This page provides a summary of a specific type of balance law within the ClimateMachine source code, the AtmosModel. This documentation aims to introduce a user to the properties of the AtmosModel, including the balance law equations and default model configurations. Both LES and GCM configurations are included.","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Conservation-Equations","page":"AtmosModel","title":"Conservation Equations","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"The conservation equations specific to this implementation of AtmosModel are included below.","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Mass","page":"AtmosModel","title":"Mass","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"fracpartial rhopartial t + nablacdot (rhovecu) = rho mathcalhat S_q_t","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Momentum","page":"AtmosModel","title":"Momentum","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"frac(partial rhovecu)partial t + nablacdot left rhovecu otimes vecu + (p - p_r) vecI_3right =\n- (rho - rho_r) nablaPhi - 2vecOmega times rhovecu \n- nablacdot (rho vectau) - nablacdotleft( vecd_q_t otimes rhovecu right) + nablacdot left( q_c w_c vechat k otimes rho vecu right) + rho vecF_vecu","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Energy","page":"AtmosModel","title":"Energy","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":" fracpartial(rho e^mathrmtot)partial t + nablacdot left( (rho e^mathrmtot + p)vecu right)\n = -nablacdot (rho vecF_R) - nablacdot biglrho (vecJ + vecD)bigr + rho Q  \n  +nablacdot left(rho W_c vechat k right)  - nablacdot (vecu cdot rhovectau) + rho vecu cdot vecF_vecu \n   - sum_jinvli(I_j + Phi)  rho C(q_j rightarrow q_p) - M","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Moisture","page":"AtmosModel","title":"Moisture","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"fracpartial (rho q_t)partial t + nablacdot (rho q_t vecu)\n= rho mathcalS_q_t - nablacdot (rho vecd_q_t) + nablacdot bigl(rho q_c w_c vechat k  bigr)\nequiv rho mathcalhat S_q_t","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Precipitating-Species","page":"AtmosModel","title":"Precipitating Species","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"fracpartial (rho q_pi)partial t + nablacdot leftrho q_pi (vecu - w_pi vechat k) right =\nrho leftC(q_t rightarrow q_pi) + C(q_pk rightarrow q_pi) right -nablacdot (rho vecd_q_p i)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Tracer-Species","page":"AtmosModel","title":"Tracer Species","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"frac(partial rho chi_i)partial t + nablacdot left(rho chi_i vecu right) = rho mathcalS_chi_i - nablacdot (rho vecd_chi_i) + nablacdot (rho chi_i w_chi i vechat k)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Equation-Abstractions","page":"AtmosModel","title":"Equation Abstractions","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"fracpartial vecYpartial t = - nabla cdot (vecF_nondiff + vecF_diff + vecF_rad + vecF_precip) + vecS","category":"page"},{"location":"Theory/Atmos/AtmosModel/#State-Variables","page":"AtmosModel","title":"State Variables","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"vecY=left( beginarrayc\nrho \nrhovecu \nrho e^mathrmtot\nrho q_k\nrho q_pi\nrho chi_j\nendarray\nright)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Fluxes","page":"AtmosModel","title":"Fluxes","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#Nondiffusive-Fluxes","page":"AtmosModel","title":"Nondiffusive Fluxes","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":" mathrmF_nondiff=left( beginarrayc\n rho vecu \n rho vecu otimes vecu + (p - p_r) vecI_3 \n rho e^mathrmtot vecu + p vecu\n rho q_k vecu\n rho q_pi vecu \n rho chi_j vecu\nendarray\nright)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Diffusive-Fluxes","page":"AtmosModel","title":"Diffusive Fluxes","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"mathrmF_diff=left( beginarrayc\nrhovecd_q_t \nrhovectau + rhovecd_q_t otimes vecu\nvecu cdot rhovectau + rho (vecJ + vecD) \nrhovecd_q_k\nrho vecd_q_p i\nrho vecd_chi_j\nendarray\nright)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Radiation-Fluxes","page":"AtmosModel","title":"Radiation Fluxes","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"mathrmF_rad =\nleft( beginarrayc\nvec0 \nvec0 \nrho vecF_R \nvec0 \nvec0 \nvec0\nendarray\nright)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Fluxes-of-precipitating-species","page":"AtmosModel","title":"Fluxes of precipitating species","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"mathrmF_fall =\n- left( beginarrayc\nrho q_c w_c vechat k  \nq_c w_c vechat k otimes rho vecu  \nrho W_c vechat k \nrho q_k w_k vechat k  \nrho q_pi w_p i vechat k \nrho chi_i w_chi i vechat k\nendarray right)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Sources","page":"AtmosModel","title":"Sources","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/","page":"AtmosModel","title":"AtmosModel","text":"mathrmS(vecY nablavecY)=\n left( beginarrayc\n -rho C(q_t rightarrow q_p) \n  -(rho - rho_r) nablaPhi - 2 vecOmega times rhovecu  + rho vecF_vecu \n rho Q - sum_jinvli (I_j + Phi)  rho C(q_j rightarrow q_p) - M  + rho vecu cdot vecF_vecu  \nrho C(q_p rightarrow q_k) + rho sum_j rho C(q_j rightarrow q_k) \n    rho sum_k C(q_k rightarrow q_p i) - rho sum_j C(q_p i rightarrow q_p j)\nrho mathcalS_chi_i\nendarray\nright)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Numerics/DGMethods/showcase_filters.jl\"","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/#Filters","page":"Filters","title":"Filters","text":"","category":"section"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"In this tutorial we show the result of applying filters available in the CliMA codebase in a 1 dimensional box advection setup. See Filters API for filters interface details.","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"using ClimateMachine\nconst clima_dir = dirname(dirname(pathof(ClimateMachine)));\ninclude(joinpath(clima_dir, \"tutorials\", \"Numerics\", \"DGMethods\", \"Box1D.jl\"))\n\noutput_dir = @__DIR__;\nmkpath(output_dir);\nnothing #hide","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"The unfiltered result of the box advection test for order 4 polynomial with central flux is","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(4, 0.0, 1.0, 1.0, joinpath(output_dir, \"box_1D_4_no_filter.svg\"))","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"The unfiltered result of the box advection test for order 4 polynomial with Rusanov flux (aka upwinding for advection) is","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_no_filter_upwind.svg\"),\n    numerical_flux_first_order = RusanovNumericalFlux(),\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"Below we show results for the same box advection test but using different filters.","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"As seen in the results, when the TMAR filter is used mass is not necessarily conserved (mass increases are possible).","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"TMARFilter() with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_tmar.svg\");\n    tmar_filter = true,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"Running the TMAR filter with Rusanov the mass conservation since some of the are reduced, but mass is still not conserved. TMARFilter() with Rusanov numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_tmar_upwind.svg\");\n    tmar_filter = true,\n    numerical_flux_first_order = RusanovNumericalFlux(),\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"CutoffFilter(grid, Nc=1) with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_cutoff_1.svg\");\n    cutoff_filter = true,\n    cutoff_param = 1,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"CutoffFilter(grid, Nc=3) with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_cutoff_3.svg\");\n    cutoff_filter = true,\n    cutoff_param = 3,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"ExponentialFilter(grid, Nc=1, s=4) with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_exp_1_4.svg\");\n    exp_filter = true,\n    exp_param_1 = 1,\n    exp_param_2 = 4,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"ExponentialFilter(grid, Nc=1, s=8) with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_exp_1_8.svg\");\n    exp_filter = true,\n    exp_param_1 = 1,\n    exp_param_2 = 8,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"ExponentialFilter(grid, Nc=1, s=32) with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_exp_1_32.svg\");\n    exp_filter = true,\n    exp_param_1 = 1,\n    exp_param_2 = 32,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"BoydVandevenFilter(grid, Nc=1, s=4) with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_boyd_1_4.svg\");\n    boyd_filter = true,\n    boyd_param_1 = 1,\n    boyd_param_2 = 4,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"BoydVandevenFilter(grid, Nc=1, s=8) with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_boyd_1_8.svg\");\n    boyd_filter = true,\n    boyd_param_1 = 1,\n    boyd_param_2 = 8,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"BoydVandevenFilter(grid, Nc=1, s=32) with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_boyd_1_32.svg\");\n    boyd_filter = true,\n    boyd_param_1 = 1,\n    boyd_param_2 = 32,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"ExponentialFilter(grid, Nc=1, s=8) and TMARFilter() with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_tmar_exp_1_8.svg\");\n    exp_filter = true,\n    tmar_filter = true,\n    exp_param_1 = 1,\n    exp_param_2 = 8,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"BoydVandevenFilter(grid, Nc=1, s=8) and TMARFilter() with central numerical flux:","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"run_box1D(\n    4,\n    0.0,\n    1.0,\n    1.0,\n    joinpath(output_dir, \"box_1D_4_tmar_boyd_1_8.svg\");\n    boyd_filter = true,\n    tmar_filter = true,\n    boyd_param_1 = 1,\n    boyd_param_2 = 8,\n)","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"(Image: )","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"","category":"page"},{"location":"generated/Numerics/DGMethods/showcase_filters/","page":"Filters","title":"Filters","text":"This page was generated using Literate.jl.","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/#How-to-make-a-Balance-law","page":"How to make a balance law","title":"How to make a Balance law","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"CurrentModule = ClimateMachine.BalanceLaws","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"Defining the set of solved PDEs in ClimateMachine revolve around defining a BalanceLaw. A balance law solves equations of the form:","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"∂Y\n-- = - ∇ • ( F_{first_order}(Y) + F_{second_order}(Y, Σ) ) + S_{non_conservative}(Y, Σ)\n∂t","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"Here, Y, Σ, F_{first_order}, F_{second_order}, and S_{non_conservative} can be thought of column vectors[1] expressing:","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"Y the prognostic state variables, or unknowns of the PDEs to be solved\nΣ the gradients of functions of the prognostic state variables\nF_{first-order} contains all first-order fluxes (e.g. not functions","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"of gradients of any variables)","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"F_{second-order} contains all second-order and higher-order fluxes","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"(e.g. functions of gradients of any variables)","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"S_{non_conservative} non-conservative sources[2]","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"In order to alleviate users from being concerned with the burden of spatial discretization, users must provide their own implementations of the following methods, which are computed locally at each nodal point:","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/#Variable-name-specification-methods","page":"How to make a balance law","title":"Variable name specification methods","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"The vars_state method is used to specify the names of the variables for the following state variable types:","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"Type Purpose\nPrognostic the variables in the prognostic state vector, typically mass, momentum, and various tracers.\nAuxiliary any variables required for the balance law that aren't related to derivatives of the state variables (e.g. spatial coordinates or various integrals) or those needed to solve expensive auxiliary equations (e.g., temperature via a non-linear equation solve)\nGradient the gradients of functions of the prognostic state variables. used to represent values before and after differentiation\nGradientFlux the gradient fluxes necessary to impose Neumann boundary conditions. typically the product of a diffusivity tensor with a gradient state variable, potentially equivalent to the second-order flux for a prognostic state variable\nUpwardIntegrals any one-dimensional vertical integrals from bottom to top of the domain required for the balance law. used to represent both the integrand and the resulting indefinite integral\nDownwardIntegrals any one-dimensional vertical integral from top to bottom of the domain required for the balance law. each variable here must also exist in vars_state since the reverse integral kernels use subtraction to reverse the integral instead of performing a new integral. use to represent the value before and after reversing direction","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/#Methods-to-compute-gradients-and-integrals","page":"How to make a balance law","title":"Methods to compute gradients and integrals","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"Method Purpose\ncompute_gradient_argument! specify how to compute the arguments to the gradients. can be functions of prognostic state  and auxiliary variables.\ncompute_gradient_flux! specify how to compute gradient fluxes. can be a functions of the gradient state, the prognostic state, and auxiliary variables.\nintegral_load_auxiliary_state! specify how to compute integrands. can be functions of the prognostic state and auxiliary variables.\nintegral_set_auxiliary_state! specify which auxiliary variables are used to store the output of the integrals.\nreverse_integral_load_auxiliary_state! specify auxiliary variables need their integrals reversed.\nreverse_integral_set_auxiliary_state! specify which auxiliary variables are used to store the output of the reversed integrals.\nupdate_auxiliary_state! perform any updates to the auxiliary variables needed at the beginning of each time-step. Can be used to solve non-linear equations, calculate integrals, and apply filters.\nupdate_auxiliary_state_gradient! same as above, but after computing gradients and gradient fluxes in case these variables are needed during the update.","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/#Methods-to-compute-fluxes-and-sources","page":"How to make a balance law","title":"Methods to compute fluxes and sources","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"Method Purpose\nflux_first_order! specify F_{first_order} for each prognostic state variable. can be functions of the prognostic state and auxiliary variables.\nflux_second_order! specify F_{second_order} for each prognostic state variable. can be functions of the prognostic state, gradient flux state, and auxiliary variables.\nsource! specify S_{non_conservative}  for each prognostic state variable. can be functions of the prognostic state, gradient flux state, and auxiliary variables.","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/#Methods-to-compute-numerical-fluxes","page":"How to make a balance law","title":"Methods to compute numerical fluxes","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"Method Purpose\nwavespeed specify how to compute the local wavespeed if using the RusanovNumericalFlux.\nboundary_state! define exterior nodal values of the prognostic state and gradient flux state used to compute the numerical boundary fluxes.","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/#Methods-to-set-initial-conditions","page":"How to make a balance law","title":"Methods to set initial conditions","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"Method Purpose\ninit_state_prognostic! provide initial values for the prognostic state as a function of time and space.\ninit_state_auxiliary! provide initial values for the auxiliary variables as a function of the geometry.","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/#General-Remarks","page":"How to make a balance law","title":"General Remarks","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"While Y can be thought of a column vector (each row of which corresponds to each state variable and its prognostic equation), the second function argument inside these methods behave as dictionaries, for example:","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"struct MyModel <: BalanceLaw end\n\nfunction vars_state(m::MyModel, ::Prognostic, FT)\n    @vars begin\n        ρ::FT\n        T::FT\n    end\nend\n\nfunction source!(m::MyModel, source::Vars, args...)\n    source.ρ = 1 # adds a source of 1 to RHS of ρ equation\n    source.T = 1 # adds a source of 1 to RHS of T equation\nend","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"All equations are marched simultaneously in time.","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/#Reference-links","page":"How to make a balance law","title":"Reference links","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"[1]: Column Vectors","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"[2]: Note that using non-conservative sources should be a final resort,","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"as this can leak conservation of the unknowns and lead to numerical instabilities. It is recommended to use either F_{diffusive} or F_{non_diffusive}, as these fluxes are communicated across elements[3]","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"[3]: MPI communication occurs only across elements, not within each element,","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"where there may be many [Gauss-Lobatto][4] points","category":"page"},{"location":"HowToGuides/Numerics/DGMethods/how_to_make_a_balance_law/","page":"How to make a balance law","title":"How to make a balance law","text":"[4]: Gauss-Lobatto","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#Diagnostics-docs","page":"Diagnostics groups","title":"Diagnostics","text":"","category":"section"},{"location":"APIs/Diagnostics/Diagnostics/","page":"Diagnostics groups","title":"Diagnostics groups","text":"CurrentModule = ClimateMachine.Diagnostics","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/","page":"Diagnostics groups","title":"Diagnostics groups","text":"Diagnostics","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics","text":"Diagnostics\n\nAccumulate mean fields and covariance statistics on the computational grid.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Diagnostics/Diagnostics/#Types","page":"Diagnostics groups","title":"Types","text":"","category":"section"},{"location":"APIs/Diagnostics/Diagnostics/","page":"Diagnostics groups","title":"Diagnostics groups","text":"Diagnostics.DiagnosticsGroup","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.DiagnosticsGroup","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.DiagnosticsGroup","text":"DiagnosticsGroup\n\nHolds a set of diagnostics that share a collection interval, a filename prefix, an output writer, an interpolation, and any extra parameters.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Diagnostics/Diagnostics/#Diagnostics-groups","page":"Diagnostics groups","title":"Diagnostics groups","text":"","category":"section"},{"location":"APIs/Diagnostics/Diagnostics/","page":"Diagnostics groups","title":"Diagnostics groups","text":"A ClimateMachine driver may use any number of the methods described below to create DiagnosticsGroups which must be specified to the ClimateMachine in a DiagnosticsConfiguration.","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/","page":"Diagnostics groups","title":"Diagnostics groups","text":"Diagnostics.setup_atmos_default_diagnostics\nDiagnostics.setup_atmos_core_diagnostics\nDiagnostics.setup_atmos_default_perturbations\nDiagnostics.setup_atmos_refstate_perturbations\nDiagnostics.setup_atmos_turbulence_stats\nDiagnostics.setup_atmos_mass_energy_loss\nDiagnostics.setup_atmos_spectra_diagnostics\nDiagnostics.setup_dump_state_diagnostics\nDiagnostics.setup_dump_aux_diagnostics","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_atmos_default_diagnostics","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_atmos_default_diagnostics","text":"setup_atmos_default_diagnostics(\n    ::AtmosLESConfigType,\n    interval::String,\n    out_prefix::String;\n    writer = NetCDFWriter(),\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing the \"AtmosDefault\" diagnostics for LES configurations. All the diagnostics in the group will run at the specified interval, be interpolated to the specified boundaries and resolution, and will be written to files prefixed by out_prefix using writer.\n\n\n\n\n\nsetup_atmos_default_diagnostics(\n    ::AtmosGCMConfigType,\n    interval::String,\n    out_prefix::String;\n    writer::AbstractWriter,\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing the \"AtmosDefault\" diagnostics for GCM configurations. All the diagnostics in the group will run at the specified interval, be interpolated to the specified boundaries and resolution, and will be written to files prefixed by out_prefix using writer.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_atmos_core_diagnostics","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_atmos_core_diagnostics","text":"setup_atmos_core_diagnostics(\n    ::AtmosLESConfigType,\n    interval::String,\n    out_prefix::String;\n    writer::AbstractWriter,\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing the \"AtmosLESCore\" diagnostics for LES configurations. All the diagnostics in the group will run at the specified interval, be interpolated to the specified boundaries and resolution, and will be written to files prefixed by out_prefix using writer.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_atmos_default_perturbations","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_atmos_default_perturbations","text":"setup_atmos_default_perturbations(\n    ::AtmosLESConfigType,\n    interval::String,\n    out_prefix::String;\n    writer::AbstractWriter,\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing the \"AtmosLESDefaultPerturbations\" diagnostics for the LES configuration. All the diagnostics in the group will run at the specified interval, and written to files prefixed by out_prefix using writer.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_atmos_refstate_perturbations","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_atmos_refstate_perturbations","text":"setup_atmos_refstate_perturbations(\n    ::ClimateMachineConfigType,\n    interval::String,\n    out_prefix::String;\n    writer = NetCDFWriter(),\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing the \"AtmosRefStatePerturbations\" diagnostics for both LES and GCM configurations. All the diagnostics in the group will run at the specified interval, be interpolated to the specified boundaries and resolution, and written to files prefixed by out_prefix using writer.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_atmos_turbulence_stats","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_atmos_turbulence_stats","text":"setup_atmos_turbulence_stats(\n    ::ClimateMachineConfigType,\n    interval::String,\n    out_prefix::String,\n    nor::Float64,\n    iter::Float64;\n    writer = NetCDFWriter(),\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing the \"AtmosTurbulenceStats\" diagnostics for both LES and GCM configurations. All the diagnostics in the group will run at the specified interval, be interpolated to the specified boundaries and resolution, and written to files prefixed by out_prefix using writer.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_atmos_mass_energy_loss","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_atmos_mass_energy_loss","text":"setup_atmos_mass_energy_loss(\n    ::ClimateMachineConfigType,\n    interval::String,\n    out_prefix::String,\n    writer = NetCDFWriter(),\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing the \"AtmosMassEnergyLoss\" diagnostics for Atmos LES and GCM configurations. All the diagnostics in the group will run at the specified interval, be interpolated to the specified boundaries and resolution, and written to files prefixed by out_prefix using writer.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_atmos_spectra_diagnostics","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_atmos_spectra_diagnostics","text":"setup_atmos_spectra_diagnostics(\n    ::AtmosLESConfigType,\n    interval::String,\n    out_prefix::String;\n    writer = NetCDFWriter(),\n    interpol = nothing,\n    nor = Inf,\n)\n\nCreate and return a DiagnosticsGroup containing a diagnostic for Atmos LES configurations that dumps the spectrum at the specified interval after the velocity fields have been interpolated, into NetCDF files prefixed by out_prefix.\n\n\n\n\n\nsetup_atmos_spectra_diagnostics(\n    ::AtmosGCMConfigType,\n    interval::String,\n    out_prefix::String;\n    writer = NetCDFWriter(),\n    interpol = nothing,\n    nor = 1.0,\n)\n\nCreate and return a DiagnosticsGroup containing a diagnostic that dumps the spectrum at the specified interval after the velocity fields have been interpolated, into NetCDF files prefixed by out_prefix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_dump_state_diagnostics","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_dump_state_diagnostics","text":"setup_dump_state_diagnostics(\n    ::ClimateMachineConfigType,\n    interval::String,\n    out_prefix::String;\n    writer = NetCDFWriter(),\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing a diagnostic that simply dumps the conservative state variables at the specified interval after being interpolated, into NetCDF files prefixed by out_prefix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.setup_dump_aux_diagnostics","page":"Diagnostics groups","title":"ClimateMachine.Diagnostics.setup_dump_aux_diagnostics","text":"setup_dump_aux_diagnostics(\n    ::ClimateMachineConfigType,\n    interval::String,\n    out_prefix::String;\n    writer = NetCDFWriter(),\n    interpol = nothing,\n)\n\nCreate and return a DiagnosticsGroup containing a diagnostic that simply dumps the auxiliary state variables at the specified interval after being interpolated, into NetCDF files prefixed by out_prefix.\n\n\n\n\n\n","category":"function"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/risingbubble.jl\"","category":"page"},{"location":"generated/Atmos/risingbubble/#Rising-Thermal-Bubble","page":"LES Experiment (Rising Thermal Bubble)","title":"Rising Thermal Bubble","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"In this example, we demonstrate the usage of the ClimateMachine AtmosModel machinery to solve the fluid dynamics of a thermal perturbation in a neutrally stratified background state defined by its uniform potential temperature. We solve a flow in a box configuration - this is representative of a large-eddy simulation. Several versions of the problem setup may be found in literature, but the general idea is to examine the vertical ascent of a thermal bubble (we can interpret these as simple representation of convective updrafts).","category":"page"},{"location":"generated/Atmos/risingbubble/#Description-of-experiment","page":"LES Experiment (Rising Thermal Bubble)","title":"Description of experiment","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"Dry Rising Bubble (circular potential temperature perturbation)\nBoundaries Top and Bottom boundaries:\nImpenetrable(FreeSlip()) - Top and bottom: no momentum flux, no mass flux through walls.\nImpermeable() - non-porous walls, i.e. no diffusive fluxes through  walls.\nLateral boundaries\nLaterally periodic\nDomain - 2500m (horizontal) x 2500m (horizontal) x 2500m (vertical)\nResolution - 50m effective resolution\nTotal simulation time - 1000s\nMesh Aspect Ratio (Effective resolution) 1:1\nOverrides defaults for\nCPU Initialisation\nTime integrator\nSources\nSmagorinsky Coefficient","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"note: Note\nThis experiment setup assumes that you have installed the ClimateMachine according to the instructions on the landing page. We assume the users' familiarity with the conservative form of the equations of motion for a compressible fluid (see the AtmosModel page).The following topics are covered in this examplePackage requirements\nDefining a model subtype for the set of conservation equations\nDefining the initial conditions\nApplying source terms\nChoosing a turbulence model\nAdding tracers to the model\nChoosing a time-integrator\nChoosing diagnostics (output) configurationsThe following topics are not covered in this exampleDefining new boundary conditions\nDefining new turbulence models\nBuilding new time-integrators\nAdding diagnostic variables (beyond a standard pre-defined list of variables)","category":"page"},{"location":"generated/Atmos/risingbubble/#Loading-code-rtb","page":"LES Experiment (Rising Thermal Bubble)","title":"Loading code","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"Before setting up our experiment, we recognize that we need to import some pre-defined functions from other packages. Julia allows us to use existing modules (variable workspaces), or write our own to do so.  Complete documentation for the Julia module system can be found here.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"We need to use the ClimateMachine module! This imports all functions specific to atmospheric and ocean flow modeling.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"using ClimateMachine\nClimateMachine.init()\nusing ClimateMachine.Atmos\nusing ClimateMachine.Orientations\nusing ClimateMachine.ConfigTypes\nusing ClimateMachine.Diagnostics\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.TemperatureProfiles\nusing ClimateMachine.Thermodynamics\nusing ClimateMachine.TurbulenceClosures\nusing ClimateMachine.VariableTemplates","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"In ClimateMachine we use StaticArrays for our variable arrays. We also use the Test package to help with unit tests and continuous integration systems to design sensible tests for our experiment to ensure new / modified blocks of code don't damage the fidelity of the physics. The test defined within this experiment is not a unit test for a specific subcomponent, but ensures time-integration of the defined problem conditions within a reasonable tolerance. Immediately useful macros and functions from this include @test and @testset which will allow us to define the testing parameter sets.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"using StaticArrays\nusing Test\nusing CLIMAParameters\nusing CLIMAParameters.Atmos.SubgridScale: C_smag\nusing CLIMAParameters.Planet: R_d, cp_d, cv_d, MSLP, grav\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet();\nnothing #hide","category":"page"},{"location":"generated/Atmos/risingbubble/#init-rtb","page":"LES Experiment (Rising Thermal Bubble)","title":"Initial Conditions","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"This example demonstrates the use of functions defined in the Thermodynamics package to generate the appropriate initial state for our problem.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"note: Note\nThe following variables are assigned in the initial conditionstate.ρ = Scalar quantity for initial density profile\nstate.ρu= 3-component vector for initial momentum profile\nstate.ρe= Scalar quantity for initial total-energy profile humidity\nstate.tracers.ρχ = Vector of four tracers (here, for demonstration only; we can interpret these as dye injections for visualization purposes)","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"function init_risingbubble!(problem, bl, state, aux, localgeo, t)\n    (x, y, z) = localgeo.coord\n\n    # Problem float-type\n    FT = eltype(state)\n\n    # Unpack constant parameters\n    R_gas::FT = R_d(bl.param_set)\n    c_p::FT = cp_d(bl.param_set)\n    c_v::FT = cv_d(bl.param_set)\n    p0::FT = MSLP(bl.param_set)\n    _grav::FT = grav(bl.param_set)\n    γ::FT = c_p / c_v\n\n    # Define bubble center and background potential temperature\n    xc::FT = 5000\n    yc::FT = 1000\n    zc::FT = 2000\n    r = sqrt((x - xc)^2 + (z - zc)^2)\n    rc::FT = 2000\n    θamplitude::FT = 2\n\n    # This is configured in the reference hydrostatic state\n    θ_ref::FT = bl.ref_state.virtual_temperature_profile.T_surface\n\n    # Add the thermal perturbation:\n    Δθ::FT = 0\n    if r <= rc\n        Δθ = θamplitude * (1.0 - r / rc)\n    end\n\n    # Compute perturbed thermodynamic state:\n    θ = θ_ref + Δθ                                      ## potential temperature\n    π_exner = FT(1) - _grav / (c_p * θ) * z             ## exner pressure\n    ρ = p0 / (R_gas * θ) * (π_exner)^(c_v / R_gas)      ## density\n    T = θ * π_exner\n    e_int = internal_energy(bl.param_set, T)\n    ts = PhaseDry(bl.param_set, e_int, ρ)\n    ρu = SVector(FT(0), FT(0), FT(0))                   ## momentum\n    # State (prognostic) variable assignment\n    e_kin = FT(0)                                       ## kinetic energy\n    e_pot = gravitational_potential(bl, aux)            ## potential energy\n    ρe_tot = ρ * total_energy(e_kin, e_pot, ts)         ## total energy\n\n    ρχ = FT(0)                                          ## tracer\n\n    # We inject tracers at the initial condition at some specified z coordinates\n    if 500 < z <= 550\n        ρχ += FT(0.05)\n    end\n\n    # We want 4 tracers\n    ntracers = 4\n\n    # Define 4 tracers, (arbitrary scaling for this demo problem)\n    ρχ = SVector{ntracers, FT}(ρχ, ρχ / 2, ρχ / 3, ρχ / 4)\n\n    # Assign State Variables\n    state.ρ = ρ\n    state.ρu = ρu\n    state.ρe = ρe_tot\n    state.tracers.ρχ = ρχ\nend","category":"page"},{"location":"generated/Atmos/risingbubble/#config-helper","page":"LES Experiment (Rising Thermal Bubble)","title":"Model Configuration","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"We define a configuration function to assist in prescribing the physical model. The purpose of this is to populate the ClimateMachine.AtmosLESConfiguration with arguments appropriate to the problem being considered.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"function config_risingbubble(FT, N, resolution, xmax, ymax, zmax)\n\n    # Choose an Explicit Single-rate Solver from the existing [`ODESolvers`](@ref ClimateMachine.ODESolvers) options.\n    # Apply the outer constructor to define the `ode_solver`.\n    # The 1D-IMEX method is less appropriate for the problem given the current\n    # mesh aspect ratio (1:1).\n    ode_solver = ClimateMachine.ExplicitSolverType(\n        solver_method = LSRK144NiegemannDiehlBusch,\n    )\n    # If the user prefers a multi-rate explicit time integrator,\n    # the ode_solver above can be replaced with\n    #\n    # `ode_solver = ClimateMachine.MultirateSolverType(\n    #    fast_model = AtmosAcousticGravityLinearModel,\n    #    slow_method = LSRK144NiegemannDiehlBusch,\n    #    fast_method = LSRK144NiegemannDiehlBusch,\n    #    timestep_ratio = 10,\n    # )`\n    # See [ODESolvers](@ref ODESolvers-docs) for all of the available solvers.\n\n\n    # Since we want four tracers, we specify this and include the appropriate\n    # diffusivity scaling coefficients (normally these would be physically\n    # informed but for this demonstration we use integers corresponding to the\n    # tracer index identifier)\n    ntracers = 4\n    δ_χ = SVector{ntracers, FT}(1, 2, 3, 4)\n    # To assemble `AtmosModel` with no tracers, set `tracers = NoTracers()`.\n\n    # The model coefficient for the turbulence closure is defined via the\n    # [CLIMAParameters\n    # package](https://CliMA.github.io/CLIMAParameters.jl/latest/) A reference\n    # state for the linearisation step is also defined.\n    T_surface = FT(300)\n    T_min_ref = FT(0)\n    T_profile = DryAdiabaticProfile{FT}(param_set, T_surface, T_min_ref)\n    ref_state = HydrostaticState(T_profile)\n\n    # Here we assemble the `AtmosModel`.\n    _C_smag = FT(C_smag(param_set))\n    model = AtmosModel{FT}(\n        AtmosLESConfigType,                            ## Flow in a box, requires the AtmosLESConfigType\n        param_set;                                     ## Parameter set corresponding to earth parameters\n        init_state_prognostic = init_risingbubble!,    ## Apply the initial condition\n        ref_state = ref_state,                         ## Reference state\n        turbulence = SmagorinskyLilly(_C_smag),        ## Turbulence closure model\n        moisture = DryModel(),                         ## Exclude moisture variables\n        source = (Gravity(),),                         ## Gravity is the only source term here\n        tracers = NTracers{ntracers, FT}(δ_χ),         ## Tracer model with diffusivity coefficients\n    )\n\n    # Finally, we pass a `Problem Name` string, the mesh information, and the\n    # model type to  the [`AtmosLESConfiguration`] object.\n    config = ClimateMachine.AtmosLESConfiguration(\n        \"DryRisingBubble\",       ## Problem title [String]\n        N,                       ## Polynomial order [Int]\n        resolution,              ## (Δx, Δy, Δz) effective resolution [m]\n        xmax,                    ## Domain maximum size [m]\n        ymax,                    ## Domain maximum size [m]\n        zmax,                    ## Domain maximum size [m]\n        param_set,               ## Parameter set.\n        init_risingbubble!,      ## Function specifying initial condition\n        solver_type = ode_solver,## Time-integrator type\n        model = model,           ## Model type\n    )\n    return config\nend","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"note: Note\nKeywords are used to specify some arguments (see appropriate source files).","category":"page"},{"location":"generated/Atmos/risingbubble/#config_diagnostics","page":"LES Experiment (Rising Thermal Bubble)","title":"Diagnostics","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"Here we define the diagnostic configuration specific to this problem.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"function config_diagnostics(driver_config)\n    interval = \"10000steps\"\n    dgngrp = setup_atmos_default_diagnostics(\n        AtmosLESConfigType(),\n        interval,\n        driver_config.name,\n    )\n    return ClimateMachine.DiagnosticsConfiguration([dgngrp])\nend\n\nfunction main()\n    # These are essentially arguments passed to the\n    # [`config_risingbubble`](@ref config-helper) function.  For type\n    # consistency we explicitly define the problem floating-precision.\n    FT = Float64\n    # We need to specify the polynomial order for the DG discretization,\n    # effective resolution, simulation end-time, the domain bounds, and the\n    # courant-number for the time-integrator. Note how the time-integration\n    # components `solver_config` are distinct from the spatial / model\n    # components in `driver_config`. `init_on_cpu` is a helper keyword argument\n    # that forces problem initialization on CPU (thereby allowing the use of\n    # random seeds, spline interpolants and other special functions at the\n    # initialization step.)\n    N = 4\n    Δh = FT(125)\n    Δv = FT(125)\n    resolution = (Δh, Δh, Δv)\n    xmax = FT(10000)\n    ymax = FT(500)\n    zmax = FT(10000)\n    t0 = FT(0)\n    timeend = FT(100)\n    # For full simulation set `timeend = 1000`\n\n    # Use up to 1.7 if ode_solver is the single rate LSRK144.\n    CFL = FT(1.7)\n\n    # Assign configurations so they can be passed to the `invoke!` function\n    driver_config = config_risingbubble(FT, N, resolution, xmax, ymax, zmax)\n    solver_config = ClimateMachine.SolverConfiguration(\n        t0,\n        timeend,\n        driver_config,\n        init_on_cpu = true,\n        Courant_number = CFL,\n    )\n    dgn_config = config_diagnostics(driver_config)\n\n    # Invoke solver (calls `solve!` function for time-integrator), pass the driver,\n    # solver and diagnostic config information.\n    result = ClimateMachine.invoke!(\n        solver_config;\n        diagnostics_config = dgn_config,\n        user_callbacks = (),\n        check_euclidean_distance = true,\n    )\n\n    # Check that the solution norm is reasonable.\n    @test isapprox(result, FT(1); atol = 1.5e-3)\nend","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"The experiment definition is now complete. Time to run it.","category":"page"},{"location":"generated/Atmos/risingbubble/#Running-the-file","page":"LES Experiment (Rising Thermal Bubble)","title":"Running the file","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"julia --project tutorials/Atmos/risingbubble.jl will run the experiment from the main ClimateMachine.jl directory, with diagnostics output at the intervals specified in config_diagnostics.  You can also prescribe command line arguments for simulation update and output specifications.  For rapid turnaround, we recommend that you run this experiment on a GPU.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"VTK output can be controlled via command line by setting parse_clargs=true in the ClimateMachine.init arguments, and then using --vtk=<interval>.","category":"page"},{"location":"generated/Atmos/risingbubble/#output-viz","page":"LES Experiment (Rising Thermal Bubble)","title":"Output Visualisation","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"See the ClimateMachine API interface documentation for generating output.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"VisIt\nParaview","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"are two commonly used programs for .vtu files.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"For NetCDF or JLD2 diagnostics you may use any of the following tools: Julia's NCDatasets and JLD2 packages with a suitable","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"or the known and quick NCDF visualization tool: ncview plotting program.","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"main()","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"","category":"page"},{"location":"generated/Atmos/risingbubble/","page":"LES Experiment (Rising Thermal Bubble)","title":"LES Experiment (Rising Thermal Bubble)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#Meshing-Stuff","page":"Meshes","title":"Meshing Stuff","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"CurrentModule = ClimateMachine.Mesh","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#Topologies","page":"Meshes","title":"Topologies","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#Types","page":"Meshes","title":"Types","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Topologies.AbstractTopology\nTopologies.BoxElementTopology\nTopologies.BrickTopology\nTopologies.StackedBrickTopology\nTopologies.CubedShellTopology\nTopologies.StackedCubedSphereTopology\nTopologies.SingleExponentialStretching","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.AbstractTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.AbstractTopology","text":"AbstractTopology{dim}\n\nRepresents the connectivity of individual elements, with local dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.BoxElementTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.BoxElementTopology","text":"BoxElementTopology{dim, T} <: AbstractTopology{dim}\n\nThe local topology of a larger MPI-distributed topology, represented by dim-dimensional box elements.\n\nThis contains the necessary information for the connectivity elements of the elements on the local process, along with \"ghost\" elements from neighbouring processes.\n\nFields\n\nmpicomm\nMPI communicator for communicating with neighbouring processes.\n\nelems\nRange of element indices\n\nrealelems\nRange of real (aka nonghost) element indices\n\nghostelems\nRange of ghost element indices\n\nghostfaces\nGhost element to face is received; ghostfaces[f,ge] == true if face f of ghost element ge is received.\n\nsendelems\nArray of send element indices\n\nsendfaces\nSend element to face is sent; sendfaces[f,se] == true if face f of send element se is sent.\n\ninteriorelems\nArray of real elements that do not have a ghost element as a neighbor.\n\nexteriorelems\nArray of real elements that have at least on ghost element as a neighbor.\nNote that this is different from sendelems because sendelems duplicates elements that need to be sent to multiple neighboring processes.\n\nelemtocoord\nElement to vertex coordinates; elemtocoord[d,i,e] is the dth coordinate of corner i of element e\nnote: Note\ncurrently coordinates always are of size 3 for (x1, x2, x3)\n\nelemtoelem\nElement to neighboring element; elemtoelem[f,e] is the number of the element neighboring element e across face f.  If there is no neighboring element then elemtoelem[f,e] == e.\n\nelemtoface\nElement to neighboring element face; elemtoface[f,e] is the face number of the element neighboring element e across face f.  If there is no neighboring element then elemtoface[f,e] == f.\"\n\nelemtoordr\nelement to neighboring element order; elemtoordr[f,e] is the ordering number of the element neighboring element e across face f.  If there is no neighboring element then elemtoordr[f,e] == 1.\n\nelemtobndy\nElement to boundary number; elemtobndy[f,e] is the boundary number of face f of element e.  If there is a neighboring element then elemtobndy[f,e] == 0.\n\nnabrtorank\nList of the MPI ranks for the neighboring processes\n\nnabrtorecv\nRange in ghost elements to receive for each neighbor\n\nnabrtosend\nRange in sendelems to send for each neighbor\n\norigsendorder\noriginal order in partitioning\n\nhasboundary\nboolean for whether or not this topology has a boundary\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.BrickTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.BrickTopology","text":"BrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topology. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.StackedBrickTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topology, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.CubedShellTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.CubedShellTopology","text":"CubedShellTopology{T} <: AbstractTopology{2}\n\nA cube-shell topology. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology{3, T} <: AbstractTopology{3}\n\nA cube-sphere topology. All elements on the same \"vertical\" dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.SingleExponentialStretching","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.SingleExponentialStretching","text":"SingleExponentialStretching(A)\n\nApply single-exponential stretching: A > 0 will increase the density of points at the lower boundary, A < 0 will increase the density at the upper boundary.\n\nReference\n\n\"Handbook of Grid Generation\" J. F. Thompson, B. K. Soni, N. P. Weatherill (Editors) RCR Press 1999, §3.6.1 Single-Exponential Function\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#Constructors","page":"Meshes","title":"Constructors","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Topologies.BrickTopology(mpicomm, Nelems)\nTopologies.StackedBrickTopology(mpicomm, elemrange)\nTopologies.CubedShellTopology(mpicomm, Neside, T)\nTopologies.StackedCubedSphereTopology(mpicomm, Nhorz, Rrange)","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.BrickTopology-Tuple{Any,Any}","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.BrickTopology","text":"BrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)\n\nGenerate a brick mesh topology with coordinates given by the tuple elemrange and the periodic dimensions given by the periodicity tuple.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x2-direction with\n\n\nusing ClimateMachine.Topologies\nusing MPI\nMPI.Init()\ntopology = BrickTopology(MPI.COMM_SELF, (2:5,4:6);\n                         periodicity=(false,true),\n                         boundary=((1,2),(3,4)))\n\nThis returns the mesh structure for\n\n         x2\n\n          ^\n          |\n         6-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  3  |  4  |  5  |\n          |  |     |     |     |\n         5-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  1  |  2  |  6  |\n          |  |     |     |     |\n         4-  +-----+-----+-----+\n          |\n          +--|-----|-----|-----|--> x1\n             2     3     4     5\n\nFor example, the (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> topology.elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 3] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 4] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 5] =\n 4  5  4  5\n 5  5  6  6\n\n[:, :, 6] =\n 4  5  4  5\n 4  4  5  5\n\nNote that the corners are listed in Cartesian order.\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> topology.elemtobndy\n4×6 Array{Int64,2}:\n 1  0  1  0  0  0\n 0  0  0  0  2  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)\n\nGenerate a stacked brick mesh topology with coordinates given by the tuple elemrange and the periodic dimensions given by the periodicity tuple.\n\nThe elements are stacked such that the elements associated with range elemrange[dim] are contiguous in the element ordering.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.  Further, stacks are not split at MPI boundaries.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x2-direction with\n\n\nusing ClimateMachine.Topologies\nusing MPI\nMPI.Init()\ntopology = StackedBrickTopology(MPI.COMM_SELF, (2:5,4:6);\n                                periodicity=(false,true),\n                                boundary=((1,2),(3,4)))\n\nThis returns the mesh structure stacked in the x2-direction for\n\n         x2\n\n          ^\n          |\n         6-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  2  |  4  |  6  |\n          |  |     |     |     |\n         5-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  1  |  3  |  5  |\n          |  |     |     |     |\n         4-  +-----+-----+-----+\n          |\n          +--|-----|-----|-----|--> x1\n             2     3     4     5\n\nFor example, the (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> topology.elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 3] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 4] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 5] =\n 4  5  4  5\n 4  4  5  5\n\n[:, :, 6] =\n 4  5  4  5\n 5  5  6  6\n\nNote that the corners are listed in Cartesian order.\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> topology.elemtobndy\n4×6 Array{Int64,2}:\n 1  0  1  0  0  0\n 0  0  0  0  2  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.CubedShellTopology","text":"CubedShellTopology(mpicomm, Nelem, T) <: AbstractTopology{dim}\n\nGenerate a cubed shell mesh with the number of elements along each dimension of the cubes being Nelem. This topology actual creates a cube mesh, and the warping should be done after the grid is created using the cubedshellwarp function. The coordinates of the points will be of type T.\n\nThe elements of the shell are partitioned equally across the MPI ranks based on a space-filling curve.\n\nNote that this topology is logically 2-D but embedded in a 3-D space\n\nExamples\n\nWe can build a cubed shell mesh with 10 elements on each cube, total elements is 10 * 10 * 6 = 600, with\n\nusing ClimateMachine.Topologies\nusing MPI\nMPI.Init()\ntopology = CubedShellTopology(MPI.COMM_SELF, 10, Float64)\n\n# Typically the warping would be done after the grid is created, but the cell\n# corners could be warped with...\n\n# Shell radius = 1\nx1, x2, x3 = ntuple(j->topology.elemtocoord[j, :, :], 3)\nfor n = 1:length(x1)\n   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])\nend\n\n# Shell radius = 10\nx1, x2, x3 = ntuple(j->topology.elemtocoord[j, :, :], 3)\nfor n = 1:length(x1)\n  x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n], 10)\nend\n\n\n\n\n\n","category":"method"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology(mpicomm, Nhorz, Rrange;                               boundary=(1,1)) <: AbstractTopology{3}\n\nGenerate a stacked cubed sphere topology with Nhorz by Nhorz cells for each horizontal face and Rrange is the radius edges of the stacked elements.  This topology actual creates a cube mesh, and the warping should be done after the grid is created using the cubedshellwarp function. The coordinates of the points will be of type eltype(Rrange). The inner boundary condition type is boundary[1] and the outer boundary condition type is boundary[2].\n\nThe elements are stacked such that the vertical elements are contiguous in the element ordering.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve. Further, stacks are not split at MPI boundaries.\n\nExamples\n\nWe can build a cubed sphere mesh with 10 x 10 x 5 elements on each cube, total elements is 10 * 10 * 5 * 6 = 3000, with\n\nusing ClimateMachine.Topologies\nusing MPI\nMPI.Init()\nNhorz = 10\nNstack = 5\nRrange = Float64.(accumulate(+,1:Nstack+1))\ntopology = StackedCubedSphereTopology(MPI.COMM_SELF, Nhorz, Rrange)\n\nx1, x2, x3 = ntuple(j->reshape(topology.elemtocoord[j, :, :],\n                            2, 2, 2, length(topology.elems)), 3)\nfor n = 1:length(x1)\n   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])\nend\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Numerics/Meshes/Mesh/#Functions","page":"Meshes","title":"Functions","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Topologies.cubedshellmesh\nTopologies.cubedshellwarp\nTopologies.hasboundary\nTopologies.cubedshellunwarp\nTopologies.grid1d","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.cubedshellmesh","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.cubedshellmesh","text":"cubedshellmesh(T, Ne; part=1, numparts=1)\n\nGenerate a cubed mesh with each of the \"cubes\" has an Ne X Ne grid of elements.\n\nThe mesh can optionally be partitioned into numparts and this returns partition part.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.\n\nThis mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.\n\nThe mesh structures for the cubes is as follows:\n\nx2\n   ^\n   |\n4Ne-           +-------+\n   |           |       |\n   |           |   6   |\n   |           |       |\n3Ne-           +-------+\n   |           |       |\n   |           |   5   |\n   |           |       |\n2Ne-           +-------+\n   |           |       |\n   |           |   4   |\n   |           |       |\n Ne-   +-------+-------+-------+\n   |   |       |       |       |\n   |   |   1   |   2   |   3   |\n   |   |       |       |       |\n  0-   +-------+-------+-------+\n   |\n   +---|-------|-------|------|-> x1\n       0      Ne      2Ne    3Ne\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.cubedshellwarp","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.cubedshellwarp","text":"cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))\n\nGiven points (a, b, c) on the surface of a cube, warp the points out to a spherical shell of radius R based on the equiangular gnomonic grid proposed by Ronchi, Iacono, Paolucci (1996) https://linkinghub.elsevier.com/retrieve/pii/S0021999196900479\n\n@article{RonchiIaconoPaolucci1996,\n  title={The ``cubed sphere'': a new method for the solution of partial\n         differential equations in spherical geometry},\n  author={Ronchi, C. and Iacono, R. and Paolucci, P. S.},\n  journal={Journal of Computational Physics},\n  volume={124},\n  number={1},\n  pages={93--114},\n  year={1996},\n  doi={10.1006/jcph.1996.0047}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.hasboundary","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.hasboundary","text":"hasboundary(topology::AbstractTopology)\n\nquery function to check whether a topology has a boundary (i.e., not fully periodic)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.cubedshellunwarp","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.cubedshellunwarp","text":"cubedshellunwarp(x1, x2, x3)\n\nThe inverse of cubedshellwarp.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.grid1d","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.grid1d","text":"grid1d(a, b[, stretch::AbstractGridStretching]; elemsize, nelem)\n\nDiscretize the 1D interval [a,b] into elements. Exactly one of the following keyword arguments must be provided:\n\nelemsize: the average element size, or\nnelem: the number of elements.\n\nThe optional stretch argument allows stretching, otherwise the element sizes will be uniform.\n\nReturns either a range object or a vector containing the element boundaries.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#Geometry","page":"Meshes","title":"Geometry","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Geometry.LocalGeometry\nGeometry.lengthscale\nGeometry.resolutionmetric","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Geometry.LocalGeometry","page":"Meshes","title":"ClimateMachine.Mesh.Geometry.LocalGeometry","text":"LocalGeometry\n\nThe local geometry at a nodal point.\n\nConstructors\n\nLocalGeometry{Np, N}(vgeo::AbstractArray{T}, n::Integer, e::Integer)\n\nExtracts a LocalGeometry object from the vgeo array at node n in element e with Np being the number of points in the element and N being the polynomial order\n\nFields\n\npolyorder\npolynomial order of the element\ncoord\nlocal degree of freedom Cartesian coordinate \ninvJ\nJacobian from Cartesian to element coordinates: invJ[i,j] is ξ_i  x_j\n\nvgeo\nGlobal volume geometry array\nn\nelement local linear node index\ne\nprocess local element index\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Geometry.lengthscale","page":"Meshes","title":"ClimateMachine.Mesh.Geometry.lengthscale","text":"lengthscale(g::LocalGeometry)\n\nThe effective grid resolution at the point.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Geometry.resolutionmetric","page":"Meshes","title":"ClimateMachine.Mesh.Geometry.resolutionmetric","text":"resolutionmetric(g::LocalGeometry)\n\nThe metric tensor of the discretisation resolution. Given a unit vector u in Cartesian coordinates and M = resolutionmetric(g), sqrt(u'*M*u) is the degree-of-freedom density in the direction of u.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#Brick-Mesh","page":"Meshes","title":"Brick Mesh","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"BrickMesh.partition\nBrickMesh.brickmesh\nBrickMesh.connectmesh\nBrickMesh.centroidtocode","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.BrickMesh.partition","page":"Meshes","title":"ClimateMachine.Mesh.BrickMesh.partition","text":"partition(comm::MPI.Comm, elemtovert, elemtocoord, elemtobndy,\n          faceconnections)\n\nThis function takes in a mesh (as returned for example by brickmesh) and returns a Hilbert curve based partitioned mesh.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.BrickMesh.brickmesh","page":"Meshes","title":"ClimateMachine.Mesh.BrickMesh.brickmesh","text":"brickmesh(x, periodic; part=1, numparts=1; boundary)\n\nGenerate a brick mesh with coordinates given by the tuple x and the periodic dimensions given by the periodic tuple.\n\nThe brick can optionally be partitioned into numparts and this returns partition part.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x_2-direction with\n\njulia> (elemtovert, elemtocoord, elemtobndy, faceconnections) =\n        brickmesh((2:5,4:6), (false,true); boundary=((1,2), (3,4)));\n\nThis returns the mesh structure for\n\n         x_2\n\n          ^\n          |\n         6-  9----10----11----12\n          |  |     |     |     |\n          |  |  4  |  5  |  6  |\n          |  |     |     |     |\n         5-  5-----6-----7-----8\n          |  |     |     |     |\n          |  |  1  |  2  |  3  |\n          |  |     |     |     |\n         4-  1-----2-----3-----4\n          |\n          +--|-----|-----|-----|--> x_1\n             2     3     4     5\n\nThe (number of corners by number of elements) array elemtovert gives the global vertex number for the corners of each element.\n\njulia> elemtovert\n4×6 Array{Int64,2}:\n 1  2  3   5   6   7\n 2  3  4   6   7   8\n 5  6  7   9  10  11\n 6  7  8  10  11  12\n\nNote that the vertices are listed in Cartesian order.\n\nThe (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 3] =\n 4  5  4  5\n 4  4  5  5\n\n[:, :, 4] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 5] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 6] =\n 4  5  4  5\n 5  5  6  6\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> elemtobndy\n4×6 Array{Int64,2}:\n 1  0  0  1  0  0\n 0  0  2  0  0  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\nFinally, the periodic face connections are given in faceconnections which is a list of arrays, one for each connection. Each array in the list is given in the format [e, f, vs...] where\n\ne  is the element number;\nf  is the face number; and\nvs is the global vertices that face associated with.\n\nI the example\n\njulia> faceconnections\n3-element Array{Array{Int64,1},1}:\n [4, 4, 1, 2]\n [5, 4, 2, 3]\n [6, 4, 3, 4]\n\nwe see that face 4 of element 5 is associated with vertices [2 3] (the vertices for face 1 of element 2).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.BrickMesh.connectmesh","page":"Meshes","title":"ClimateMachine.Mesh.BrickMesh.connectmesh","text":"connectmesh(comm::MPI.Comm, elemtovert, elemtocoord, elemtobndy,\n            faceconnections)\n\nThis function takes in a mesh (as returned for example by brickmesh) and returns a connected mesh.  This returns a NamedTuple of:\n\nelems the range of element indices\nrealelems the range of real (aka nonghost) element indices\nghostelems the range of ghost element indices\nghostfaces ghost element to face is received; ghostfaces[f,ge] == true if face f of ghost element ge is received.\nsendelems an array of send element indices\nsendfaces send element to face is sent; sendfaces[f,se] == true if face f of send element se is sent.\nelemtocoord element to vertex coordinates; elemtocoord[d,i,e] is the  dth coordinate of corner i of element e\nelemtoelem element to neighboring element; elemtoelem[f,e] is the number of the element neighboring element e across face f.  If there is no neighboring element then elemtoelem[f,e] == e.\nelemtoface element to neighboring element face; elemtoface[f,e] is the face number of the element neighboring element e across face f.  If there is no neighboring element then elemtoface[f,e] == f.\nelemtoordr element to neighboring element order; elemtoordr[f,e] is the ordering number of the element neighboring element e across face f.  If there is no neighboring element then elemtoordr[f,e] == 1.\nelemtobndy element to bounday number; elemtobndy[f,e] is the boundary number of face f of element e.  If there is a neighboring element then elemtobndy[f,e] == 0.\nnabrtorank a list of the MPI ranks for the neighboring processes\nnabrtorecv a range in ghost elements to receive for each neighbor\nnabrtosend a range in sendelems to send for each neighbor\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.BrickMesh.centroidtocode","page":"Meshes","title":"ClimateMachine.Mesh.BrickMesh.centroidtocode","text":"centroidtocode(comm::MPI.Comm, elemtocorner; coortocode, CT)\n\nReturns a code for each element based on its centroid.\n\nThese element codes can be used to determine a linear ordering for the partition function.\n\nThe communicator comm is used to calculate the bounding box for representing the centroids in coordinates of type CT, defaulting to CT=UInt64.  These integer coordinates are converted to a code using the function coortocode, which defaults to hilbertcode.\n\nThe array containing the element corner coordinates, elemtocorner, is used to compute the centroids.  elemtocorner is a dimension by number of corners by number of elements array.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#Grids","page":"Meshes","title":"Grids","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Grids specify the approximation within each element, and any necessary warping.","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Grids.get_z\nGrids.referencepoints\nGrids.min_node_distance\nGrids.DiscontinuousSpectralElementGrid","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Grids.get_z","page":"Meshes","title":"ClimateMachine.Mesh.Grids.get_z","text":"get_z(grid; z_scale = 1, rm_dupes = false)\n\nGet the Gauss-Lobatto points along the Z-coordinate.\n\ngrid: DG grid\nz_scale: multiplies z-coordinate\nrm_dupes: removes duplicate Gauss-Lobatto points\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Grids.referencepoints","page":"Meshes","title":"ClimateMachine.Mesh.Grids.referencepoints","text":"referencepoints(::AbstractGrid)\n\nReturns the points on the reference element.\n\n\n\n\n\nreferencepoints(::DiscontinuousSpectralElementGrid)\n\nReturns the 1D interpolation points used for the reference element.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Grids.min_node_distance","page":"Meshes","title":"ClimateMachine.Mesh.Grids.min_node_distance","text":"min_node_distance(::AbstractGrid, direction::Direction=EveryDirection() )\n\nReturns an approximation of the minimum node distance in physical space.\n\n\n\n\n\nmin_node_distance(::DiscontinuousSpectralElementGrid,\n                  direction::Direction=EveryDirection()))\n\nReturns an approximation of the minimum node distance in physical space along the reference coordinate directions.  The direction controls which reference directions are considered.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid","page":"Meshes","title":"ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid","text":"DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,\n                                 polynomialorder,\n                                 meshwarp = (x...)->identity(x))\n\nGenerate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a topology, where the order of the elements is given by polynomialorder. DeviceArray gives the array type used to store the data (CuArray or Array), and the coordinate points will be of FloatType.\n\nThe optional meshwarp function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#Filters","page":"Meshes","title":"Filters","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"There are methods used to cleanup state vectors.","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Filters.CutoffFilter\nFilters.BoydVandevenFilter\nFilters.ExponentialFilter\nFilters.TMARFilter","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Filters.CutoffFilter","page":"Meshes","title":"ClimateMachine.Mesh.Filters.CutoffFilter","text":"CutoffFilter(grid, Nc=polynomialorder(grid))\n\nReturns the spectral filter that zeros out polynomial modes greater than or equal to Nc.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Filters.BoydVandevenFilter","page":"Meshes","title":"ClimateMachine.Mesh.Filters.BoydVandevenFilter","text":"BoydVandevenFilter(grid, Nc=0, s=32)\n\nReturns the spectral filter using the logorithmic error function of the form:\n\nσ(η) = 12 erfc(2*sqrt(s)*χ(η)*(abs(η)-05))\n\nwhenever s ≤ i ≤ N, and 1 otherwise. The function χ(η) is defined as\n\nχ(η) = sqrt(-log(1-4*(abs(η)-05)^2)(4*(abs(η)-05)^2))\n\nif x != 0.5 and 1 otherwise. Here, s is the filter order, the filter starts with polynomial order Nc, and alpha is a parameter controlling the smallest value of the filter function.\n\nReferences\n\n@inproceedings{boyd1996erfc,\ntitle={The erfc-log filter and the asymptotics of the Euler and Vandeven sequence accelerations},\nauthor={Boyd, JP},\nbooktitle={Proceedings of the Third International Conference on Spectral and High Order Methods},\npages={267--276},\nyear={1996},\norganization={Houston Math. J}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Filters.ExponentialFilter","page":"Meshes","title":"ClimateMachine.Mesh.Filters.ExponentialFilter","text":"ExponentialFilter(grid, Nc=0, s=32, α=-log(eps(eltype(grid))))\n\nReturns the spectral filter with the filter function\n\nσ(η) = xp(-α η^s)\n\nwhere s is the filter order (must be even), the filter starts with polynomial order Nc, and alpha is a parameter controlling the smallest value of the filter function.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Filters.TMARFilter","page":"Meshes","title":"ClimateMachine.Mesh.Filters.TMARFilter","text":"TMARFilter()\n\nReturns the truncation and mass aware rescaling nonnegativity preservation filter.  The details of this filter are described in\n\n@article{doi:10.1175/MWR-D-16-0220.1,\n  author = {Light, Devin and Durran, Dale},\n  title = {Preserving Nonnegativity in Discontinuous Galerkin\n           Approximations to Scalar Transport via Truncation and Mass\n           Aware Rescaling (TMAR)},\n  journal = {Monthly Weather Review},\n  volume = {144},\n  number = {12},\n  pages = {4771-4786},\n  year = {2016},\n  doi = {10.1175/MWR-D-16-0220.1},\n}\n\nNote this needs to be used with a restrictive time step or a flux correction to ensure that grid integral is conserved.\n\nExamples\n\nThis filter can be applied to the 3rd and 4th fields of an MPIStateArray Q with the code\n\nFilters.apply!(Q, (3, 4), grid, TMARFilter())\n\nwhere grid is the associated DiscontinuousSpectralElementGrid.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#Interpolation","page":"Meshes","title":"Interpolation","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#Types-2","page":"Meshes","title":"Types","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Interpolation.InterpolationBrick\nInterpolation.InterpolationCubedSphere","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.InterpolationBrick","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.InterpolationBrick","text":"InterpolationBrick{\n    FT <: AbstractFloat,CuArrays\n    UI8AD <: AbstractArray{UInt8, 2},\n    UI16VD <: AbstractVector{UInt16},\n    I32V <: AbstractVector{Int32},\n} <: InterpolationTopology\n\nThis interpolation data structure and the corresponding functions works for a brick, where stretching/compression happens only along the x1, x2 & x3 axis. Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3).\n\nFields\n\nNel\nNumber of elements\nNp\nTotal number of interpolation points\nNpl\nTotal number of interpolation points on local process\npoly_order\nPolynomial order of spectral element approximation\nxbnd\nDomain bounds in x1, x2 and x3 directions\nx1g\nInterpolation grid in x1 direction\nx2g\nInterpolation grid in x2 direction\nx3g\nInterpolation grid in x3 direction\nξ1\nUnique ξ1 coordinates of interpolation points within each spectral element\nξ2\nUnique ξ2 coordinates of interpolation points within each spectral element\nξ3\nUnique ξ3 coordinates of interpolation points within each spectral element\nflg\nFlags when ξ1/ξ2/ξ3 interpolation point matches with a GLL point\nfac\nNormalization factor\nx1i\nx1 interpolation grid index of interpolation points within each element on the local process\nx2i\nx2 interpolation grid index of interpolation points within each element on the local process\nx3i\nx3 interpolation grid index of interpolation points within each element on the local process\noffset\nOffsets for each element\nm1_r\nGLL points\nm1_w\nGLL weights\nwb\nBarycentric weights\nNp_all\nNumber of interpolation points on each of the processes\nx1i_all\nx1 interpolation grid index of interpolation points within each element on all processes stored only on proc 0\nx2i_all\nx2 interpolation grid index of interpolation points within each element on all processes stored only on proc 0\nx3i_all\nx3 interpolation grid index of interpolation points within each element on all processes stored only on proc 0\n\nUsage\n\nInterpolationBrick(\n    grid::DiscontinuousSpectralElementGrid{FT},\n    xbnd::Array{FT,2},\n    xres,\n) where FT <: AbstractFloat\n\nThis interpolation structure and the corresponding functions works for a brick, where stretching/compression happens only along the x1, x2 & x3 axis. Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3).\n\nArguments for the inner constructor\n\ngrid: DiscontinousSpectralElementGrid\nxbnd: Domain boundaries in x1, x2 and x3 directions\nxres: Resolution of the interpolation grid in x1, x2 and x3 directions\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere","text":"InterpolationCubedSphere{\nFT <: AbstractFloat,\nT <: Int,\nFTV <: AbstractVector{FT},\nFTVD <: AbstractVector{FT},\nTVD <: AbstractVector{T},\nUI8AD <: AbstractArray{UInt8, 2},\nUI16VD <: AbstractVector{UInt16},\nI32V <: AbstractVector{Int32},\n} <: InterpolationTopology\n\nThis interpolation structure and the corresponding functions works for a cubed sphere topology. The data is interpolated along a lat/long/rad grid.\n\n-90⁰  ≤ lat  ≤ 90⁰\n\n-180⁰ ≤ long ≤ 180⁰\n\nRᵢ ≤ r ≤ Rₒ\n\nFields\n\nNel\nNumber of elements\nNp\nNumber of interpolation points\nNpl\nNumber of interpolation points on local process\npoly_order\nPolynomial order of spectral element approximation\nn_rad\nNumber of interpolation points in radial direction\nn_lat\nNumber of interpolation points in lat direction\nn_long\nNumber of interpolation points in long direction\nrad_grd\nInterpolation grid in radial direction\nlat_grd\nInterpolation grid in lat direction\nlong_grd\nInterpolation grid in long direction\nξ1\nDevice array containing ξ1 coordinates of interpolation points within each element\nξ2\nDevice array containing ξ2 coordinates of interpolation points within each element\nξ3\nDevice array containing ξ3 coordinates of interpolation points within each element\nflg\nflags when ξ1/ξ2/ξ3 interpolation point matches with a GLL point\nfac\nNormalization factor\nradi\nRadial coordinates of interpolation points withing each element\nlati\nLatitude coordinates of interpolation points withing each element\nlongi\nLongitude coordinates of interpolation points withing each element\noffset\nOffsets for each element\nm1_r\nGLL points\nm1_w\nGLL weights\nwb\nBarycentric weights\nNp_all\nNumber of interpolation points on each of the processes\nradi_all\nRadial interpolation grid index of interpolation points within each element on all processes stored only on proc 0\nlati_all\nLatitude interpolation grid index of interpolation points within each element on all processes stored only on proc 0\nlongi_all\nLongitude interpolation grid index of interpolation points within each element on all processes stored only on proc 0\n\nUsage\n\nInterpolationCubedSphere(grid::DiscontinuousSpectralElementGrid, vert_range::AbstractArray{FT}, nhor::Int, lat_res::FT, long_res::FT, rad_res::FT) where {FT <: AbstractFloat}\n\nThis interpolation structure and the corresponding functions works for a cubed sphere topology. The data is interpolated along a lat/long/rad grid.\n\n-90⁰  ≤ lat  ≤ 90⁰\n\n-180⁰ ≤ long ≤ 180⁰\n\nRᵢ ≤ r ≤ Rₒ\n\nArguments for the inner constructor\n\ngrid: DiscontinousSpectralElementGrid\nvert_range: Vertex range along the radial coordinate\nlat_res: Resolution of the interpolation grid along the latitude coordinate in radians\nlong_res: Resolution of the interpolation grid along the longitude coordinate in radians\nrad_res: Resolution of the interpolation grid along the radial coordinate\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#Functions-2","page":"Meshes","title":"Functions","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/","page":"Meshes","title":"Meshes","text":"Interpolation.interpolate_local!\nInterpolation.project_cubed_sphere!\nInterpolation.accumulate_interpolated_data!","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.interpolate_local!","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.interpolate_local!","text":"interpolate_local!(\n    intrp_brck::InterpolationBrick{FT},\n    sv::AbstractArray{FT},\n    v::AbstractArray{FT},\n) where {FT <: AbstractFloat}\n\nThis interpolation function works for a brick, where stretching/compression happens only along the x1, x2 & x3 axis.  Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3)\n\nArguments\n\nintrp_brck: Initialized InterpolationBrick structure\nsv: State Array consisting of various variables on the discontinuous Galerkin grid\nv:  Interpolated variables\n\n\n\n\n\ninterpolate_local!(intrp_cs::InterpolationCubedSphere{FT},\n                         sv::AbstractArray{FT},\n                          v::AbstractArray{FT}) where {FT <: AbstractFloat}\n\nThis interpolation function works for cubed spherical shell geometry.\n\nArguments\n\nintrp_cs: Initialized cubed sphere structure\nsv: Array consisting of various variables on the discontinuous Galerkin grid\nv:  Array consisting of variables on the interpolated grid\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.project_cubed_sphere!","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.project_cubed_sphere!","text":"project_cubed_sphere!(intrp_cs::InterpolationCubedSphere{FT},\n                             v::AbstractArray{FT},\n                          uvwi::Tuple{Int,Int,Int}) where {FT <: AbstractFloat}\n\nThis function projects the velocity field along unit vectors in radial, lat and long directions for cubed spherical shell geometry.\n\nFields\n\nintrp_cs: Initialized cubed sphere structure\nv: Array consisting of x1, x2 and x3 components of the vector field\nuvwi:  Tuple providing the column numbers for x1, x2 and x3 components of vector field in the array.          These columns will be replaced with projected vector fields along unit vectors in long, lat and rad directions.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!","text":"accumulate_interpolated_data!(intrp::InterpolationTopology,\n                                 iv::AbstractArray{FT,2},\n                                fiv::AbstractArray{FT,4}) where {FT <: AbstractFloat}\n\nThis interpolation function gathers interpolated data onto process # 0.\n\nFields\n\nintrp: Initialized interpolation topology structure\niv: Interpolated variables on local process\nfiv: Full interpolated variables accumulated on process # 0\n\n\n\n\n\n","category":"function"},{"location":"#ClimateMachine","page":"Home","title":"ClimateMachine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ClimateMachine is a software package that models the evolution of the Earth system over weeks to centuries. The ClimateMachine solves three-dimensional partial differential equations for the distributions of water, momentum, energy, and tracers such as carbon in the atmosphere, oceans, and on land.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ClimateMachine will harness a wide range of Earth observations and data generated computationally to predict the evolution of Earth’s climate and features such as droughts, rainfall extremes, and high-impact storms.","category":"page"},{"location":"#Subcomponents","page":"Home","title":"Subcomponents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ClimateMachine currently consists of three models for the subcomponents of the Earth system:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimateMachine.Atmos: A model of the fluid mechanics of the atmosphere and its interaction with solar radiation and phase changes of water that occur, for example, in clouds.\nClimateMachine.Ocean: A model for the fluid mechanics of the ocean and its distributions of heat, salinity, carbon, and other tracers.\nClimateMachine.Land: A model for the flow of energy and water in soils and on the land surface, for the biophysics of vegetation on land, and for the transfer and storage of carbon in the land biosphere.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The subcomponents will be coupled by exchanging water, momentum, energy, and tracers such as carbon dioxide across their boundaries.","category":"page"},{"location":"#Dynamical-core","page":"Home","title":"Dynamical core","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A dynamical core based on discontinuous Galerkin numerical methods is used to discretize the physical conservation laws that underlie each of the ClimateMachine's subcomponents.","category":"page"},{"location":"#How-to-use-the-documentation","page":"Home","title":"How to use the documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to... Look here\ninstall ClimateMachine.jl Getting started\nlearn about default configurations Getting started\nlook up common terminology Getting started\nrun simple Atmos, Ocean, or Land models Tutorials\nrun code fragments detailing numerical methods Tutorials\nget more detail about a model subcomponent or a numerical method How-to-guides\nlearn how to call functions in source code APIs\nhelp develop ClimateMachine.jl software Contribution guide","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ClimateMachine is being developed by the Climate Modeling Alliance.","category":"page"},{"location":"HowToGuides/Numerics/Meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"HowToGuides/Ocean/#Ocean","page":"Ocean","title":"Ocean","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/#Running-the-ClimateMachine","page":"Running","title":"Running the ClimateMachine","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"The ClimateMachine is composed of three models for the Earth system, a dynamical core, and a number of other components. These are put together to set up a simulation by a driver, for example the Held-Suarez atmospheric GCM, or the Rising Bubble atmospheric LES. The driver specifies:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"the dimensions and resolution of the simulation domain,\nthe duration of the simulation,\nboundary conditions,\nsource terms,\na reference state,\nthe turbulence model,\nthe moisture model,\ndiagnostics of interest,\ninitial conditions,\netc.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Additionally, the driver chooses the time integrator to be used to run the simulation and may specify the Courant number used to compute the timestep.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Thus, running the ClimateMachine requires a driver. For example, the Held-Suarez atmospheric GCM is run with:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"$ julia --project experiments/AtmosGCM/heldsuarez.jl","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Simpler examples of driver files can be found in the tutorials. Driver files in experiments show more complex examples.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#Input-and-output","page":"Running","title":"Input and output","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"The ClimateMachine provides the ArtifactWrappers module to assist a driver in sourcing input data for a simulation, but any mechanism may be used.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Output takes the form of various groups of diagnostic variables that are written to NetCDF files at user-specified intervals by the ClimateMachine when configured to do so by a driver.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"The ClimateMachine can also output prognostic  and auxiliary state variables to VTK files at specified intervals.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Whether or not output is generated, and if so, at what interval, is a ClimateMachine setting.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#ClimateMachine-settings","page":"Running","title":"ClimateMachine settings","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Some aspects of the ClimateMachine's behavior can be controlled via its settings such as use of the GPU, diagnostics output and frequency, checkpointing/restarting, etc. There are 3 ways in which these settings can be changed:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Command line arguments have the highest precedence, but it is possible for a driver to disable parsing of command line arguments. In such a case, only the next two ways can be used to change settings.\nProgrammatic settings have the next highest precedence.\nEnvironment variables have the lowest precedence.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#ClimateMachine-clargs","page":"Running","title":"Command line arguments","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"If a driver configures the ClimateMachine to parse command line arguments (by passing parse_clargs = true to ClimateMachine.init()), you can query the list of arguments understood, for example:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"$ julia --project experiments/AtmosGCM/heldsuarez.jl --help\nusage: experiments/AtmosGCM/heldsuarez.jl [--disable-gpu]\n                        [--show-updates <interval>]\n                        [--diagnostics <interval>] [--vtk <interval>]\n                        [--monitor-timestep-duration <interval>]\n                        [--monitor-courant-numbers <interval>]\n                        [--checkpoint <interval>]\n                        [--checkpoint-keep-all] [--checkpoint-at-end]\n                        [--checkpoint-dir <path>]\n                        [--restart-from-num <number>]\n                        [--fix-rng-seed]\n                        [--disable-custom-logger]\n                        [--log-level <level>] [--output-dir <path>]\n                        [--integration-testing]\n                        [--number-of-tracers <number>] [-h]\n\nClimate Machine: an Earth System Model that automatically learns from data\n\noptional arguments:\n  --number-of-tracers <number>\n                        Number of dummy tracers (type: Int64, default:\n                        0)\n  -h, --help            show this help message and exit\n\nClimateMachine:\n  --disable-gpu         do not use the GPU\n  --show-updates <interval>\n                        interval at which to show simulation updates\n                        (default: \"60secs\")\n  --diagnostics <interval>\n                        interval at which to collect diagnostics\n                        (default: \"never\")\n  --vtk <interval>      interval at which to output VTK (default:\n                        \"never\")\n  --monitor-timestep-duration <interval>\n                        interval in time-steps at which to output\n                        wall-clock time per time-step (default:\n                        \"never\")\n  --monitor-courant-numbers <interval>\n                        interval at which to output acoustic,\n                        advective, and diffusive Courant numbers\n                        (default: \"never\")\n  --checkpoint <interval>\n                        interval at which to create a checkpoint\n                        (default: \"never\")\n  --checkpoint-keep-all\n                        keep all checkpoints (instead of just the most\n                        recent)\n  --checkpoint-at-end   create a checkpoint at the end of the\n                        simulation\n  --checkpoint-dir <path>\n                        the directory in which to store checkpoints\n                        (default: \"checkpoint\")\n  --restart-from-num <number>\n                        checkpoint number from which to restart (in\n                        <checkpoint-dir>) (type: Int64, default: -1)\n  --fix-rng-seed        set RNG seed to a fixed value for\n                        reproducibility\n  --disable-custom-logger\n                        do not use a custom logger\n  --log-level <level>   set the log level to one of\n                        debug/info/warn/error (default: \"info\")\n  --output-dir <path>   directory for output data (default: \"output\")\n  --debug-init          fill state arrays with NaNs and dump them\n                        post-initialization\"\n  --integration-testing\n                        enable integration testing\n\nAny <interval> unless otherwise stated may be specified as:\n    - 2hours or 10mins or 30secs => wall-clock time\n    - 9.5smonths or 3.3sdays or 1.5shours => simulation time\n    - 1000steps => simulation steps\n    - never => disable\n    - default => use experiment specified interval (only for diagnostics at present)","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"There may also be driver-specific command line arguments.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#ClimateMachine-kwargs","page":"Running","title":"Programmatic control","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Every ClimateMachine setting can also be controlled via keyword arguments to the ClimateMachine initialization function, ClimateMachine.init(). For instance, a driver can specify that VTK output should occur every 5 simulation minutes with:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"ClimateMachine.init(vtk = \"5smins\")","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"This can be overridden by by passing --vtk=never on the command line, if the ClimateMachine is parsing command line arguments.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"note: Note\nThe ClimateMachine will only process command line arguments if a driver requests that it do so with:ClimateMachine.init(parse_clargs = true)","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#ClimateMachine-envvars","page":"Running","title":"Environment variables","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Every ClimateMachine command line argument has an equivalent environment variable that takes the form CLIMATEMACHINE_SETTINGS_<SETTING_NAME>, however command line arguments and programmatic control have higher precedence.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#Running-with-MPI","page":"Running","title":"Running with MPI","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Use MPI to start a distributed run of the ClimateMachine. For example:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"mpiexec -np 4 julia --project experiments/AtmosGCM/heldsuarez.jl","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"will run the Held-Suarez experiment with four MPI ranks. If you are running on a cluster, you would use this command within a SLURM batch script (or the equivalent) that allocates four tasks. On a stand-alone machine, MPI will likely require that you have at least four cores.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"Note that unless GPU use is disabled (by changing the setting in one of the ways described above), each ClimateMachine process will use GPU acceleration. If there are insufficient GPUs (four in the example above), the ClimateMachine processes will share the GPU resources available.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#Scripts-for-end-to-end-runs,-logging-and-visualization","page":"Running","title":"Scripts for end-to-end runs, logging and visualization","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/","page":"Running","title":"Running","text":"The ClimateMachine wiki contains detailed examples of Slurm scripts that run the ClimateMachine, record specified performance metrics and produce basic visualization output. ","category":"page"},{"location":"DevDocs/AcceptableUnicode/#Acceptable-Unicode-characters","page":"Acceptable Unicode","title":"Acceptable Unicode characters","text":"","category":"section"},{"location":"DevDocs/AcceptableUnicode/","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"Using Unicode seems to be irresistible. However, we must ensure avoiding problematic Unicode usage.","category":"page"},{"location":"DevDocs/AcceptableUnicode/","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"Below is a list of acceptable Unicode characters.  All characters not listed below are forbidden. We forbid the use of accents (dot, hat, vec, etc.), because this can lead to visually ambiguous characters.","category":"page"},{"location":"DevDocs/AcceptableUnicode/#Acceptable-lower-case-Greek-letters","page":"Acceptable Unicode","title":"Acceptable lower-case Greek letters","text":"","category":"section"},{"location":"DevDocs/AcceptableUnicode/","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"α # (alpha)\nβ # (beta)\nδ # (delta)\nϵ # (epsilon)\nε # (varepsilon)\nγ # (gamma)\nκ # (kappa)\nλ # (lambda)\nμ # (mu)\nν # (nu)\nη # (eta)\nω # (omega)\nπ # (pi)\nρ # (rho)\nσ # (sigma)\nθ # (theta)\nχ # (chi)\nξ # (xi)\nζ # (zeta)\nϕ # (psi)\nφ # (varphi)","category":"page"},{"location":"DevDocs/AcceptableUnicode/#Acceptable-upper-case-Greek-letters","page":"Acceptable Unicode","title":"Acceptable upper-case Greek letters","text":"","category":"section"},{"location":"DevDocs/AcceptableUnicode/","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"Δ # (Delta)\n∑ # (Sigma)\nΓ # (Gamma)\nΩ # (Omega)\nΨ # (Psi)\nΦ # (Phi)","category":"page"},{"location":"DevDocs/AcceptableUnicode/#Acceptable-mathematical-symbols","page":"Acceptable Unicode","title":"Acceptable mathematical symbols","text":"","category":"section"},{"location":"DevDocs/AcceptableUnicode/","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"∫ # (int)\n∬ # (iint)\n∭ # (iiint)\n∞ # (infinity)\n≈ # (approx)\n∂ # (partial)\n∇ # (nabla/del), note that nabla and del are indistinguishable\n∀ # (forall)\n≥ # (greater than equal to)\n≤ # (less than equal to)","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#Atmospheric-temperature-profiles","page":"Temperature profiles","title":"Atmospheric temperature profiles","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"CurrentModule = ClimateMachine.TemperatureProfiles","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"Several temperature profiles are available in ClimateMachine.jl. Here, we plot each profile.","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#Usage","page":"Temperature profiles","title":"Usage","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"Using a profile involves passing two arguments:","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"param_set a parameter set, from CLIMAParameters.jl\nz altitude","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"to one of the temperature profile constructors.","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#IsothermalProfile","page":"Temperature profiles","title":"IsothermalProfile","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"using ClimateMachine.TemperatureProfiles\nusing ClimateMachine.Thermodynamics\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\nFT = Float64;\nz = range(FT(0), stop = FT(2.5e4), length = 50);\n\nisothermal = IsothermalProfile(param_set, FT);\nargs = isothermal.(Ref(param_set), z)\nT = first.(args)\np = last.(args)\n\np1 = plot(T, z./10^3, xlabel=\"Temperature [K]\");\np2 = plot(p./10^3, z./10^3, xlabel=\"Pressure [kPa]\");\nplot(p1, p2, layout=(1,2), title=\"Isothermal\", ylabel=\"z [km]\")\nsavefig(\"isothermal.svg\")","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"(Image: )","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#DecayingTemperatureProfile","page":"Temperature profiles","title":"DecayingTemperatureProfile","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"using ClimateMachine.TemperatureProfiles\nusing ClimateMachine.Thermodynamics\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\nFT = Float64;\nz = range(FT(0), stop = FT(2.5e4), length = 50);\n\ndecaying = DecayingTemperatureProfile{FT}(param_set);\nargs = decaying.(Ref(param_set), z)\nT = first.(args)\np = last.(args)\n\np1 = plot(T, z./10^3, xlabel=\"Temperature [K]\");\np2 = plot(p./10^3, z./10^3, xlabel=\"Pressure [kPa]\");\nplot(p1, p2, layout=(1,2), ylabel=\"z [km]\", title=\"Decaying\")\nsavefig(\"decaying.svg\")","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"(Image: )","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#DryAdiabaticProfile","page":"Temperature profiles","title":"DryAdiabaticProfile","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"using ClimateMachine.TemperatureProfiles\nusing ClimateMachine.Thermodynamics\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\nFT = Float64;\nz = range(FT(0), stop = FT(2.5e4), length = 50);\n\ndry_adiabatic = DryAdiabaticProfile{FT}(param_set);\nargs = dry_adiabatic.(Ref(param_set), z)\nT = first.(args)\np = last.(args)\nθ_dry = Thermodynamics.dry_pottemp_given_pressure.(Ref(param_set), T, p)\n\np1 = plot(T, z./10^3, xlabel=\"Temperature [K]\");\np2 = plot(p./10^3, z./10^3, xlabel=\"Pressure [kPa]\");\np3 = plot(θ_dry, z./10^3, xlabel=\"Potential temperature [K]\");\nplot(p1, p2, p3, layout=(1,3), ylabel=\"z [km]\", title=\"Dry adiabatic\")\nsavefig(\"dry_adiabatic.svg\")","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"(Image: )","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#Extending","page":"Temperature profiles","title":"Extending","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/","page":"Temperature profiles","title":"Temperature profiles","text":"Additional constructors, or additional profiles can be added to this module by adding a struct, containing parameters needed to construct the profile, and a functor to call the profile with a parameter set and altitude.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Land/Soil/Coupled/equilibrium_test.jl\"","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#Coupled-heat-and-water-equations-tending-towards-equilibrium","page":"Coupled Water and Heat","title":"Coupled heat and water equations tending towards equilibrium","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Other tutorials, such as the soil heat tutorial and -link water tutorial here- demonstrate how to solve the heat equation or Richard's equation without considering dynamic interactions between the two. As an example, the user could prescribe a fixed function of space and time for the liquid water content, and use that to drive the heat equation, but without allowing the water content to dynamically evolve according to Richard's equation and without allowing the changing temperature of the soil to affect the water evolution.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Here we show how to solve the interacting heat and water equations, in sand, but without phase changes. This allows us to capture behavior that is not present in the decoupled equations.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"The equations are:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"frac ρe_int t =    κ(θ_l θ_i ν ) T +   ρe_int_liq K (Tθ_l θ_i ν ) nabla h( ϑ_l z ν )","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"frac  ϑ_l t =   K (Tθ_l θ_i ν ) h( ϑ_l z ν )","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Here","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"t is the time (s),","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"z is the location in the vertical (m),","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ρe_int is the volumetric internal energy of the soil (J/m^3),","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"T is the temperature of the soil (K),","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"κ is the thermal conductivity (W/m/K),","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ρe_int_liq is the volumetric internal energy of liquid water (J/m^3),","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"K is the hydraulic conductivity (m/s),","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"h is the hydraulic head (m),","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ϑ_l is the augmented volumetric liquid water fraction,","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"θ_i is the volumetric ice fraction, and","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ν  denotes parameters relating to soil type, such as porosity.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"We will solve this equation in an effectively 1-d domain with z  -10, and with the following boundary and initial conditions:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"- κ T(t z = 0) = 0 z","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"-κ T(t z = -1) = 0 z","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"T(t = 0 z) = T_min + (T_max-T_min) e^Cz","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"- K h(t z = 0) = 0 z","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"-K h(t z = -1) = 0 z","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ϑ(t = 0 z) = ϑ_min + (ϑ_max-ϑ_min) e^Cz","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"where C T_min T_max ϑ_min and ϑ_max are constants.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"If we evolve this system for times long compared to the dynamical timescales of the system, we expect it to reach an equilibrium where the LHS of these equations tends to zero. Assuming zero fluxes at the boundaries, the resulting equilibrium state should satisfy hz = 0 and Tz = 0. Physically, this means that the water settles into a vertical profile in which the resulting pressure balances gravity and that the temperature is constant across the domain.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"We verify that the system is approaching this equilibrium, and we also sketch out an analytic calculation for the final temperature in equilibrium.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#Import-necessary-modules","page":"Coupled Water and Heat","title":"Import necessary modules","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"External (non - CliMA) modules","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"using MPI\nusing OrderedCollections\nusing StaticArrays\nusing Statistics\nusing Plots","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"CliMA Parameters","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"using CLIMAParameters\nusing CLIMAParameters.Planet: ρ_cloud_liq, ρ_cloud_ice, cp_l, cp_i, T_0, LH_f0","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ClimateMachine modules","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"using ClimateMachine\nusing ClimateMachine.Land\nusing ClimateMachine.Land.SoilWaterParameterizations\nusing ClimateMachine.Land.SoilHeatParameterizations\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.Diagnostics\nusing ClimateMachine.ConfigTypes\nusing ClimateMachine.DGMethods\nusing ClimateMachine.DGMethods.NumericalFluxes\nusing ClimateMachine.DGMethods: BalanceLaw, LocalGeometry\nusing ClimateMachine.MPIStateArrays\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.VariableTemplates\nusing ClimateMachine.SingleStackUtils\nusing ClimateMachine.BalanceLaws:\n    BalanceLaw, Prognostic, Auxiliary, Gradient, GradientFlux, vars_state","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#Preliminary-set-up","page":"Coupled Water and Heat","title":"Preliminary set-up","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Get the parameter set, which holds constants used across CliMA models:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"struct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet();\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Initialize and pick a floating point precision:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ClimateMachine.init()\nFT = Float64;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Load a function that will interpolate output of simulation:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"const clima_dir = dirname(dirname(pathof(ClimateMachine)));\ninclude(joinpath(\n    clima_dir,\n    \"tutorials\",\n    \"Land\",\n    \"Soil\",\n    \"interpolation_helper.jl\",\n));\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Set soil parameters to be consistent with sand. Please see e.g. the soil heat tutorial for other soil type parameters, or [2].","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"The porosity:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"porosity = FT(0.395);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Soil solids are the components of soil besides water, ice, gases, and air. We specify the soil component fractions, relative to all soil solids. These should sum to unity; they do not account for pore space.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ν_ss_quartz = FT(0.92)\nν_ss_minerals = FT(0.08)\nν_ss_om = FT(0.0)\nν_ss_gravel = FT(0.0);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Other parameters include the hydraulic conductivity at saturation, the specific storage, and the van Genuchten parameters for sand. We recommend Chapter 8 of [1] for finding parameters for other soil types.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Ksat = FT(4.42 / 3600 / 100) # m/s\nS_s = FT(1e-3) #inverse meters\nvg_n = FT(1.89)\nvg_α = FT(7.5); # inverse meters\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Other constants needed:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"κ_quartz = FT(7.7) # W/m/K\nκ_minerals = FT(2.5) # W/m/K\nκ_om = FT(0.25) # W/m/K\nκ_liq = FT(0.57) # W/m/K\nκ_ice = FT(2.29); # W/m/K\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"The particle density of organic material-free soil is equal to the particle density of quartz and other minerals [3]:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ρp = FT(2700); # kg/m^3\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"We calculate the thermal conductivities for the solid material and for saturated soil. These functions are taken from Balland and Arp (2005) [3].","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"κ_solid = k_solid(ν_ss_om, ν_ss_quartz, κ_quartz, κ_minerals, κ_om)\nκ_sat_frozen = ksat_frozen(κ_solid, porosity, κ_ice)\nκ_sat_unfrozen = ksat_unfrozen(κ_solid, porosity, κ_liq);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Next, we calculate the volumetric heat capacity of dry soil. Dry soil refers to soil that has no water content.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ρc_ds = FT((1 - porosity) * 1.926e06); # J/m^3/K\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"We collect the majority of the parameters needed for modeling heat and water flow in soil in soil_param_functions. The van Genuchten parameters are stored in the water model, in an object called hydraulics, however.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"soil_param_functions = SoilParamFunctions{FT}(\n    Ksat = Ksat,\n    S_s = S_s,\n    porosity = porosity,\n    ν_ss_gravel = ν_ss_gravel,\n    ν_ss_om = ν_ss_om,\n    ν_ss_quartz = ν_ss_quartz,\n    ρc_ds = ρc_ds,\n    ρp = ρp,\n    κ_solid = κ_solid,\n    κ_sat_unfrozen = κ_sat_unfrozen,\n    κ_sat_frozen = κ_sat_frozen,\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#Initial-and-Boundary-conditions","page":"Coupled Water and Heat","title":"Initial and Boundary conditions","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"The initial temperature profile:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"function T_init(aux)\n    FT = eltype(aux)\n    zmax = FT(0)\n    zmin = FT(-1)\n    T_max = FT(289.0)\n    T_min = FT(288.0)\n    c = FT(20.0)\n    z = aux.z\n    output = T_min + (T_max - T_min) * exp(-(z - zmax) / (zmin - zmax) * c)\n    return output\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"The initial water profile:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"function ϑ_l0(aux)\n    FT = eltype(aux)\n    zmax = FT(0)\n    zmin = FT(-1)\n    theta_max = FT(porosity * 0.5)\n    theta_min = FT(porosity * 0.4)\n    c = FT(20.0)\n    z = aux.z\n    output =\n        theta_min +\n        (theta_max - theta_min) * exp(-(z - zmax) / (zmin - zmax) * c)\n    return output\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"The boundary value problem in this case requires a boundary condition at the top and the bottom of the domain for each equation being solved. These conditions can be Dirichlet, or Neumann.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Dirichlet boundary conditions are on ϑ_l and T, while Neumann boundary conditions are on -κ∇T and -K∇h. For Neumann conditions, the user supplies a scalar, which is multiplied by ẑ within the code.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"The user should set the unused fields to nothing to indicate that they do not want to supply a boundary condition of that type. For example, below we indicate that we are applying (and supplying!) Neumann conditions for each variable at the top and the bottom of the domain.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Water boundary conditions:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"surface_water_flux = (aux, t) -> eltype(aux)(0.0)\nbottom_water_flux = (aux, t) -> eltype(aux)(0.0)\nsurface_water_state = nothing\nbottom_water_state = nothing;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"As we are not including the equations for phase changes in this tutorial, we chose temperatures that are above the freezing point of water.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"The boundary conditions for the heat equation:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"surface_heat_flux = (aux, t) -> eltype(aux)(0.0)\nbottom_heat_flux = (aux, t) -> eltype(aux)(0.0)\nsurface_heat_state = nothing\nbottom_heat_state = nothing;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Next, we define the required init_soil! function, which takes the user specified functions of space for T_init and ϑ_l0 and initializes the state variables of volumetric internal energy and augmented liquid fraction. This requires a conversion from T to ρe_int.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"function init_soil!(land, state, aux, localgeo, time)\n    myFT = eltype(state)\n    ϑ_l = myFT(land.soil.water.initialϑ_l(aux))\n    θ_i = myFT(land.soil.water.initialθ_i(aux))\n    state.soil.water.ϑ_l = ϑ_l\n    state.soil.water.θ_i = θ_i\n\n    θ_l = volumetric_liquid_fraction(ϑ_l, land.soil.param_functions.porosity)\n    ρc_ds = land.soil.param_functions.ρc_ds\n    ρc_s = volumetric_heat_capacity(θ_l, θ_i, ρc_ds, land.param_set)\n\n    state.soil.heat.ρe_int = volumetric_internal_energy(\n        θ_i,\n        ρc_s,\n        land.soil.heat.initialT(aux),\n        land.param_set,\n    )\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#Create-the-soil-model-structure","page":"Coupled Water and Heat","title":"Create the soil model structure","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"First, for water (this is where the van Genuchten parameters are supplied):","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"soil_water_model = SoilWaterModel(\n    FT;\n    viscosity_factor = TemperatureDependentViscosity{FT}(),\n    moisture_factor = MoistureDependent{FT}(),\n    hydraulics = vanGenuchten{FT}(α = vg_α, n = vg_n),\n    initialϑ_l = ϑ_l0,\n    dirichlet_bc = Dirichlet(\n        surface_state = surface_water_state,\n        bottom_state = bottom_water_state,\n    ),\n    neumann_bc = Neumann(\n        surface_flux = surface_water_flux,\n        bottom_flux = bottom_water_flux,\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Note that the viscosity of water depends on temperature. We account for the effect that has on the hydraulic conductivity by specifying viscosity_factor = TemperatureDependentViscosity{FT}(). The default, if no viscosity_factor keyword argument is supplied, is to not include the effect of T on viscosity. More guidance about specifying the hydraulic conductivity, and the hydraulics model, can be found in the hydraulic functions tutorial.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Repeat for heat:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"soil_heat_model = SoilHeatModel(\n    FT;\n    initialT = T_init,\n    dirichlet_bc = Dirichlet(\n        surface_state = surface_heat_state,\n        bottom_state = bottom_heat_state,\n    ),\n    neumann_bc = Neumann(\n        surface_flux = surface_heat_flux,\n        bottom_flux = bottom_heat_flux,\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Combine into a single soil model:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"m_soil = SoilModel(soil_param_functions, soil_water_model, soil_heat_model);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"We aren't using any sources or sinks in the equations here, but this is where freeze/thaw terms, runoff, root extraction, etc. would go.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"sources = ();\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Create the LandModel - without other components (canopy, carbon, etc):","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"m = LandModel(\n    param_set,\n    m_soil;\n    source = sources,\n    init_state_prognostic = init_soil!,\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#Specify-the-numerical-details","page":"Coupled Water and Heat","title":"Specify the numerical details","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Choose a resolution, domain boundaries, integration time, timestep, and ODE solver.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"N_poly = 1\nnelem_vert = 50\nzmin = FT(-1)\nzmax = FT(0)\n\ndriver_config = ClimateMachine.SingleStackConfiguration(\n    \"LandModel\",\n    N_poly,\n    nelem_vert,\n    zmax,\n    param_set,\n    m;\n    zmin = zmin,\n    numerical_flux_first_order = CentralNumericalFluxFirstOrder(),\n)\n\nt0 = FT(0)\ntimeend = FT(60 * 60 * 72)\ndt = FT(30.0)\n\n\nsolver_config =\n    ClimateMachine.SolverConfiguration(t0, timeend, driver_config, ode_dt = dt);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Determine how often you want output:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"const n_outputs = 4\nconst every_x_simulation_time = ceil(Int, timeend / n_outputs);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Create a place to store this output, and determine which indices in the state vector correspond to the variables we are interested in:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"all_data = Dict([k => Dict() for k in 1:n_outputs]...)\n\nK∇h_vert_ind = varsindex(vars_state(m, GradientFlux(), FT), :soil, :water)[3]\nκ∇T_vert_ind = varsindex(vars_state(m, GradientFlux(), FT), :soil, :heat)[3]\nϑ_l_ind = varsindex(vars_state(m, Prognostic(), FT), :soil, :water, :ϑ_l)\nT_ind = varsindex(vars_state(m, Auxiliary(), FT), :soil, :heat, :T)\nz_ind = varsindex(vars_state(m, Auxiliary(), FT), :z)\n\nt = ODESolvers.gettime(solver_config.solver)\nthegrid = solver_config.dg.grid\nQ = solver_config.Q;\naux = solver_config.dg.state_auxiliary;\ngrads = solver_config.dg.state_gradient_flux\nϑ_l = Q[:, ϑ_l_ind, :][:]\nz = aux[:, z_ind, :][:]\nT = aux[:, T_ind, :][:];\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Gradients aren't calculated until the integration starts; we would need to use the specified inital conditions to determine them. However, we care more about showing that they tend to zero over time, as the system approaches equlibrium, so we won't calculate them.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Save initial condition:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"initial_state = Dict{String, Array}(\n    \"t\" => [t],\n    \"ϑ_l\" => ϑ_l,\n    \"T\" => T,\n    \"K∇h_vert\" => [nothing],\n    \"κ∇T_vert\" => [nothing],\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"We specify a function which evaluates every_x_simulation_time and returns the state vector, appending the variables we are interested in into all_data.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"We also create an additional cartesian grid upon which an interpolated solution of the DG output is evaluated. This is useful because the DG output is multi-valued at element boundaries.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"zres = FT(0.02)\nboundaries = [\n    FT(0) FT(0) zmin\n    FT(1) FT(1) zmax\n]\nresolution = (FT(2), FT(2), zres)\nthegrid = solver_config.dg.grid\nintrp_brck = create_interpolation_grid(boundaries, resolution, thegrid)\nstep = [1];\ncallback = GenericCallbacks.EveryXSimulationTime(\n    every_x_simulation_time,\n) do (init = false)\n    t = ODESolvers.gettime(solver_config.solver)\n    iQ, iaux, igrads = interpolate_variables((Q, aux, grads), intrp_brck)\n    ϑ_l = iQ[:, ϑ_l_ind, :][:]\n    T = iaux[:, T_ind, :][:]\n    K∇h_vert = igrads[:, K∇h_vert_ind, :][:]\n    κ∇T_vert = igrads[:, κ∇T_vert_ind, :][:]\n    all_vars = Dict{String, Array}(\n        \"t\" => [t],\n        \"ϑ_l\" => ϑ_l,\n        \"T\" => T,\n        \"K∇h_vert\" => K∇h_vert,\n        \"κ∇T_vert\" => κ∇T_vert,\n    )\n    all_data[step[1]] = all_vars\n\n    step[1] += 1\n    nothing\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#Run-the-integration","page":"Coupled Water and Heat","title":"Run the integration","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"ClimateMachine.invoke!(solver_config; user_callbacks = (callback,));\nnothing #hide","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Get the final state and create plots:","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"t = ODESolvers.gettime(solver_config.solver)\niQ, iaux, igrads = interpolate_variables((Q, aux, grads), intrp_brck)\n\nϑ_l = iQ[:, ϑ_l_ind, :][:]\nT = iaux[:, T_ind, :][:]\nK∇h_vert = igrads[:, K∇h_vert_ind, :][:]\nκ∇T_vert = igrads[:, κ∇T_vert_ind, :][:]\nall_vars = Dict{String, Array}(\n    \"t\" => [t],\n    \"ϑ_l\" => ϑ_l,\n    \"T\" => T,\n    \"K∇h_vert\" => K∇h_vert,\n    \"κ∇T_vert\" => κ∇T_vert,\n)\nall_data[n_outputs] = all_vars\niz = iaux[:, z_ind, :][:]\n\nt = [all_data[k][\"t\"][1] for k in 1:n_outputs]\nt = ceil.(Int64, t ./ 60)\n\nϑ_plot =\n    plot(initial_state[\"ϑ_l\"], z, label = \"t = 0\", ylabel = \"z\", xlabel = \"ϑ_l\")\nplot!(all_data[1][\"ϑ_l\"], iz, label = \"t = 0.75 days\")\nplot!(all_data[2][\"ϑ_l\"], iz, label = \"t = 1.5 days\")\nplot!(all_data[3][\"ϑ_l\"], iz, label = \"t = 2.25 days\")\nplot!(all_data[4][\"ϑ_l\"], iz, label = \"t = 3 days\")\n\n\nK∇h_z_plot = plot(\n    all_data[1][\"K∇h_vert\"],\n    iz,\n    label = \"0.75 days\",\n    xlabel = \"K∇h_z (m/s)\",\n)\nplot!(all_data[2][\"K∇h_vert\"], iz, label = \"1.5 days\")\nplot!(all_data[3][\"K∇h_vert\"], iz, label = \"2.25 days\")\nplot!(all_data[4][\"K∇h_vert\"], iz, label = \"3 days\")\nplot!(legend = :bottomleft)\nplot(ϑ_plot, K∇h_z_plot)\nsavefig(\"eq_moisture_plot.png\")","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"(Image: )","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"T_plot =\n    plot(initial_state[\"T\"], z, label = \"t = 0\", ylabel = \"z\", xlabel = \"T (K)\")\nplot!(all_data[1][\"T\"], iz, label = \"t = 0.75 days\")\nplot!(all_data[2][\"T\"], iz, label = \"t = 1.5 days\")\nplot!(all_data[3][\"T\"], iz, label = \"t = 2.25 days\")\nplot!(all_data[4][\"T\"], iz, label = \"t = 3 days\")\nplot!(legend = :bottomright)\n\nκ∇T_z_plot = plot(\n    all_data[1][\"κ∇T_vert\"],\n    iz,\n    label = \"0.75 days\",\n    xlabel = \"κ∇T_z (W/m^2)\",\n)\nplot!(all_data[2][\"κ∇T_vert\"], iz, label = \"1.5 days\")\nplot!(all_data[3][\"κ∇T_vert\"], iz, label = \"2.25 days\")\nplot!(all_data[4][\"κ∇T_vert\"], iz, label = \"3 days\")\nplot!(legend = :bottomright)\nplot(T_plot, κ∇T_z_plot)\nsavefig(\"eq_temperature_plot.png\")","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"(Image: )","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#Analytic-Expectations","page":"Coupled Water and Heat","title":"Analytic Expectations","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"We can determine a priori what we expect the final temperature to be in equilibrium.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Regardless of the final water profile in equilibrium, we know that the final temperature T_f will be a constant across the domain. All water that began with a temperature above this point will cool to T_f, and water that began with a temperature below this point will warm to T_f. The initial function T(z) is equal to T_f at a value of z = z̃. This is the location in space which divides these two groups (water that warms over time and water that cools over time) spatially. We can solve for z̃(T_f) using T_f = T(z̃).","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"Next, we can determine the change in energy required to cool the water above z̃ to T_f: it is the integral from z̃ to the surface at z = 0 of c θ(z) T(z), where c is the volumetric heat capacity - a constant here - and θ(z) is the initial water profile. Compute the energy required to warm the water below z̃ to T_f in a similar way, set equal, and solve for T_f. This results in T_f = 288.056, which is very close to the mean T we observe after 3 days, of 288.054.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"One could also solve the ordinary differential equation for ϑ_l specified by  h z = 0 to determine the functional form of the equilibrium profile of the liquid water.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/#References","page":"Coupled Water and Heat","title":"References","text":"","category":"section"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"[1] Bonan, G. Climate Change and Terrestrial Ecosystem Modeling (2019), Cambridge University Press","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"[2] Cosby, B. J., Hornberger, G. M., Clapp, R. B., and Ginn, T. R. (1984). A statistical exploration of the relationships of soil moisture characteristics to the physical properties of soils. Water Resources Research, 20, 682–690.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"[3] Balland and Arp (2005) Modeling soil thermal conductivities over a wide range of conditions, J. Env. Eng. Sci., 4, 549–558.","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"","category":"page"},{"location":"generated/Land/Soil/Coupled/equilibrium_test/","page":"Coupled Water and Heat","title":"Coupled Water and Heat","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/#Microphysics_0M","page":"Microphysics_0M","title":"Microphysics_0M","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"The Microphysics_0M.jl module defines a 0-moment bulk parameterization of   the moisture sink due to precipitation. It offers a simplified way of removing the excess water   without assuming anything about the size distributions of cloud   or precipitation particles.","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"The q_tot (total water specific humidity) sink due to precipitation   is obtained by relaxation with a constant timescale   to a state with condensate exceeding a threshold value removed. The threshold for removing excess q_tot is defined either by the   condensate specific humidity or supersaturation. The thresholds and the relaxation timescale are defined in   CLIMAParameters.jl.","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"note: Note\nTo remove precipitation instantly, the relaxation timescale should be equal to the timestep length.","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/#Moisture-sink-due-to-precipitation","page":"Microphysics_0M","title":"Moisture sink due to precipitation","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"If based on maximum condensate specific humidity, the sink is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"beginequation\n  left mathcalS_q_tot right_precip =-\n    fracmax(0 q_liq + q_ice - q_c0)tau_precip\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"q_liq, q_ice are cloud liquid water and cloud ice specific humidities,\nq_c0 is the condensate specific humidity threshold above which water is removed,\ntau_precip is the relaxation timescale.","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"If based on saturation excess, the sink is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"beginequation\n  left mathcalS_q_tot right_precip =-\n    fracmax(0 q_liq + q_ice - S_0  q_vap^sat)tau_precip\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"q_liq, q_ice are cloud liquid water and cloud ice specific humidities,\nS_0 is the supersaturation threshold above which water is removed,\nq_vap^sat is the saturation specific humidity,\ntau_precip is the relaxation timescale.","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/#Coupling-to-the-state-variables","page":"Microphysics_0M","title":"Coupling to the state variables","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"Following the conservation equations for moisture and mass, the mathcalS_q_tot sink has to be multiplied by rho before   adding it as one of the sink terms to both moisture and mass state variables. For the conservation equation for total energy,   no additional source/sink terms M are considered, and the   the sink due to removing q_tot is computed as:","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"beginequation\nleft sum_jinvli(I_j + Phi)  rho C(q_j rightarrow q_p) right_precip =\n  leftlambda I_l + (1 - lambda) I_i + Phi right\n  rho  leftmathcalS_q_tot right_precip\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"lambda is the liquid fraction\nI_l = c_vl (T - T_0) is the internal energy of liquid water\nI_i = c_vi (T - T_0) - I_i0 is the internal energy of ice\nT is the temperature,\nT_0 is the thermodynamic reference temperature (which is unrelated to the reference temperature used in hydrostatic reference states used in the momentum equations),\nI_i0 is the specific internal energy of ice at T_0\nc_vl and c_vi are the isochoric specific heats   of liquid water, and ice.\nPhi is the effective gravitational potential.","category":"page"},{"location":"Theory/Atmos/Microphysics_0M/","page":"Microphysics_0M","title":"Microphysics_0M","text":"This assumes that the mathcalS_q_tot sink is partitioned between the   cloud liquid water and cloud ice sinks   mathcalS_q_liq and mathcalS_q_ice based on the   cloud liquid water and cloud ice fractions.","category":"page"},{"location":"APIs/Land/LandModel/#Land-Model","page":"Land Model","title":"Land Model","text":"","category":"section"},{"location":"APIs/Land/LandModel/","page":"Land Model","title":"Land Model","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Land/LandModel/#Land-Model-2","page":"Land Model","title":"Land Model","text":"","category":"section"},{"location":"APIs/Land/LandModel/","page":"Land Model","title":"Land Model","text":"ClimateMachine.Land.LandModel","category":"page"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.LandModel","page":"Land Model","title":"ClimateMachine.Land.LandModel","text":"LandModel{PS, S, SRC, IS} <: BalanceLaw\n\nA BalanceLaw for land modeling. Users may over-ride prescribed default values for each field.\n\nUsage\n\nLandModel(\n    param_set,\n    soil,\n    source\n    init_state_prognostic\n)\n\nFields\n\nparam_set\nParameter set\nsoil\nSoil model\nsource\nSource Terms (Problem specific source terms)\ninit_state_prognostic\nInitial Condition (Function to assign initial values of state variables)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/LandModel/#Soil","page":"Land Model","title":"Soil","text":"","category":"section"},{"location":"APIs/Land/LandModel/","page":"Land Model","title":"Land Model","text":"ClimateMachine.Land.SoilModel\nClimateMachine.Land.SoilWaterModel\nClimateMachine.Land.PrescribedWaterModel\nClimateMachine.Land.SoilHeatModel\nClimateMachine.Land.PrescribedTemperatureModel\nClimateMachine.Land.SoilWaterParameterizations\nClimateMachine.Land.SoilHeatParameterizations\nClimateMachine.Land.SoilParamFunctions\nClimateMachine.Land.get_water_content","category":"page"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.SoilModel","page":"Land Model","title":"ClimateMachine.Land.SoilModel","text":"SoilModel{PF, W, H} <: BalanceLaw\n\nA BalanceLaw for soil modeling. Users may over-ride prescribed default values for each field.\n\nUsage\n\nSoilModel(\n    param_functions,\n    water,\n    heat,\n)\n\nFields\n\nparam_functions\nSoil Parameter Functions\nwater\nWater model\nheat\nHeat model\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.SoilWaterModel","page":"Land Model","title":"ClimateMachine.Land.SoilWaterModel","text":"SoilWaterModel{FT, IF, VF, MF, HM, Fiϑl, Fiθi, BCD, BCN} <: AbstractWaterModel\n\nThe necessary components for solving the equations for water (liquid or ice) in soil. \n\nWithout freeze/thaw source terms added (separately), this model reduces to Richard's equation for liquid water. Note that the default for θ_i is zero.  Without freeze/thaw source terms added to both the liquid and ice equations,  the default should never be changed, because we do not enforce that the total  volumetric water fraction is less than or equal to porosity otherwise.\n\nWhen freeze/thaw source terms are included, this model encompasses water in both liquid and ice form, and water content is conserved upon phase change. \n\nFields\n\nimpedance_factor\nImpedance Factor - will be 1 or ice dependent\nviscosity_factor\nViscosity Factor - will be 1 or temperature dependent\nmoisture_factor\nMoisture Factor - will be 1 or moisture dependent\nhydraulics\nHydraulics Model - used in matric potential and moisture factor of hydraulic conductivity\ninitialϑ_l\nInitial condition: augmented liquid fraction\ninitialθ_i\nInitial condition: volumetric ice fraction\ndirichlet_bc\nDirichlet boundary condition structure\nneumann_bc\nNeumann boundary condition  structure\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.PrescribedWaterModel","page":"Land Model","title":"ClimateMachine.Land.PrescribedWaterModel","text":"PrescribedWaterModel{F1, F2} <: AbstractWaterModel\n\nModel structure for a prescribed water content model.\n\nThe user supplies functions of space and time for both ϑ_l and θ_i. No auxiliary or state variables are added, no PDE is solved.  The defaults are no moisture anywhere, for all time. \n\nFields\n\nϑ_l\nAugmented liquid fraction\nθ_i\nVolumetric fraction of ice\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.SoilHeatModel","page":"Land Model","title":"ClimateMachine.Land.SoilHeatModel","text":"SoilHeatModel{FT, FiT, BCD, BCN} <: AbstractHeatModel\n\nThe necessary components for the Heat Equation in a soil water matrix.\n\nFields\n\ninitialT\nInitial conditions for temperature\ndirichlet_bc\nDirichlet BC structure\nneumann_bc\nNeumann BC structure\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.PrescribedTemperatureModel","page":"Land Model","title":"ClimateMachine.Land.PrescribedTemperatureModel","text":"PrescribedTemperatureModel{F1} <: AbstractHeatModel\n\nModel structure for a prescribed temperature model.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.SoilWaterParameterizations","page":"Land Model","title":"ClimateMachine.Land.SoilWaterParameterizations","text":"SoilWaterParameterizations\n\nvan Genuchten, Brooks and Corey, and Haverkamp parameters for and formulation of\n\nhydraulic conductivity\nmatric potential\n\nHydraulic conductivity can be chosen to be dependent or independent of  impedance, viscosity and moisture.\n\nFunctions for hydraulic head, effective saturation, pressure head, matric  potential, and the relationship between augmented liquid fraction and liquid fraction are also included.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.SoilHeatParameterizations","page":"Land Model","title":"ClimateMachine.Land.SoilHeatParameterizations","text":"SoilHeatParameterizations\n\nFunctions for volumetric heat capacity, temperature as a function of volumetric internal energy, saturated thermal conductivity, thermal conductivity, relative saturation and the Kersten number are included. Heat capacities denoted by ρc_ are volumetric, while cp_ denotes an isobaric specific heat capacity.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.SoilParamFunctions","page":"Land Model","title":"ClimateMachine.Land.SoilParamFunctions","text":"SoilParamFunctions{FT} <: AbstractSoilParameterFunctions{FT}\n\nNecessary parameters for the soil model. These will eventually be prescribed functions of space (and time).\n\nFields\n\nporosity\nAggregate porosity of the soil\nKsat\nHydraulic conductivity at saturation. Units of m s-1.\nS_s\nSpecific storage of the soil. Units of m s-1.\nν_ss_gravel\nVolume fraction of gravels, relative to soil solids only. Units of m-3 m-3.\nν_ss_om\nVolume fraction of SOM, relative to soil solids only. Units of m-3 m-3.\nν_ss_quartz\nVolume fraction of quartz, relative to soil solids only. Units of m-3 m-3.\nρc_ds\nBulk volumetric heat capacity of dry soil. Units of J m-3 K-1.\nρp\nParticle density for soil solids. Units of kg/m^3\nκ_solid\nThermal conductivity of the soil solids. Units of W m-1 K-1.\nκ_sat_unfrozen\nSaturated thermal conductivity for unfrozen soil. Units of W m-1 K-1.\nκ_sat_frozen\nSaturated thermal conductivity for frozen soil. Units of W m-1 K-1.\na\nAdjustable scale parameter for determining Kersten number in the Balland and Arp formulation; unitless.\nb\nAdjustable scale parameter for determining Kersten number in the Balland and Arp formulation; unitless.\nκ_dry_parameter\nParameter used in the Balland and Arp formulation for κ_dry; unitless\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.get_water_content","page":"Land Model","title":"ClimateMachine.Land.get_water_content","text":"get_water_content(\n    water::SoilWaterModel,\n    aux::Vars,\n    state::Vars,\n    t::Real\n)\n\nReturn the moisture variables for the balance law soil water model.\n\n\n\n\n\nget_water_content(\n    water::PrescribedWaterModel,\n    aux::Vars,\n    state::Vars,\n    t::Real\n)\n\nReturn the moisture variables for the prescribed soil water model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Land/LandModel/#Boundary-Conditions","page":"Land Model","title":"Boundary Conditions","text":"","category":"section"},{"location":"APIs/Land/LandModel/","page":"Land Model","title":"Land Model","text":"ClimateMachine.Land.Dirichlet\nClimateMachine.Land.Neumann","category":"page"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.Dirichlet","page":"Land Model","title":"ClimateMachine.Land.Dirichlet","text":"struct Dirichlet{Fs, Fb} <: AbstractBoundaryFunctions\n\nA concrete type to hold the surface state and bottom state variable  values/functions, if Dirichlet boundary conditions are desired.\n\nFields\n\nsurface_state\nSurface state boundary condition\nbottom_state\nBottom state boundary condition\n\n\n\n\n\n","category":"type"},{"location":"APIs/Land/LandModel/#ClimateMachine.Land.Neumann","page":"Land Model","title":"ClimateMachine.Land.Neumann","text":"struct Neumann{Fs, Fb} <: AbstractBoundaryFunctions\n\nA concrete type to hold the surface and/or bottom diffusive flux  values/functions, if Neumann boundary conditions are desired.\n\nNote that these are intended to be scalar values. In the boundary_state! functions, they are multiplied by the ẑ vector (i.e. the normal vector n̂ to the domain at the upper boundary, and -n̂ at the lower boundary. These normal vectors point out of the domain.)\n\nFields\n\nsurface_flux\nSurface flux boundary condition\nbottom_flux\nBottom flux boundary condition\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#Balance-Laws","page":"Balance Laws","title":"Balance Laws","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"CurrentModule = ClimateMachine.BalanceLaws","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#The-balance-law","page":"Balance Laws","title":"The balance law","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"BalanceLaw","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.BalanceLaw","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.BalanceLaw","text":"abstract type BalanceLaw end\n\nAn abstract type representing a PDE balance law of the form:\n\nfracdqdt = nabla cdot F_1(q a t) + nabla cdot F_2(q nabla g h a t) + S(q nabla g a t)\n\nwhere:\n\nq is the prognostic state,\na is the auxiliary state,\ng = G(q a t) is the gradient state (variables of which we compute the gradient),\nh is the hyperdiffusive state.\n\nSubtypes of BalanceLaw should define the following interfaces:\n\nvars_state to define the prognostic, auxiliary and intermediate variables.\nflux_first_order! to compute F_1\nflux_second_order! to compute F_2\nsource! to compute S\n\nIf vars(bl, ::GradientFlux, FT) is non-empty, then the following should be defined:\n\ncompute_gradient_argument! to compute G\ncompute_gradient_flux! is a linear transformation of nabla g\n\nIf vars(bl, ::Hyperdiffusive, FT) is non-empty, then the following should be defined:\n\ntransform_post_gradient_laplacian!\n\nAdditional functions:\n\nwavespeed if using the Rusanov numerical flux.\nboundary_state! if using non-periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#State-variable-types","page":"Balance Laws","title":"State variable types","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"AbstractStateType\nPrognostic\nAuxiliary\nGradient\nGradientFlux\nGradientLaplacian\nHyperdiffusive\nUpwardIntegrals\nDownwardIntegrals","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.AbstractStateType","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.AbstractStateType","text":"AbstractStateType\n\nSubtypes of this describe the variables used by different parts of a BalanceLaw:\n\nPrognostic\nAuxiliary\nGradient\nGradientFlux\nGradientLaplacian\nHyperdiffusive\nUpwardIntegrals\nDownwardIntegrals\n\nSee also vars_state.\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.Prognostic","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.Prognostic","text":"Prognostic <: AbstractStateType\n\nPrognostic variables in the PDE system, which are specified by the BalanceLaw, and solved for by the ODE solver.\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.Auxiliary","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.Auxiliary","text":"Auxiliary <: AbstractStateType\n\nAuxiliary variables help serve several purposes:\n\nPre-compute and store \"expensive\" variables, for example, quantities computed in vertical integrals.\nDiagnostic exports\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.Gradient","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.Gradient","text":"Gradient <: AbstractStateType\n\nVariables whose gradients must be computed.\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.GradientFlux","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.GradientFlux","text":"GradientFlux <: AbstractStateType\n\nFlux variables, which are functions of gradients.\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.GradientLaplacian","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.GradientLaplacian","text":"GradientLaplacian <: AbstractStateType\n\nGradient-Laplacian variables.\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.Hyperdiffusive","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.Hyperdiffusive","text":"Hyperdiffusive <: AbstractStateType\n\nHyper-diffusive variables\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.UpwardIntegrals","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.UpwardIntegrals","text":"UpwardIntegrals <: AbstractStateType\n\nVariables computed in upward integrals\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.DownwardIntegrals","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.DownwardIntegrals","text":"DownwardIntegrals <: AbstractStateType\n\nVariables computed in downward integrals\n\n\n\n\n\n","category":"type"},{"location":"APIs/BalanceLaws/BalanceLaws/#Variable-specification-methods","page":"Balance Laws","title":"Variable specification methods","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"vars_state","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.vars_state","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.vars_state","text":"BalanceLaws.vars_state(::BL, ::AbstractStateType, FT)\n\nDefines the state variables of a BalanceLaw subtype BL with floating point type FT.\n\nFor each AbstractStateType, this should return a NamedTuple type, with element type either FT, an SArray with element type FT or another NamedTuple satisfying the same property.\n\nFor convenience, we recommend using the VariableTemplates.@vars macro.\n\nExample\n\nstruct MyBalanceLaw <: BalanceLaw end\n\nBalanceLaws.vars_state(::MyBalanceLaw, ::Prognostic, FT) =\n    @vars(x::FT, y::SVector{3, FT})\nBalanceLaws.vars_state(::MyBalanceLaw, ::Auxiliary, FT) =\n    @vars(components::@vars(a::FT, b::FT))\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#Initial-condition-methods","page":"Balance Laws","title":"Initial condition methods","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"init_state_prognostic!\ninit_state_auxiliary!\nnodal_init_state_auxiliary!","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.init_state_prognostic!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.init_state_prognostic!","text":"init_state_prognostic!(\n    ::BL,\n    state_prognostic::Vars,\n    state_auxiliary::Vars,\n    localgeo,\n    args...,\n)\n\nSets the initial state of the prognostic variables state_prognostic at each node for a BalanceLaw subtype BL.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.init_state_auxiliary!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.init_state_auxiliary!","text":"init_state_auxiliary!(::HBModel)\n\nsets the initial value for auxiliary variables (those that aren't related to vertical integrals) dispatches to oceaninitaux! which is defined in a problem file such as SimpleBoxProblem.jl\n\n\n\n\n\nNo need to init, initialize by full model\n\n\n\n\n\ninit_state_auxiliary!(\n    m::AtmosModel,\n    aux::Vars,\n    grid,\n    direction\n)\n\nInitialise auxiliary variables for each AtmosModel subcomponent. Store Cartesian coordinate information in aux.coord.\n\n\n\n\n\ninit_state_auxiliary!(\n    ::BL,\n    statearray_auxiliary,\n    geom::LocalGeometry,\n)\n\nSets the initial state of the auxiliary variables state_auxiliary at each node for a BalanceLaw subtype BL. By default this calls nodal_init_state_auxiliary!.\n\n\n\n\n\ninit_state_auxiliary!(\n    bl::BalanceLaw,\n    f!, \n    statearray_auxiliary,\n    grid,\n    direction;\n    state_temporary = nothing\n)\n\nApply f!(bl, state_auxiliary, tmp, geom) at each node, storing the result in statearray_auxiliary, where tmp are the values at the corresponding node in state_temporary and geom contains the geometry information.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.nodal_init_state_auxiliary!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.nodal_init_state_auxiliary!","text":"nodal_init_state_auxiliary!(::BL, state_auxiliary, state_temporary, geom)\n\nSets the initial state of the auxiliary variables state_auxiliary at each node for a BalanceLaw subtype BL.\n\nSee also init_state_auxiliary!.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#Source-term-kernels","page":"Balance Laws","title":"Source term kernels","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"flux_first_order!\nflux_second_order!\nsource!","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.flux_first_order!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.flux_first_order!","text":"flux_first_order!(\n    ::BL,\n    flux::Grad,\n    state_prognostic::Vars,\n    state_auxiliary::Vars,\n    t::Real,\n    direction\n)\n\nSets the first-order (hyperbolic) flux terms for a BalanceLaw subtype BL.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.flux_second_order!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.flux_second_order!","text":"flux_second_order!(\n    ::BL,\n    flux::Grad,\n    state_prognostic::Vars,\n    state_gradient_flux::Vars,\n    hyperdiffusive::Vars,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nSets second-order (parabolic) flux terms for a BalanceLaw subtype BL.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.source!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.source!","text":"source!(\n    ::BL,\n    source::Vars,\n    state_prognostic::Vars,\n    diffusive::Vars,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nCompute non-conservative source terms for a BalanceLaw subtype BL.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#Integral-kernels","page":"Balance Laws","title":"Integral kernels","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"indefinite_stack_integral!\nreverse_indefinite_stack_integral!\nintegral_load_auxiliary_state!\nintegral_set_auxiliary_state!\nreverse_integral_load_auxiliary_state!\nreverse_integral_set_auxiliary_state!","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.indefinite_stack_integral!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.indefinite_stack_integral!","text":"indefinite_stack_integral!\n\nCompute indefinite integral along stack.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.reverse_indefinite_stack_integral!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.reverse_indefinite_stack_integral!","text":"reverse_indefinite_stack_integral!\n\nCompute reverse indefinite integral along stack.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.integral_load_auxiliary_state!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.integral_load_auxiliary_state!","text":"integral_load_auxiliary_state!(::BL, integrand, state_prognostic, state_aux)\n\nSpecify variables integrand which will have their upward integrals computed.\n\nSee also UpwardIntegrals\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.integral_set_auxiliary_state!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.integral_set_auxiliary_state!","text":"integral_set_auxiliary_state!(::BL, state_aux, integral)\n\nUpdate auxiliary variables based on the upward integral integral defined in integral_load_auxiliary_state!.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.reverse_integral_load_auxiliary_state!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.reverse_integral_load_auxiliary_state!","text":"reverse_integral_load_auxiliary_state!(::BL, integrand, state_prognostic, state_aux)\n\nSpecify variables integrand which will have their downward integrals computed.\n\nSee also DownwardIntegrals\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.reverse_integral_set_auxiliary_state!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.reverse_integral_set_auxiliary_state!","text":"reverse_integral_set_auxiliary_state!(::BL, state_aux, integral)\n\nUpdate auxiliary variables based on the downward integral integral defined in reverse_integral_load_auxiliary_state!.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#Gradient/Laplacian-kernels","page":"Balance Laws","title":"Gradient/Laplacian kernels","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"compute_gradient_flux!\ncompute_gradient_argument!\ntransform_post_gradient_laplacian!","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.compute_gradient_flux!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.compute_gradient_flux!","text":"compute_gradient_flux!(\n    ::BL,\n    state_gradient_flux::Vars,\n    ∇transformstate::Grad,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nTransformation of gradients to the diffusive variables for a BalanceLaw subtype BL. This should be a linear function of ∇transformstate\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.compute_gradient_argument!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.compute_gradient_argument!","text":"compute_gradient_argument!(\n    ::BL,\n    transformstate::Vars,\n    state_prognostic::Vars,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nTransformation of state variables state_prognostic to variables transformstate of which gradients are computed for a BalanceLaw subtype BL.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.transform_post_gradient_laplacian!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.transform_post_gradient_laplacian!","text":"transform_post_gradient_laplacian!(\n    ::BL,\n    Qhypervisc_div::Vars,\n    ∇Δtransformstate::Grad,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nTransformation of Laplacian gradients to the hyperdiffusive variables for a BalanceLaw subtype BL.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#Auxiliary-kernels","page":"Balance Laws","title":"Auxiliary kernels","text":"","category":"section"},{"location":"APIs/BalanceLaws/BalanceLaws/","page":"Balance Laws","title":"Balance Laws","text":"wavespeed\nboundary_state!\nupdate_auxiliary_state!\nupdate_auxiliary_state_gradient!\nnodal_update_auxiliary_state!","category":"page"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.wavespeed","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.wavespeed","text":"wavespeed(\n    ::BL,\n    n⁻,\n    state_prognostic::Vars,\n    state_auxiliary::Vars,\n    t::Real,\n    direction\n)\n\nWavespeed in the direction n⁻ for a BalanceLaw subtype BL. This is required to be defined if using a RusanovNumericalFlux numerical flux.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.boundary_state!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.boundary_state!","text":"boundary_state!(\n    ::NumericalFluxGradient,\n    ::L,\n    state_prognostic⁺::Vars,\n    state_auxiliary⁺::Vars,\n    normal⁻,\n    state_prognostic⁻::Vars,\n    state_auxiliary⁻::Vars,\n    bctype,\n    t\n)\nboundary_state!(\n    ::NumericalFluxFirstOrder,\n    ::L,\n    state_prognostic⁺::Vars,\n    state_auxiliary⁺::Vars,\n    normal⁻,\n    state_prognostic⁻::Vars,\n    state_auxiliary⁻::Vars,\n    bctype,\n    t\n)\nboundary_state!(\n    ::NumericalFluxSecondOrder,\n    ::L,\n    state_prognostic⁺::Vars,\n    state_gradient_flux⁺::Vars,\n    state_auxiliary⁺:\n    Vars, normal⁻,\n    state_prognostic⁻::Vars,\n    state_gradient_flux⁻::Vars,\n    state_auxiliary⁻::Vars,\n    bctype,\n    t\n)\n\nApply boundary conditions for\n\nNumericalFluxGradient numerical flux (internal method)\nNumericalFluxFirstOrder first-order unknowns\nNumericalFluxSecondOrder second-order unknowns\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.update_auxiliary_state!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.update_auxiliary_state!","text":"update_auxiliary_state!(::HBModel)\n\napplies the vertical filter to the zonal and meridional velocities to preserve numerical incompressibility\napplies an exponential filter to θ to anti-alias the non-linear advective term\n\ndoesn't actually touch the aux variables any more, but we need a better filter interface than this anyways\n\n\n\n\n\nupdate_auxiliary_state!(\n    dg::DGModel,\n    m::BalanceLaw,\n    statearray_aux,\n    t::Real,\n    elems::UnitRange,\n    [diffusive=false]\n)\n\nHook to update the auxiliary state variables before calling any other functions.\n\nBy default, this calls nodal_update_auxiliary_state! at each node.\n\nIf diffusive=true, then state_gradflux is also passed to nodal_update_auxiliary_state!.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.update_auxiliary_state_gradient!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.update_auxiliary_state_gradient!","text":"update_auxiliary_state_gradient!(\n    dg::DGModel,\n    m::BalanceLaw,\n    statearray_aux,\n    t::Real,\n    elems::UnitRange,\n    [diffusive=false]\n)\n\nHook to update the auxiliary state variables after the gradient computation.\n\nBy default, this calls nothing.\n\nIf diffusive=true, then state_gradflux is also passed to nodal_update_auxiliary_state!.\n\n\n\n\n\n","category":"function"},{"location":"APIs/BalanceLaws/BalanceLaws/#ClimateMachine.BalanceLaws.nodal_update_auxiliary_state!","page":"Balance Laws","title":"ClimateMachine.BalanceLaws.nodal_update_auxiliary_state!","text":"nodal_update_auxiliary_state!(::BL, state_prognostic, state_auxiliary, [state_gradflux,] t)\n\nUpdate the auxiliary state variables at each node for a BalanceLaw subtype BL. By default it does nothing.\n\nCalled by update_auxiliary_state!.\n\n\n\n\n\n","category":"function"},{"location":"Theory/Atmos/Model/tracers/#Tracers-docs","page":"Tracers","title":"Tracers","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"note: Note\nUsage: Enable tracers using a keyword argument in the AtmosModel specification\n- tracers = NoTracer()\n- tracers = NTracers{N, FT}(δ_χ) where N is the number of tracers required.\nFT is the float-type and delta_chi is an SVector of diffusivity scaling coefficients","category":"page"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"note: Note\nHyperdiffusion is currently not supported with tracers. Laplacian diffusion coefficients may still be specified. (See above)","category":"page"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"In tracers.jl, we define the equation sets governing tracer dynamics. Specifically, we address the the equations of tracer motion in conservation form,","category":"page"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"export NoTracers, NTracers","category":"page"},{"location":"Theory/Atmos/Model/tracers/#tracer-eqns","page":"Tracers","title":"Equations","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"fracpartial rhochipartial t +  nabla cdot ( rhochi u) = nabla cdot (rhodelta_DchimathrmD_Tnablachi) + rho mathrmS","category":"page"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"where  chi represents the tracer species, mathrmS represents the tracer source terms and delta_Dchi mathrmD_T represents the scaled turbulent eddy diffusivity for each tracer.  Currently a default scaling of 1 is supported.  The equation as written above corresponds to a single scalar tracer, but can be extended to include multiple independent tracer species.","category":"page"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"We first define an abstract tracer type, and define the default function signatures. Two options are currently supported. NoTracers, and NTracers.","category":"page"},{"location":"Theory/Atmos/Model/tracers/#abstract-tracer-type","page":"Tracers","title":"Abstract Tracer Type","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"Default stub functions for a generic tracer type are defined here.","category":"page"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"abstract type TracerModel <: BalanceLaw end\n\nvars_state(::TracerModel, ::AbstractStateType, FT) = @vars()\n\nfunction atmos_init_aux!(\n    ::TracerModel,\n    ::AtmosModel,\n    aux::Vars,\n    geom::LocalGeometry,\n)\n    nothing\nend\nfunction atmos_nodal_update_auxiliary_state!(\n    ::TracerModel,\n    m::AtmosModel,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    nothing\nend\nfunction flux_tracers!(\n    ::TracerModel,\n    atmos::AtmosModel,\n    flux::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    nothing\nend\nfunction compute_gradient_flux!(\n    ::TracerModel,\n    diffusive::Vars,\n    ∇transform::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    nothing\nend\nfunction flux_second_order!(\n    ::TracerModel,\n    flux::Grad,\n    state::Vars,\n    diffusive::Vars,\n    aux::Vars,\n    t::Real,\n    D_t,\n)\n    nothing\nend\nfunction compute_gradient_argument!(\n    ::TracerModel,\n    transform::Vars,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    nothing\nend","category":"page"},{"location":"Theory/Atmos/Model/tracers/#no-tracers","page":"Tracers","title":"NoTracers","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"The default tracer type in both the LES and GCM configurations is the no tracer model. (This means no state variables for tracers are being carried around). For the purposes of this model, moist variables are considered separately in moisture.jl.","category":"page"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"ClimateMachine.Atmos.NoTracers","category":"page"},{"location":"Theory/Atmos/Model/tracers/#ClimateMachine.Atmos.NoTracers","page":"Tracers","title":"ClimateMachine.Atmos.NoTracers","text":"NoTracers <: TracerModel\n\nNo tracers. Default model.\n\n\n\n\n\n","category":"type"},{"location":"Theory/Atmos/Model/tracers/#multiple-tracers","page":"Tracers","title":"NTracers","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"Allows users to specify an integer corresponding to the number of tracers required.  Note that tracer naming is not currently supported, i.e. the user must track each tracer variable based on its numerical index. Sources can be added to each tracer based on the corresponding numerical vector index. Initial profiles must be specified using the init_state_prognostic! hook at the experiment level.","category":"page"},{"location":"Theory/Atmos/Model/tracers/","page":"Tracers","title":"Tracers","text":"ClimateMachine.Atmos.NTracers{N,FT}","category":"page"},{"location":"Theory/Atmos/Model/tracers/#ClimateMachine.Atmos.NTracers","page":"Tracers","title":"ClimateMachine.Atmos.NTracers","text":"NTracers{N, FT} <: TracerModel\n\nCurrently the simplest way to get n-tracers in an AtmosModel run using the existing machinery. Model input: SVector of diffusivity scaling coefficients. Length of SVector allows number of tracers to be inferred. Tracers are currently identified by indices.\n\nFields\n\n\n\nδ_χ\nN-component SVector with scaling ratios for tracer diffusivities\n\n\n\n\n\n","category":"type"},{"location":"APIs/Arrays/Arrays/#Arrays","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"APIs/Arrays/Arrays/","page":"Arrays","title":"Arrays","text":"CurrentModule = ClimateMachine.MPIStateArrays","category":"page"},{"location":"APIs/Arrays/Arrays/#MPI-State-Arrays","page":"Arrays","title":"MPI State Arrays","text":"","category":"section"},{"location":"APIs/Arrays/Arrays/","page":"Arrays","title":"Arrays","text":"Storage for the state of a discretization.","category":"page"},{"location":"APIs/Arrays/Arrays/","page":"Arrays","title":"Arrays","text":"MPIStateArray\nbegin_ghost_exchange!\nend_ghost_exchange!\nweightedsum","category":"page"},{"location":"APIs/Arrays/Arrays/#ClimateMachine.MPIStateArrays.MPIStateArray","page":"Arrays","title":"ClimateMachine.MPIStateArrays.MPIStateArray","text":"MPIStateArray{FT, DATN<:AbstractArray{FT,3}, DAI1, DAV,\n              DAT2<:AbstractArray{FT,2}} <: AbstractArray{FT, 3}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Arrays/Arrays/#ClimateMachine.MPIStateArrays.begin_ghost_exchange!","page":"Arrays","title":"ClimateMachine.MPIStateArrays.begin_ghost_exchange!","text":"begin_ghost_exchange!(Q::MPIStateArray; dependencies = nothing)\n\nBegin the MPI halo exchange of the data stored in Q.  A KernelAbstractions Event is returned that can be used as a dependency to end the exchange.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Arrays/Arrays/#ClimateMachine.MPIStateArrays.end_ghost_exchange!","page":"Arrays","title":"ClimateMachine.MPIStateArrays.end_ghost_exchange!","text":"end_ghost_exchange!(Q::MPIStateArray; dependencies = nothing)\n\nThis function blocks on the host until the ghost halo is received from MPI.  A KernelAbstractions Event is returned that can be waited on to indicate when the data is ready on the device.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Arrays/Arrays/#ClimateMachine.MPIStateArrays.weightedsum","page":"Arrays","title":"ClimateMachine.MPIStateArrays.weightedsum","text":"weightedsum(A[, states])\n\nCompute the weighted sum of the MPIStateArray A. If states is specified on the listed states are summed, otherwise all the states in A are used.\n\nA typical use case for this is when the weights have been initialized with quadrature weights from a grid, thus this becomes an integral approximation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Arrays/Arrays/#Buffers","page":"Arrays","title":"Buffers","text":"","category":"section"},{"location":"APIs/Arrays/Arrays/","page":"Arrays","title":"Arrays","text":"CMBuffers.CMBuffer","category":"page"},{"location":"APIs/Arrays/Arrays/#ClimateMachine.MPIStateArrays.CMBuffers.CMBuffer","page":"Arrays","title":"ClimateMachine.MPIStateArrays.CMBuffers.CMBuffer","text":"CMBuffer{T}(::Type{Arr}, kind, dims...; pinned = true)\n\nCUDA/MPI buffer abstracts storage for MPI communication. The buffer is used for staging data and for MPI transfers. When running on:\n\nCPU – a single buffer is used for staging and MPI transfers can be initiated directly to/from it.\nCUDA – either:\nMPI is CUDA-aware: a single buffer on the device for staging and MPI transfers can be initiated directly to/from it, or\nMPI is not CUDA-aware: a double buffering scheme with the staging buffer on the device and a transfer buffer on the host\n\nArguments\n\nT: element type\nArr::Type: what kind of array to allocate for stage\nkind::CMBufferKind: either SingleCMBuffer or DoubleCMBuffer\ndims...: dimensions of the array\n\n\n\n\n\n","category":"type"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Contribution-Guide-for-Abstract-Iterative-Solvers","page":"Iterative Solvers","title":"Contribution Guide for Abstract Iterative Solvers","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"CurrentModule = ClimateMachine.SystemSolvers","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"An abstract iterative solver requires one struct, one constructor, and two functions in order to interface with the rest of ClimateMachine. In what follows we will describe in detail the function signatures, return values, and struct properties necessary to build with ClimateMachine.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"We have the following concrete implementations:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"GeneralizedMinimalResidual\nGeneralizedConjugateResidual\nConjugateGradient\nBatchedGeneralizedMinimalResidual","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Basic-Template-for-an-Iterative-Solver","page":"Iterative Solvers","title":"Basic Template for an Iterative Solver","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"A basic template of an iterative solver could be as follows:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"\nexport MyIterativeMethod\n\n# struct\nstruct MyIterativeMethod{FT} <: AbstractIterativeSystemSolver\n    # minimum\n    rtol::FT\n    atol::FT\n    # Add more structure if necessary\nend\n\n# constructor\nfunction MyIterativeMethod(args...)\n    # body of constructor\n    return MyIterativeMethod(contructor_args...)\nend\n\n# initialize function (1)\nfunction initialize!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, args...)\n    # body of initialize function in abstract iterative solver\n    return Bool, Int\nend\n\n# iteration function (2)\nfunction doiteration!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, threshold, args...)\n    # body of iteration\n    return Bool, Int, Float\nend\n","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"MyIterativeMethod and function bodies would need to be replaced appropriately for a particular implementation. We will describe each component in detail in subsequent sections.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Struct","page":"Iterative Solvers","title":"Struct","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"A subset of AbstractIterativeSystemSolver needs at least two members: atol and rtol. The former represents an absolute tolerance and the latter is a relative tolerance. Both can be used to terminate the iteration to determine the convergence criteria. An example struct could be","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"struct MyIterativeMethod{FT} <: AbstractIterativeSystemSolver\n    atol::FT\n    rtol::FT\nend","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"but often has more depending on the kind of iterative solver being used.  For example, in a Krylov subspace method one would need to store a number of vectors which constitute the Krylov subspace.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Constructor","page":"Iterative Solvers","title":"Constructor","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The constructor for the struct can be defined any number of ways depending on the needs of the struct itself. Often times this is just used to allocate memory or convergence thresholds. This can also be a good place to define structures that make the iterative solver easier to work with. For example, for a columnwise solver one would want an easy array structure to work with vectors in a columnwise fashion.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"In Basic Template for an Iterative Solver we used an outer constructor, e.g.,","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"# constructor\nfunction MyIterativeMethod(args...)\n    # body of constructor\n    return MyIterativeMethod(contructor_args...)\nend","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"but we could have also used an inner constructor if desired.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Initialize-Function","page":"Iterative Solvers","title":"Initialize Function","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The initialize function needs the following signature","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"function initialize!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, args...)\n    # body of initialize function in abstract iterative solver\n    return Bool, Int\nend","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The intialize function has the following arguments:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"linearoperator! (function)\nQ    (array) [OVERWRITTEN]\nQrhs (array)\nsolver (struct) used for dispatch\nargs... passed to linearoperator! function","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The linearoperator! function is assumed to have the following signature:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"linearoperator!(y, x, args...)\n    # body of linear operator\n    return nothing\nend","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"It represents action of a linear operator L on a vector x, that stores the value in the vector y, i.e. Lx = y. The last argument (the args...) is necessary due to how linear operators are defined within ClimateMachine.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The Q and Qrhs function arguments are supposed to represent the solution of the linear system LQ = Qrhs where L is the linear operator implicitly defined by linearoperator!.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The initialize function must have 2 return values:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"convergence (bool)\niterations (int)","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The return values keep track of whether or not the iterative algorithm has converged as well as how many times the linear operator was applied.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Iteration-Function","page":"Iterative Solvers","title":"Iteration Function","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The iteration function needs the following signature","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"function doiteration!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, threshold, args...)\n    # body of iteration\n    return Bool, Int, Float\nend","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The iteration function has the following arguments:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"linearoperator! (function)\nQ (array) [OVERWRITTEN]\nQrhs (array)\nsolver (struct). used for dispatch\nthreshold (float). for the convergence criteria\nargs... passed into the linearoperator! function","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The linearoperator! function is assumed to have the following signature:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"linearoperator!(y, x, args...)\n    # body of linear operator\n    return nothing\nend","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"It represents action of a linear operator L on a vector x, that stores the value in the vector y, i.e. Lx = y. The last argument (the args...) is necessary due to how linear operators are defined within ClimateMachine.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The Q and Qrhs function arguments are supposed to represent the solution of the linear system LQ = Qrhs where L is the linear operator implicitly defined by linearoperator!.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The iteration function must have 3 return values:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"converged (bool)\niterations (int)\nresidual_norm (float64)","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The return values keep track of whether or not the iterative algorithm has converged as well as how many times the linear operator was applied. The residual norm is useful since it is often used to determine a stopping criteria.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#ClimateMachine-Specific-Considerations","page":"Iterative Solvers","title":"ClimateMachine Specific Considerations","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"An MPIStateArray Q in 3D, has the following structure by default:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"size(Q) = (n_ijk, n_s, n_e)","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"where","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_ijk is the number of Gauss-Lobatto points per element\nn_s is the number of states\nn_e is the number of elements","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"In three dimensions, if one wants to operate in a column-wise fashion (with a stacked-brick topology) it is easiest to reshape the array into the following form","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"alias_Q = reshape(Q, (n_i, n_j, n_k, n_s, n_ev, n_eh))","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"where","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_i is the number of Gauss-Lobatto points per element within","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"element that are aligned with one of the horizontal directions.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_j is the number of Gauss-Lobatto points per element within","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"element that are aligned with another one of the horizontal directions.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_k is the number of Gauss-Lobatto points within element that","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"are aligned with the vertical direction.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_s is the number of states\nn_ev is the number of elements in the vertical direction\nn_eh is the number of elements in the horizontal direction","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"Note: n_i x n_j x n_k = n_ijk and n_ev x n_eh = n_e.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"Thus if one wants to operate on a column for a fixed state index (let's say the int s) and a fixed horizontal coordinate (let's say fixed ints i, j, eh), then one could operator on the state:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"one_column = alias_Q[i, j, :, s, :, eh]","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"which are the third and fifth argument in the MPIStateArray.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"Some extra tips are:","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"Since GPUs have limited memory, don't take up too much memory.\nIf possible define a preconditioner. Iterative methods are typically","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"very slow otherwise.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Preconditioners","page":"Iterative Solvers","title":"Preconditioners","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"The code needs to be slightly restructured to allow for preconditioners.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Writing-Tests","page":"Iterative Solvers","title":"Writing Tests","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"Test on small systems where answers can be checked analytically. Check with matrices with easily computable inverses, i.e., the identity matrix or a diagonal matrix. Test with diverse matrix structures. Test with different array types: Arrays, CuArrays, MPIStateArrays, etc. Also test with balance laws to make sure that it can actually be run with IMEX solvers on the CPU/GPU and their distributed analogues.","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Performance-Checks","page":"Iterative Solvers","title":"Performance Checks","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"Timing performance can be done with general CPU/GPU guidelines","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/#Conventions","page":"Iterative Solvers","title":"Conventions","text":"","category":"section"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"Q refers to the initial guess for the iterative solver that gets","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"overwritten with the final solution","category":"page"},{"location":"HowToGuides/Numerics/SystemSolvers/IterativeSolvers/","page":"Iterative Solvers","title":"Iterative Solvers","text":"Qrhs refers to the right hand side of the linear system","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Thermodynamics-docs","page":"Thermodynamics","title":"Thermodynamics Module","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"Thermodynamics.jl provides all thermodynamic functions needed for the atmosphere and functions shared across model components. The functions are general for a moist atmosphere that includes suspended cloud condensate in the working fluid; the special case of a dry atmosphere is obtained for zero specific humidities (or simply by omitting the optional specific humidity arguments in the functions that are needed for a dry atmosphere). The general formulation assumes that there are tracers for specific humidity q, partitioned into","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"q.tot total water specific humidity\nq.liq liquid specific humidity\nq.ice ice specific humidity","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"to characterize the thermodynamic state and composition of moist air.","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"There are several types of functions:","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"Equation of state (ideal gas law):\nair_pressure\nSpecific gas constant and isobaric and isochoric specific heats of moist air:\ngas_constant_air\ncp_m\ncv_m\nSpecific latent heats of vaporization, fusion, and sublimation:\nlatent_heat_vapor\nlatent_heat_fusion\nlatent_heat_sublim\nSaturation vapor pressure and specific humidity over liquid and ice:\nsat_vapor_press_liquid\nsat_vapor_press_ice\nsat_shum\nFunctions computing energies and inverting them to obtain temperatures\ntotal_energy\ninternal_energy\nair_temperature\nFunctions to compute temperatures and partitioning of water into phases in thermodynamic equilibrium (when Gibbs' phase rule implies that the entire thermodynamic state of moist air, including the liquid and ice specific humidities, can be calculated from the 3 thermodynamic state variables, such as energy, pressure, and total specific humidity)\nliquid_fraction (fraction of condensate that is liquid)\nsaturation_adjustment (compute temperature from energy, density, and total specific humidity)\nAuxiliary functions for diagnostic purposes, e.g., other thermodynamic","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"quantities     * liquid_ice_pottemp (liquid-ice potential temperature)","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"A moist dynamical core that assumes equilibrium thermodynamics can be obtained from a dry dynamical core with total energy as a prognostic variable by including a tracer for the total specific humidity q.tot, using the functions, e.g., for the energies in the module, and computing the temperature T and the liquid and ice specific humidities (q.liq and q.ice) from the internal energy e_int by saturation adjustment.","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Usage","page":"Thermodynamics","title":"Usage","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"Users are encouraged to first establish a thermodynamic state with one of our Thermodynamic State Constructors. For example, we would construct a moist thermodynamic state using","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"ts = PhaseEquil(param_set, e_int, ρ, q_tot);","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"here, ρ is the density of the moist air, and the internal energy e_int = e_tot - e_kin - geopotential is the total energy e_tot minus kinetic energy e_kin and potential energy geopotential (all energies per unit mass). Once we've established a thermodynamic state, we can call Thermodynamic state methods that support thermodynamic states:","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"T = air_temperature(ts);\nq = PhasePartition(ts);","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"No changes to the \"right-hand sides\" of the dynamical equations are needed for a moist dynamical core that supports clouds, as long as they do not precipitate. Additional source-sink terms arise from precipitation.","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"Schematically, the workflow in such a core would look as follows:","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"# initialize\ngeopotential = grav * z\nq_tot          = ...\nρ            = ...\n\n(u, v, w)    = ...\ne_kin           = 0.5 * (u^2 + v^2 + w^2)\n\ne_tot        = total_energy(e_kin, geopotential, T, q_tot)\n\ndo timestep   # timestepping loop\n\n  # advance dynamical variables by a timestep (temperature typically\n  # appears in terms on the rhs, such as radiative transfer)\n  advance(u, v, w, ρ, e_tot, q_tot)\n\n  # compute internal energy from dynamic variables\n  e_int = e_tot - 0.5 * (u^2 + v^2 + w^2) - geopotential\n\n  # compute temperature, pressure and condensate specific humidities,\n  ts = PhaseEquil(param_set, e_int, ρ, q_tot);\n  T = air_temperature(ts);\n  q = PhasePartition(ts);\n  p = air_pressure(ts);\n\nend","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"For a dynamical core that additionally uses the liquid and ice specific humidities q.liq and q.ice as prognostic variables, and thus explicitly allows the presence of non-equilibrium phases such as supercooled water, the saturation adjustment in the above workflow is replaced calling a non-equilibrium moist thermodynamic state:","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"q_tot, q_liq, q_ice = ...\nts = PhaseNonEquil(param_set, e_int, ρ, PhasePartition(q_tot, q_liq, q_ice));\nT = air_temperature(ts);\np = air_pressure(ts);","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Extending","page":"Thermodynamics","title":"Extending","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"If Thermodynamics.jl does not have a particular thermodynamic constructor that is needed, you can implement a new one in src/Common/Thermodynamics/states.jl. In this constructor, you must add whichever arguments you wish to offer as inputs, then translate this thermodynamic state into one of:","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"PhaseDry a dry thermodynamic state, uniquely determined by two independent thermodynamic properties\nPhaseEquil a moist thermodynamic state in thermodynamic equilibrium, uniquely determined by three independent thermodynamic properties\nPhaseNonEquil a moist thermodynamic state in thermodynamic non-equilibrium, uniquely determined by four independent thermodynamic properties","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Tested-Profiles","page":"Thermodynamics","title":"Tested Profiles","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"Thermodynamics.jl is tested using a set of profiles specified in test/Common/Thermodynamics/profiles.jl.","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Dry-Phase","page":"Thermodynamics","title":"Dry Phase","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"using ClimateMachine.Thermodynamics\nusing ClimateMachine.TemperatureProfiles\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\ninclude(joinpath(@__DIR__, repeat([\"..\"], 4)...,\"test\", \"Common\", \"Thermodynamics\", \"profiles.jl\"))\nprofiles = PhaseDryProfiles(param_set, Array{Float32});\n@unpack_fields profiles T ρ z\np1 = scatter(ρ, z./10^3, xlabel=\"Density [kg/m^3]\", ylabel=\"z [km]\", title=\"Density\");\np2 = scatter(T, z./10^3, xlabel=\"Temperature [K]\", ylabel=\"z [km]\", title=\"Temperature\");\nplot(p1, p2, layout=(1,2))\nsavefig(\"tested_profiles_dry.svg\");","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"(Image: )","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Moist-Phase-in-thermodynamic-equilibrium","page":"Thermodynamics","title":"Moist Phase in thermodynamic equilibrium","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"using ClimateMachine.Thermodynamics\nusing ClimateMachine.TemperatureProfiles\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\ninclude(joinpath(@__DIR__, repeat([\"..\"], 4)...,\"test\", \"Common\", \"Thermodynamics\", \"profiles.jl\"))\nprofiles = PhaseEquilProfiles(param_set, Array{Float32});\n@unpack_fields profiles T ρ q_tot z\np1 = scatter(ρ, z./10^3, xlabel=\"Density [kg/m^3]\", ylabel=\"z [km]\", title=\"Density\");\np2 = scatter(T, z./10^3, xlabel=\"Temperature [K]\", ylabel=\"z [km]\", title=\"Temperature\");\np3 = scatter(q_tot*1000, z./10^3, xlabel=\"Total specific\\nhumidity [g/kg]\", ylabel=\"z [km]\", title=\"Total specific\\nhumidity\");\nplot(p1, p2, p3, layout=(1,3))\nsavefig(\"tested_profiles_virt_temp.svg\")","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"(Image: )","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Input-space-exploration","page":"Thermodynamics","title":"Input space exploration","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"In the previous section, we plotted the tested thermodynamic states. In this section, we explore the convergence of the input space beyond what is tested. In particular, rather than being interested in physically meaningful combinations of constructor inputs (e.g., ρ, e_int, q_tot), we are interested in all permutations of inputs within a given range of ρ, e_int, q_tot. Some of these permutations may not be physically meaningful, or likely to be observed in climate simulations, but showing the convergence space helps illustrate the buffer between our tested profiles and the nearest space where convergence fails.","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"using ClimateMachine.Thermodynamics\nusing ClimateMachine.TemperatureProfiles\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nimport ClimateMachine.Thermodynamics\nThermodynamics.print_warning() = false\n\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\nFT = Float64;\nclima_root = joinpath(@__DIR__, repeat([\"..\"], 4)...);\ninclude(joinpath(clima_root, \"test\", \"Common\", \"Thermodynamics\", \"profiles.jl\"))\ninclude(joinpath(clima_root, \"docs\", \"plothelpers.jl\"));\nprofiles = PhaseEquilProfiles(param_set, Array{FT});\n@unpack_fields profiles ρ e_int q_tot\n\ndims = (10, 10, 10);\nρ = range(min(ρ...), stop=max(ρ...), length=dims[1]);\ne_int = range(min(e_int...), stop=max(e_int...), length=dims[2]);\nq_tot = range(min(q_tot...), stop=max(q_tot...), length=dims[3]);\n\nρ_all = Array{FT}(undef, prod(dims));\ne_int_all = Array{FT}(undef, prod(dims));\nq_tot_all = Array{FT}(undef, prod(dims));\n\nlinear_indices = LinearIndices((1:dims[1], 1:dims[2], 1:dims[3]));\nTS = Array{Union{ThermodynamicState, Nothing}}(undef, prod(dims));\nTS_no_err = Array{ThermodynamicState}(undef, prod(dims));\n\n@inbounds for i in linear_indices.indices[1]\n    @inbounds for j in linear_indices.indices[2]\n        @inbounds for k in linear_indices.indices[3]\n            p = linear_indices[i, j, k];\n            ρ_all[p] = ρ[i];\n            e_int_all[p] = e_int[j];\n            q_tot_all[p] = q_tot[k];\n\n            Thermodynamics.error_on_non_convergence() = false\n            TS_no_err[p] = PhaseEquil(param_set, e_int[j], ρ[i], q_tot[k]);\n            Thermodynamics.error_on_non_convergence() = true\n            # @show p/prod(linear_indices.indices)*100\n            try\n                TS[p] = PhaseEquil(param_set, e_int[j], ρ[i], q_tot[k]);\n            catch\n                TS[p] = nothing\n            end\n        end\n    end\nend\n\n# Full 3D scatter plot\nfunction save_masked_plot3D(TS_no_err, mask, title, filename)\n    ρ_mask = ρ_all[mask];\n    T_mask = air_temperature.(TS_no_err[mask]);\n    q_tot_mask = q_tot_all[mask];\n    pts = (ρ_mask, T_mask, q_tot_mask)\n    Plots.plot(pts..., seriestype=:scatter, markersize = 7)\n    plot!(xlabel=\"Density\",\n          ylabel=\"Temperature\",\n          zlabel=\"Total specific humidity\",\n          title=\"$title\")\n    savefig(filename)\nend;\n\nsave_masked_plot3D(TS_no_err, TS .== nothing, \"NC\", \"Scatter3DNonConverged.svg\");\nsave_masked_plot3D(TS_no_err, TS .!= nothing, \"C\", \"Scatter3DConverged.svg\");\n\n# 2D binned scatter plots\nfunction save_masked_plot2D_slices(TS_no_err, mask, title, filename)\n    ρ_mask = ρ_all[mask];\n    T_mask = air_temperature.(TS_no_err[mask]);\n    q_tot_mask = q_tot_all[mask];\n    save_binned_surface_plots(ρ_mask, T_mask, q_tot_mask, title, filename)\nend;\n\nsave_masked_plot2D_slices(TS_no_err, TS .== nothing, \"NC\", \"Slices2DNonConverged.svg\");\nsave_masked_plot2D_slices(TS_no_err, TS .!= nothing, \"C\", \"Slices2DConverged.svg\");\n\n@warn \"Note that the temperature axis for the non-converged\nplot is not necessarily accurate, since the temperatures are\nthe result of a non-converged saturation adjustment\"","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Converged-cases-(3D-view)","page":"Thermodynamics","title":"Converged cases (3D view)","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"(Image: )","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Non-converged-cases-(3D-view)","page":"Thermodynamics","title":"Non-converged cases (3D view)","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"(Image: )","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Converged-cases-(2D-view),-binned-by-total-specific-humidity","page":"Thermodynamics","title":"Converged cases (2D view), binned by total specific humidity","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"(Image: )","category":"page"},{"location":"HowToGuides/Common/Thermodynamics/#Non-converged-cases-(2D-view),-binned-by-total-specific-humidity","page":"Thermodynamics","title":"Non-converged cases (2D view), binned by total specific humidity","text":"","category":"section"},{"location":"HowToGuides/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"(Image: )","category":"page"},{"location":"DevDocs/SystemImage/#System-Image","page":"Custom System Image","title":"System Image","text":"","category":"section"},{"location":"DevDocs/SystemImage/","page":"Custom System Image","title":"Custom System Image","text":"To speed up the start time of ClimateMachine a custom system image can be built with the PackageCompiler.","category":"page"},{"location":"DevDocs/SystemImage/","page":"Custom System Image","title":"Custom System Image","text":"A helper script for doing this is provided at .dev/systemimage/climate_machine_image.jl","category":"page"},{"location":"DevDocs/SystemImage/","page":"Custom System Image","title":"Custom System Image","text":"If called with","category":"page"},{"location":"DevDocs/SystemImage/","page":"Custom System Image","title":"Custom System Image","text":"no arguments: will create the system image ClimateMachine.so in the @__DIR__ directory (i.e., the directory in which the script is located)\na single argument: the system image will be placed in the path specified by the argument (relative to the callers path)\na specified systemimg path and true: the system image will compile the climate machine package module (useful for CI). This option should not be used when actually developing the climate machine package; see the drawback from the PackageCompiler repository.","category":"page"},{"location":"DevDocs/SystemImage/","page":"Custom System Image","title":"Custom System Image","text":"To run julia using the newly created system image use:","category":"page"},{"location":"DevDocs/SystemImage/","page":"Custom System Image","title":"Custom System Image","text":"julia -J/PATH/TO/SYSTEM/IMAGE/ClimateMachine.so --project","category":"page"},{"location":"DevDocs/SystemImage/","page":"Custom System Image","title":"Custom System Image","text":"tip: Tip\nIf you put the system image in your .git directory, your system image will not be remove by calls to git clean.","category":"page"},{"location":"DevDocs/SystemImage/","page":"Custom System Image","title":"Custom System Image","text":"warning: Warning\nIf the climate machine Manifest.toml is updated you must build a new system image for these changes to be seen.","category":"page"},{"location":"DevDocs/DiagnosticVariables/#Diagnostics-vars","page":"Diagnostic variable list","title":"Diagnostic Variable List","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"This is a list of all the diagnostic variables that the ClimateMachine can produce, partitioned into groups.","category":"page"},{"location":"DevDocs/DiagnosticVariables/#LES-Diagnostics","page":"Diagnostic variable list","title":"LES Diagnostics","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"Unless other noted, these fields are density-weighted using horizontally averaged density.","category":"page"},{"location":"DevDocs/DiagnosticVariables/#default","page":"Diagnostic variable list","title":"default","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(time,-z)","page":"Diagnostic variable list","title":"1D fields (time, z)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nu x-velocity\nv y-velocity\nw z-velocity\navg_rho density\nrho (density-averaged) density\nqt total specific humidity\nql liquid water specific humidity\nqv water vapor specific humidity\nthd potential temperature\nthv virtual potential temperature\nthl liquid-ice potential temperature\net total specific energy\nei specific internal energy\nht specific enthalpy based on total energy\nhi specific enthalpy based on internal energy\nvar_u variance of x-velocity\nvar_v variance of y-velocity\nvar_w variance of z-velocity\nw3 the third moment of z-velocity\ntke turbulence kinetic energy\nvar_qt variance of total specific humidity\nvar_thl variance of liquid-ice potential temperature\nvar_ei variance of specific internal energy\ncov_w_u vertical eddy flux of x-velocity\ncov_w_v vertical eddy flux of y-velocity\ncov_w_rho vertical eddy flux of mass\ncov_w_qt vertical eddy flux of total specific humidity\ncov_w_ql vertical eddy flux of liuqid water specific humidity\ncov_w_qv vertical eddy flux of water vapor specific humidity\ncov_w_thd vertical eddy flux of potential temperature\ncov_w_thv vertical eddy flux of virtual temperature\ncov_w_thl vertical eddy flux of liquid-ice potential temperature\ncov_w_ei vertical eddy flux of specific internal energy\ncov_qt_thl covariance of total specific humidity and liquid-ice potential temperature\ncov_qt_ei covariance of total specific humidity and specific internal energy\nw_qt_sgs vertical sgs flux of total specific humidity\nw_ht_sgs vertical sgs flux of total specific enthalpy\ncld_frac cloud fraction\nlwp liquid water path","category":"page"},{"location":"DevDocs/DiagnosticVariables/#Scalars-(time)","page":"Diagnostic variable list","title":"Scalars (time)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\ncld_cover cloud cover\ncld_top cloud top\ncld_base cloud base","category":"page"},{"location":"DevDocs/DiagnosticVariables/#core","page":"Diagnostic variable list","title":"core","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(time,-z)-2","page":"Diagnostic variable list","title":"1D fields (time, z)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nu_core cloud core x-velocity\nv_core cloud core y-velocity\nw_core cloud core z-velocity\navg_rho_core cloud core density\nrho_core cloud core (density-averaged) density\nqt_core cloud core total specific humidity\nql_core cloud core liquid water specific humidity\nthv_core cloud core virtual potential temperature\nthl_core cloud core liquid-ice potential temperature\nei_core cloud core specific internal energy\nvar_u_core cloud core variance of x-velocity\nvar_v_core cloud core variance of y-velocity\nvar_w_core cloud core variance of z-velocity\nvar_qt_core cloud core variance of total specific humidity\nvar_thl_core cloud core variance of liquid-ice potential temperature\nvar_ei_core cloud core variance of specific internal energy\ncov_w_rho_core cloud core vertical eddy flux of mass\ncov_w_qt_core cloud core vertical eddy flux of total specific humidity\ncov_w_thl_core cloud core vertical eddy flux of liquid-ice potential temperature\ncov_w_ei_core cloud core vertical eddy flux of specific internal energy\ncov_qt_thl_core cloud core covariance of total specific humidity and liquid-ice potential temperature\ncov_qt_ei_core cloud core covariance of total specific humidity and specific internal energy\ncore_frac cloud core (q_liq > 0 and w > 0) fraction","category":"page"},{"location":"DevDocs/DiagnosticVariables/#GCM-Diagnostics","page":"Diagnostic variable list","title":"GCM Diagnostics","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"Based on this issue.\nGCM diagnostic variables are not currently density weigted.","category":"page"},{"location":"DevDocs/DiagnosticVariables/#default-(for-Dry-Held-Suarez)","page":"Diagnostic variable list","title":"default (for Dry Held-Suarez)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(time,-long,-lat,-level)","page":"Diagnostic variable list","title":"3D fields (time, long, lat, level)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nu zonal velocity (along longitude)\nv meridional velocity (along latitude)\nw vertical velocity (along altitude)\nrho density\n \ntemp air temperature\npres air pressure\nthd dry potential temperature\n \net total specific energy\nei specific internal energy\nht specific enthalpy from total energy\nhi specific enthalpy from internal energy\n \nvort relative vorticity","category":"page"},{"location":"DevDocs/DiagnosticVariables/#default-(for-Moist-Aquaplanet)","page":"Diagnostic variable list","title":"default (for Moist Aquaplanet)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"These are in addition to Held-Suarez.","category":"page"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(time,-long,-lat,-level)-2","page":"Diagnostic variable list","title":"3D fields (time, long, lat, level)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nqt total specific humidity\nql liquid water specific humidity\nqv water vapour specific humidity\nqi ice specific humidity\nthv virtual potential temperature\nthl liquid-ice potential temperature","category":"page"},{"location":"DevDocs/DiagnosticVariables/#To-be-implemented-(for-Dry-Held-Suarez)","page":"Diagnostic variable list","title":"To be implemented (for Dry Held-Suarez)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(time,-lat,-level)","page":"Diagnostic variable list","title":"2D fields (time, lat, level)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nstream_euler Eulerian meridional streamfunction","category":"page"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(time,-long,-lat)","page":"Diagnostic variable list","title":"2D fields (time, long, lat)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"| short name | description                                                                | |:–––––-|:–––––––––––––––––––––––––––––––––––––-|","category":"page"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(long,-lat,-level)","page":"Diagnostic variable list","title":"3D fields (long, lat, level)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nstream horizontal streamfunction (Laplacian of vort)\npv_qg potential vorticity (f + vort + f/N d2/dz2 stream)\npv_ertel Ertel potential vorticity\ndiv divergence\n \nvar_uu_zonal variances using zonal mean (also for vv, ww, TT, option for others)\ncov_uv_zonal covariances using zonal mean (also for uw, vw, uT, vT, wT, option for others)\n \nvar_uu_time variances using time mean (also for vv, ww, TT, option for others)\ncov_uv_time covariances using time mean (also for uw, vw, uT, vT, wT, option for others)\n \nvar_uu_bandpass (co)variances using a Lanczos filter (also for vv, ww, TT, option for others)\ncov_uv_bandpass (co)variances using a Lanczos filter (also for uw, vw, uT, vT, wT, option for others)","category":"page"},{"location":"DevDocs/DiagnosticVariables/#Spectral-decomposition-(time,-lat,-level,-wavenumber)","page":"Diagnostic variable list","title":"Spectral decomposition (time, lat, level, wavenumber)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\npower_spec_eke eddy kinetic energy power spectrum","category":"page"},{"location":"DevDocs/DiagnosticVariables/#To-be-implemented-(for-Moist-Aquaplanet)","page":"Diagnostic variable list","title":"To be implemented (for Moist Aquaplanet)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"This are in addition to Held-Suarez.","category":"page"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(time,-long,-lat)-2","page":"Diagnostic variable list","title":"2D fields (time, long, lat)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\ntoa_sw_do top of atmosphere (TOA) downwelling shortwave flux\ntoa_sw_up TOA Upwelling shortwave flux\ntoa_lw_up TOA Upwelling longwave flux\ntoa_sw_sfc up- and downwelling shortwave flux at surface\ntoa_lw_sfc up- and downwelling longwave flux at surface\nsensible_sfc sensible heat flux at surface\nlatent_sfc latent heat flux at surface\nT_sfc surface air temperature\nrain_sfc rain rate at surface\nsnow_sfc snow rate at surface","category":"page"},{"location":"DevDocs/DiagnosticVariables/#D-fields-(time,-long,-lat,-level)-3","page":"Diagnostic variable list","title":"3D fields (time, long, lat, level)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nrh relative humidity\ncld_frac cloud fraction\nmse moist static energy","category":"page"},{"location":"DevDocs/DiagnosticVariables/#More-complex-diagnostics,-e.g.-extremes","page":"Diagnostic variable list","title":"More complex diagnostics, e.g. extremes","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nrain_thres frequency with which a given rain rate threshold at the surface is exceeded\ntemp_thres frequency with which a given temperature threshold at the surface is exceeded\ntrack_loc frequency of tracked features (e.g. cyclones, blocking)\ntrack_int intensity of tracked features (e.g. cyclones, blocking)","category":"page"},{"location":"DevDocs/DiagnosticVariables/#To-be-implemented-(for-full-GCM,-additional-to-all-above)","page":"Diagnostic variable list","title":"To be implemented (for full GCM, additional to all above)","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nxx (Later: sea ice cover, leaf temperature, soil temperature, ...)","category":"page"},{"location":"GettingStarted/Installation/#Installing-ClimateMachine","page":"Installation","title":"Installing ClimateMachine","text":"","category":"section"},{"location":"GettingStarted/Installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"The Climate Machine (CLIMA) uses the Julia programming language and has been tested for the latest Julia release version 1.4, which can be downloaded via your package manager or from the Julia website.","category":"page"},{"location":"GettingStarted/Installation/#Install-MPI-(optional)","page":"Installation","title":"Install MPI (optional)","text":"","category":"section"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"The ClimateMachine uses the Message Passing Interface (MPI) for distributed processing via the MPI.jl package. This package downloads and installs an MPI implementation for your platform. However, on high-performance computing systems, you will probably want to configure this package to use the system-provided MPI implementation. You can do so by setting the environment variable JULIA_MPI_BINARY=system.","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"Install MPI.jl in Julia using the built-in package manager (press ] at the Julia prompt):","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.4) pkg> add MPI","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"The package should be installed and built without errors. You can verify that all is well with:","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"julia> ]\n(v1.4) pkg> test MPI","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"If you are having problems, see the MPI.jl documentation for help.","category":"page"},{"location":"GettingStarted/Installation/#Install-the-ClimateMachine","page":"Installation","title":"Install the ClimateMachine","text":"","category":"section"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"Download the ClimateMachine source (you will need Git):","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"$ git clone https://github.com/CliMA/ClimateMachine.jl","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"Now change into the ClimateMachine.jl directory with ","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"$ cd ClimateMachine.jl","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"and install all the required packages with:","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"$ julia --project -e 'using Pkg; pkg\"instantiate\"; pkg\"build MPI\"'","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"Pre-compile the packages to allow the ClimateMachine to start faster:","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"$ julia --project -e 'using Pkg; pkg\"precompile\"'","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"You can verify your installation with:","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"$ julia --project test/runtests.jl","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"This will take a while!","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"You are now ready to run one of the tutorials. For instance, the dry Rayleigh Benard tutorial:","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"$ julia --project tutorials/Atmos/dry_rayleigh_benard.jl","category":"page"},{"location":"GettingStarted/Installation/","page":"Installation","title":"Installation","text":"The ClimateMachine is CUDA-enabled and will use GPU(s) if available. To run on the CPU, set the environment variable CLIMATEMACHINE_GPU to false.","category":"page"},{"location":"APIs/Atmos/TemperatureProfiles/#Temperature-Profiles","page":"Temperature Profiles","title":"Temperature Profiles","text":"","category":"section"},{"location":"APIs/Atmos/TemperatureProfiles/","page":"Temperature Profiles","title":"Temperature Profiles","text":"CurrentModule = ClimateMachine.TemperatureProfiles","category":"page"},{"location":"APIs/Atmos/TemperatureProfiles/","page":"Temperature Profiles","title":"Temperature Profiles","text":"TemperatureProfile\nIsothermalProfile\nDryAdiabaticProfile\nDecayingTemperatureProfile","category":"page"},{"location":"APIs/Atmos/TemperatureProfiles/#ClimateMachine.TemperatureProfiles.TemperatureProfile","page":"Temperature Profiles","title":"ClimateMachine.TemperatureProfiles.TemperatureProfile","text":"TemperatureProfile\n\nSpecifies the temperature or virtual temperature profile for a reference state.\n\nInstances of this type are required to be callable objects with the following signature\n\nT,p = (::TemperatureProfile)(param_set::AbstractParameterSet, z::FT) where {FT}\n\nwhere T is the temperature or virtual temperature (in K), and p is the pressure (in Pa).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/TemperatureProfiles/#ClimateMachine.TemperatureProfiles.IsothermalProfile","page":"Temperature Profiles","title":"ClimateMachine.TemperatureProfiles.IsothermalProfile","text":"IsothermalProfile(param_set, T_virt)\nIsothermalProfile(param_set, ::Type{FT<:AbstractFloat})\n\nA uniform virtual temperature profile, which is implemented as a special case of DecayingTemperatureProfile.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/TemperatureProfiles/#ClimateMachine.TemperatureProfiles.DryAdiabaticProfile","page":"Temperature Profiles","title":"ClimateMachine.TemperatureProfiles.DryAdiabaticProfile","text":"DryAdiabaticProfile{FT} <: TemperatureProfile{FT}\n\nA temperature profile that has uniform dry potential temperature θ\n\nFields\n\nT_surface\nSurface temperature (K)\nT_min_ref\nMinimum temperature (K)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Atmos/TemperatureProfiles/#ClimateMachine.TemperatureProfiles.DecayingTemperatureProfile","page":"Temperature Profiles","title":"ClimateMachine.TemperatureProfiles.DecayingTemperatureProfile","text":"DecayingTemperatureProfile{F} <: TemperatureProfile{FT}\n\nA virtual temperature profile that decays smoothly with height z, from T_virt_surf to T_min_ref over a height scale H_t. The default height scale H_t is the density scale height evaluated with T_virt_surf.\n\nT_textv(z) = max(T_textv sfc  (T_textv sfc - T_textv min) tanh(zH_textt)\n\nFields\n\nT_virt_surf\nVirtual temperature at surface (K)\nT_min_ref\nMinimum virtual temperature at the top of the atmosphere (K)\nH_t\nHeight scale over which virtual temperature drops (m)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/SurfaceFluxes/#Surface-Fluxes","page":"Surface Fluxes","title":"Surface Fluxes","text":"","category":"section"},{"location":"APIs/Common/SurfaceFluxes/","page":"Surface Fluxes","title":"Surface Fluxes","text":"ClimateMachine.SurfaceFluxes","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes","text":"SurfaceFluxes\n\nInterface\n\nsurface_conditions computes\nMonin-Obukhov length\nPotential temperature flux (if not given) using Monin-Obukhov theory\ntransport fluxes using Monin-Obukhov theory\nfriction velocity/temperature scale/tracer scales\nexchange coefficients\n\nReferences\n\n@article{nishizawa2018surface,   title={A Surface Flux Scheme Based on the Monin-Obukhov Similarity for Finite Volume Models},   author={Nishizawa, S and Kitamura, Y},   journal={Journal of Advances in Modeling Earth Systems},   volume={10},   number={12},   pages={3159–3175},   year={2018},   publisher={Wiley Online Library} }\n\n\n\n\n\n","category":"module"},{"location":"APIs/Common/SurfaceFluxes/#Universal-Functions","page":"Surface Fluxes","title":"Universal Functions","text":"","category":"section"},{"location":"APIs/Common/SurfaceFluxes/","page":"Surface Fluxes","title":"Surface Fluxes","text":"ClimateMachine.SurfaceFluxes.UniversalFunctions","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.UniversalFunctions","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.UniversalFunctions","text":"UniversalFunctions\n\nUniversal stability and stability correction functions for SurfaceFluxes module.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Common/SurfaceFluxes/","page":"Surface Fluxes","title":"Surface Fluxes","text":"ClimateMachine.SurfaceFluxes.UniversalFunctions.Gryanik\nClimateMachine.SurfaceFluxes.UniversalFunctions.Grachev\nClimateMachine.SurfaceFluxes.UniversalFunctions.Businger","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.UniversalFunctions.Gryanik","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.UniversalFunctions.Gryanik","text":"Gryanik <: AbstractUniversalFunction{FT}\n\nReference\n\nGryanik, Vladimir M., et al. \"New modified and extended\nstability functions for the stable boundary layer based\non SHEBA and parametrizations of bulk transfer coefficients\nfor climate models.\" Journal of the Atmospheric Sciences\n(2020).\n\nEquations in reference:\n\nϕ_m: Eq. 13\nϕ_h: Eq. 13\nψ_m: Eq. 14\nψ_h: Eq. 14\n\nFields\n\nparam_set\nParameter set\nL\nMonin-Obhukov Length\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.UniversalFunctions.Grachev","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.UniversalFunctions.Grachev","text":"Grachev <: AbstractUniversalFunction{FT}\n\nReference:\n\nGrachev, A. A., E. L. Andreas, C. W. Fairall, P. S. Guest, and\nP. O. G. Persson, 2007a: SHEBA flux–profile relationships in\nthe stable atmospheric boundary layer. Bound.-Layer Meteor.,\n124, 315–333, https://doi.org/10.1007/s10546-007-9177-6.\n\nEquations in reference:\n\nϕ_m: Eq. 13\nϕ_h: Eq. 13\nψ_m: Eq. 14\nψ_h: Eq. 14\n\nFields\n\nparam_set\nParameter set\nL\nMonin-Obhukov Length\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.UniversalFunctions.Businger","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.UniversalFunctions.Businger","text":"Businger\n\nReference\n\nNishizawa, S., and Y. Kitamura. \"A Surface Flux\nScheme Based on the Monin‐Obukhov Similarity for\nFinite Volume Models.\" Journal of Advances in\nModeling Earth Systems 10.12 (2018): 3159-3175.\nAppendix A.\n\nOriginal research\n\nBusinger, Joost A., et al. \"Flux-profile\nrelationships in the atmospheric surface layer.\"\nJournal of the atmospheric Sciences 28.2 (1971):\n181-189.\n\nEquations in reference:\n\nϕ_m: Eq. A1\nϕ_h: Eq. A2\nψ_m: Eq. A3\nψ_h: Eq. A4\n\nFields\n\nparam_set\nParameter set\nL\nMonin-Obhukov Length\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/SurfaceFluxes/","page":"Surface Fluxes","title":"Surface Fluxes","text":"ClimateMachine.SurfaceFluxes.UniversalFunctions.phi\nClimateMachine.SurfaceFluxes.UniversalFunctions.psi\nClimateMachine.SurfaceFluxes.UniversalFunctions.Psi","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.UniversalFunctions.phi","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.UniversalFunctions.phi","text":"phi\n\nUniversal stability function for wind shear (ϕm) and temperature gradient (ϕh)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.UniversalFunctions.psi","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.UniversalFunctions.psi","text":"psi\n\nUniversal stability correction function for momentum (ψm) and heat (ψh)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.UniversalFunctions.Psi","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.UniversalFunctions.Psi","text":"Psi\n\nIntegral of universal stability correction function for momentum (ψm) and heat (ψh)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#Fluxes-API","page":"Surface Fluxes","title":"Fluxes API","text":"","category":"section"},{"location":"APIs/Common/SurfaceFluxes/","page":"Surface Fluxes","title":"Surface Fluxes","text":"ClimateMachine.SurfaceFluxes.surface_conditions\nClimateMachine.SurfaceFluxes.exchange_coefficients","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.surface_conditions","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.surface_conditions","text":"surface_conditions\n\nSurface conditions given\n\nx_initial initial guess for solution (L_MO, u_star, θ_star, ϕ_star, ...)\nx_ave volume-averaged value for variable x\nx_s surface value for variable x\nz_0 roughness length for variable x\nF_exchange flux at the top for variable x\nVDSE_scale virtual dry static energy (i.e., basic potential temperature)\nΔz layer thickness (not spatial discretization)\nz coordinate axis\na free model parameter with prescribed value of 4.7\nVDSE_flux_star_given potential temperature flux (optional)\n\nIf VDSE_flux_star is not given, then it is computed by iteration of equations 3, 17, and 18 in Nishizawa2018.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.exchange_coefficients","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.exchange_coefficients","text":"exchange_coefficients(z, F_exchange, a, x_star, VDSE_scale, L_MO)\n\nComputes exchange transfer coefficients\n\nK_exchange exchange coefficients\n\n\n\n\n\n","category":"function"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Contribution-Guide-for-Abstract-Time-stepping-Algorithms","page":"Time-integration","title":"Contribution Guide for Abstract Time-stepping Algorithms","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"CurrentModule = ClimateMachine.ODESolvers","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"This guide gives a brief overview on how time-stepping methods are implemented in ClimateMachine, and how one might contribute a new time-stepping method.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Currently, ClimateMachine supports a variety of time-stepping methods within the Runge-Kutta framework. For purely explicit time-integration, ClimateMachine supports the following methods:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"LSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\nSSPRK33ShuOsher\nSSPRK34SpiteriRuuth","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Methods 1 and 2 are implemented as low-storage Runge-Kutta methods, which uses a 2N storage scheme for the coefficient arrays of the given time-stepping method (known as the Butcher Tableau). All time-integration methods are part of a single module: ODESolvers.  Each Runge-Kutta method requires one struct, with a constructor.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Basic-Template-for-an-explicit-Runge-Kutta-Method","page":"Time-integration","title":"Basic Template for an explicit Runge-Kutta Method","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"A basic template for an explicit Runge-Kutta method is as follows:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"export MyExplicitRKMethod\n\nstruct MyExplicitRKMethod{T, RT, AT, Nstages} <: AbstractODESolver\n    \"time step size\"\n    dt::RT\n    \"rhs function\"\n    rhs!\n    \"Storage for the stage vectors\"\n    Qstage::AT\n    \"RK coefficient vector A (rhs scaling)\"\n    RKA::Array{RT, 2}\n    \"RK coefficient vector B (rhs accumulation scaling)\"\n    RKB::Array{RT, 1}\n    \"RK coefficient vector C (temporal scaling)\"\n    RKC::Array{RT, 1}\n    # May require more attributes depending on the type of RK method\n\n    # Constructor\n    function MyExplicitRKMethod(args...)\n        # Body of the constructor\n        ...\n        return MyExplicitRKMethod(dt, rhs, Qstage, RKA, RKB, RKC)\n    end\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Once MyExplicitRKMethod is defined, we require to implement an appropriate dostep! function, which defines how to step the state vector Q forward in time:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"function ODESolver.dostep!(Q, rkmethod::MyExplicitRKMethod, p,\n                           time::Real,...)\n    # Function body\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Once dostep! is implemented, MyExplicitRKMethod should be ready for use in ClimateMachine.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Basic-Template-for-an-IMEX/Additive-Runge-Kutta-Method","page":"Time-integration","title":"Basic Template for an IMEX/Additive Runge-Kutta Method","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"IMEX, or IMplicit-EXplicit, Runge-Kutta methods require a bit more attention. IMEX methods are typically constructed from Additively-partitioned Runge-Kutta (ARK) methods. For IMEX methods, the standard way is to consider an ARK method with two partitions: one explicit part, and one implicit part. The implicit part will require a linear solver.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"An ARK method with an explicit and implicit component will require two Butcher Tableaus: one for each of the partitioned components.  Additionally, a linear solver is required.  Currently, ClimateMachine supports the follow set of ARK methods for IMEX-based timestepping:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"ARK1ForwardBackwardEuler\nARK2ImplicitExplicitMidpoint\nARK2GiraldoKellyConstantinescu\nARK548L2SA2KennedyCarpenter\nARK437L2SA1KennedyCarpenter","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"For example, consider the following:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"export MyIMEXMethod\n\nstruct MyIMEXMethod{T, RT, AT, LT, V, VS, Nstages, Nstages_sq} <: AbstractODESolver\n    \"time step\"\n    dt::RT\n    \"rhs function\"\n    rhs!\n    \"rhs linear operator\"\n    rhs_linear!\n    \"implicit operator, pre-factorized\"\n    implicitoperator!\n    \"linear solver\"\n    linearsolver::LT\n    \"Stage vectors for the ARK method\"\n    Qstages::NTuple{Nstages, AT}\n    \"RK coefficient matrix A for the explicit scheme\"\n    RKA_explicit::SArray{NTuple{2, Nstages}, RT, 2, Nstages_sq}\n    \"RK coefficient matrix A for the implicit scheme\"\n    RKA_implicit::SArray{NTuple{2, Nstages}, RT, 2, Nstages_sq}\n    \"RK coefficient vector B (rhs accumulation scaling)\"\n    RKB::SArray{Tuple{Nstages}, RT, 1, Nstages}\n    \"RK coefficient vector C (temporal scaling)\"\n    RKC::SArray{Tuple{Nstages}, RT, 1, Nstages}\n\n    # May have more attributes depending on the method\n\n    # Constructor\n    function MyIMEXMethod(args...)\n        # Body of the constructor\n        ...\n        return MyIMEXMethod(dt, rhs, rhs_linear, implicitoperator,\n                            Qstages, RKA_explicit, RKA_implicit,\n                            RKB, RKC)\n    end","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"In addition to a dostep! function, IMEX methods also require functions related to the implicitoperator, which should be interpreted as a matrix operator representing the implicit components. Depending on the coefficients in RKA_implicit, a linear solve may be required at each stage of the ARK method, or only a subset of the total stages. If the implicit operator is changing with each stage, then it will need to be updated via a function updatedt!:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"function updatedt!(ark::MyIMEXMethod, dt::Real)\n    # Function body\n    ark.implicitoperator! = prefactorize(...)\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"For information on the function prefactorize, see the module ClimateMachine.SystemSolvers.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#The-Struct-and-its-Constructor","page":"Time-integration","title":"The Struct and its Constructor","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"The Struct defining important quantities for a given time-integrator is a subset of an AbstractODESolver. For simplicity, we assume a standard Runge-Kutta method:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"struct MyRKMethod{T, RT, AT, Nstages} <: AbstractODESolver\n    \"time step size\"\n    dt::RT\n    \"rhs function\"\n    rhs!\n    \"Storage for the stage vectors\"\n    Qstage::AT\n    \"RK coefficient vector A (rhs scaling)\"\n    RKA::Array{RT, 2}\n    \"RK coefficient vector B (rhs accumulation scaling)\"\n    RKB::Array{RT, 1}\n    \"RK coefficient vector C (temporal scaling)\"\n    RKC::Array{RT, 1}\n    # May require more attributes depending on the type of RK method\n\n    # Constructor\n    function MyRKMethod(args...)\n        # Body of the constructor\n        ...\n        return MyRKMethod(constructor_args...)\n    end\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Since time-integration methods are often complex and drastically different from one another, the Struct and its Constructor, MyRKMethod(args...), will often look quite different, i.e. explicit and IMEX time-integrators have different Struct attributes and Constructor arguments.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"As a general rule of thumb, all Runge-Kutta-based methods will need to keep track of the time-step size dt as wells as the Butcher tableau coefficients. If your time-integrator has an implicit component (semi-implicit) or is fully implicit, the Struct will need to know about the implicitoperator and the corresponding linearsolver.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#The-dostep!-function","page":"Time-integration","title":"The dostep! function","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"No matter the type of time-integration method, all time-steppers require the implementation of the dostep! function. Suppose we have some time-stepper, say MyTimeIntegrator. Then the arguments to the dostep! function will be:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"function dostep!(\n    Q,\n    rkmethod::MyTimeIntegrator,\n    p,\n    time,\n    slow_δ = nothing,\n    slow_rv_dQ = nothing,\n    in_slow_scaling = nothing,\n)\n    # Function body\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Where Q is the state vector, time denotes the time for the next time-step, the time-integrator, and slow_δ, slow_rv_dQ, in_slow_scaling are optional arguments contributing to additional terms in the ODE right-hand side. More information on those argument will be covered in a later section. Note that the argument p should be interpreted as a context manager for more sophisticated time-stepping methods (for example, schemes with multiple RK methods); typical Runge-Kutta schemes will generally not need to worry about the argument p.  The argument rkmethod is used for multiple dispatch, and Q is an array that gets overwritten with field values at the next time-step.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Multirate-Runge-Kutta-Methods","page":"Time-integration","title":"Multirate Runge-Kutta Methods","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Multirate time-integration is a popular approach for weather and climate simulations. The core idea is that the ODE in question can be expressed as the sum of a fast and slow component. In the atmosphere, fast dynamics include the modes associated with acoustic waves (assuming a compressible or pseudo-compressible model of the atmosphere), typically on the order of 300 m/s, while dynamics associated with advection, diffusion, and radiation represent slow dynamics. The core idea behind a multirate method is to step each component (fast and slow) forward in time at a different rate (hence the name \"Multi-Rate\").","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"There are several different approaches for multirate methods. In ClimateMachine, a multirate time-stepper is provided as MultirateRungeKutta, which takes a given number of Runge-Kutta methods (one for each rate).","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Implementation-Considerations","page":"Time-integration","title":"Implementation Considerations","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Generally speaking, a multirate method requires composing several different time-stepping methods for different components of the ODE. Therefore, the Struct and its Constructor may look something like:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"export MyMultirateMethod\n\nstruct MyMultirateMethod{SS, FS, RT} <: AbstractODESolver\n    \"slow solver\"\n    slow_solver::SS\n    \"fast solver\"\n    fast_solver::FS\n    # May require more attributes depending on implementation\n\n    # Constructor\n    function MyMultirateMethod(args...)\n        # Body of constructor\n        ...\n        return MyMultirateMethod(constructor_args...)\n    end\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"One can imagine a scenario where several rates are operating in tandem. There are a number of possible approaches for handling this. One example is to recursively nest multiple MyMultirateMethod instances:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"function MyMultirateMethod(solvers::Tuple, Q; dt::Real)\n    # Take a tuple of solvers and defined a nested\n    # multirate method\n    fast_solver = MyMultirateMethod(solvers[2:end], Q; dt = dt)\n    slow_solver = solver[1]\n    return MyMultirateMethod(slow_solver, fast_solver, Q; dt = dt)\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Note that this example assumes the solvers Tuple is ordered in such a way that the first element is the slowest solver, while all subsequent solvers are faster than the previous.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Just like all other previously mentioned time-integrators, the dostep! function will need to be implemented, taking into account the nesting of several solvers.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Writing-Tests","page":"Time-integration","title":"Writing Tests","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Testing is critical for the success and sustainability of any software project. Therefore, it is absolutely imperative for all newly added time-integrator to have a corresponding regression test.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"The standard way is to consider an ODE with an analytic solution. A given time-integrator will have a known convergence rate, and thus a good regression test would be to verify temporal convergence in the computed solution. Several examples can be found in ClimateMachine.jl/test/ODESolvers.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Performance-Checks","page":"Time-integration","title":"Performance Checks","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Timing performance of a time-integrator can be done using standard guidelines for CPU and GPU architectures. Certain factors that impact the performance of a time-integrator includes the following:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Memory management – how much memory is a given method using, in","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"particular, storing stage vectors for RK methods. For IMEX methods, using direct solvers (LU factorization, for example) often has a significant impact on memory usage.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Right-hand side evaluations – for explicit methods, the total number","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"of function evaluations contributes to most of the arithmetic intensity of the time-integrator. More evaluates require more compute resources.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"Solving linear systems – for IMEX or implicit methods, solving a linear","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/","page":"Time-integration","title":"Time-integration","text":"system of equations is required. This is arguably the most expensive part of any IMEX/implicit time-integrator. Things to consider include: iterative methods, preconditioning, and parallel scalability.","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/agnesi_nh_lin.jl\"","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/#EX-LIN_NH-docs","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear NH mountain waves (Topography)","text":"","category":"section"},{"location":"generated/Atmos/agnesi_nh_lin/#Description-of-experiment","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Description of experiment","text":"","category":"section"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"Dry linear Non-hydrostatic Mountain Waves","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"This example of a non-linear hydrostatic mountain wave can be classified as an initial value problem.","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"The atmosphere is dry and the flow impinges against a witch of Agnesi mountain of heigh h_m=1m and base parameter a=1000m and centered in x_c = 72km in a 2D domain Omega = 144km times 30 km. The mountain is defined as","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":" z = frach_m1 + fracx - x_ca","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"The 2D problem is setup in 3D by using 1 element in the y direction. To damp the upward moving gravity waves, a Reyleigh absorbing layer is added at z = 10000m.","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"The initial atmosphere is defined such that it has a stability frequency N=001 s^-1, where","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":" N^2 = gfracrm d ln theta rm dz","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"so that","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"theta = theta_0 expleft(fracN^2 zg right)","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"pi = 1 + fracg^2c_p theta_0 N^2left(expleft(frac-N^2 zg right)right)","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"where theta_0 = 280K.","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"so that","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"ρ = fracp_sfcR_gasthetapi^c_vR_gas","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"and T = theta pi","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"Boundaries\nImpenetrable(FreeSlip()) - Top and bottom: no momentum flux, no mass flux through walls.\nImpermeable() - non-porous walls, i.e. no diffusive fluxes through  walls.\nAgnesi topography built via meshwarp.\nLaterally periodic\nDomain - 144,000 m (horizontal) x 1360 m (horizontal) x 30,000m (vertical) (infinite domain in y)\nResolution - 340 m X 200 m effective resolution\nTotal simulation time - 18,000 s\nOverrides defaults for\nCPU Initialisation\nTime integrator\nSources","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"note: Note\nThis experiment setup assumes that you have installed the ClimateMachine according to the instructions on the landing page. We assume the users' familiarity with the conservative form of the equations of motion for a compressible fluid (see the AtmosModel page).The following topics are covered in this exampleDefining the initial conditions\nApplying source terms\nAdd an idealized topography defined by a warping function","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/#Boilerplate-(Using-Modules)","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Boilerplate (Using Modules)","text":"","category":"section"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"The setup of this problem is taken from Case 6 of: @article{giraldoRestelli2008a,   author = {{Giraldo},F.~X. and {Restelli},M.},   title = {A study of spectral element and discontinuous {G}alerkin methods for the {Navier-Stokes} equations in nonhydrostatic mesoscale atmospheric modeling: {E}quation sets and test cases},   journal = {J. Comput. Phys.},   year  = {2008},   volume = {227},   pages  = {3849-3877}, },","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"using ClimateMachine\nClimateMachine.init(parse_clargs = true)\n\nusing ClimateMachine.Atmos\nusing ClimateMachine.Orientations\nusing ClimateMachine.ConfigTypes\nusing ClimateMachine.Diagnostics\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.Mesh.Filters\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.TemperatureProfiles\nusing ClimateMachine.Thermodynamics\nusing ClimateMachine.TurbulenceClosures\nusing ClimateMachine.VariableTemplates\nusing StaticArrays\nusing Test\n\nusing CLIMAParameters\nusing CLIMAParameters.Atmos.SubgridScale: C_smag\nusing CLIMAParameters.Planet: R_d, cp_d, cv_d, MSLP, grav\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/#init","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Initial Conditions","text":"","category":"section"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"note: Note\nThe following variables are assigned in the initial conditionstate.ρ = Scalar quantity for initial density profile\nstate.ρu= 3-component vector for initial momentum profile\nstate.ρe= Scalar quantity for initial total-energy profile humidity","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"function init_agnesi_hs_lin!(problem, bl, state, aux, localgeo, t)\n    (x, y, z) = localgeo.coord\n\n    # Problem float-type\n    FT = eltype(state)\n\n    # Unpack constant parameters\n    R_gas::FT = R_d(bl.param_set)\n    c_p::FT = cp_d(bl.param_set)\n    c_v::FT = cv_d(bl.param_set)\n    p0::FT = MSLP(bl.param_set)\n    _grav::FT = grav(bl.param_set)\n    γ::FT = c_p / c_v\n\n    c::FT = c_v / R_gas\n    c2::FT = R_gas / c_p\n\n    # Define initial thermal field as isothermal\n    Tiso::FT = 250.0\n    θ0::FT = Tiso\n\n    # Assign a value to the Brunt-Vaisala frquencey:\n    Brunt::FT = 0.01\n    Brunt2::FT = Brunt * Brunt\n    g2::FT = _grav * _grav\n\n    π_exner::FT = exp(-_grav * z / (c_p * Tiso))\n    θ::FT = θ0 * exp(Brunt2 * z / _grav)\n    ρ::FT = p0 / (R_gas * θ) * (π_exner)^c\n\n    # Compute perturbed thermodynamic state:\n    T = θ * π_exner\n    e_int = internal_energy(bl.param_set, T)\n    ts = PhaseDry(bl.param_set, e_int, ρ)\n\n    # initial velocity\n    u = FT(10.0)\n\n    # State (prognostic) variable assignment\n    e_kin = FT(0)                                       # kinetic energy\n    e_pot = gravitational_potential(bl.orientation, aux)# potential energy\n    ρe_tot = ρ * total_energy(e_kin, e_pot, ts)         # total energy\n\n    state.ρ = ρ\n    state.ρu = SVector{3, FT}(ρ * u, 0, 0)\n    state.ρe = ρe_tot\nend\n\nfunction setmax(f, xmax, ymax, zmax)\n    function setmaxima(xin, yin, zin)\n        return f(xin, yin, zin; xmax = xmax, ymax = ymax, zmax = zmax)\n    end\n    return setmaxima\nend","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"Define a warping function to build an analytic topography:","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"function warp_agnesi(xin, yin, zin; xmax = 1000.0, ymax = 1000.0, zmax = 1000.0)\n\n    FT = eltype(xin)\n\n    ac = FT(1000)\n    hm = FT(1)\n    xc = FT(0.5) * xmax\n    zdiff = hm / (FT(1) + ((xin - xc) / ac)^2)\n\n    # Linear relaxation towards domain maximum height\n    x, y, z = xin, yin, zin + zdiff * (zmax - zin) / zmax\n    return x, y, z\nend","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/#config-helper","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Model Configuration","text":"","category":"section"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"We define a configuration function to assist in prescribing the physical model. The purpose of this is to populate the AtmosLESConfiguration with arguments appropriate to the problem being considered.","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"function config_agnesi_hs_lin(FT, N, resolution, xmax, ymax, zmax)\n    #\n    # Explicit Rayleigh damping:\n    #\n    # ``\n    #   \\tau_s = \\alpha * \\sin\\left(0.5\\pi \\frac{z - z_s}{zmax - z_s} \\right)^2,\n    # ``\n    # where\n    # ``sponge_ampz`` is the wave damping coefficient (1/s)\n    # ``z_s`` is the level where the Rayleigh sponge starts\n    # ``zmax`` is the domain top\n    #\n    # Setup the parameters for the gravity wave absorbing layer\n    # at the top of the domain\n    #\n    # u_relaxation(xvelo, vvelo, wvelo) contains the background velocity values to which\n    # the sponge relaxes the vertically moving wave\n    u_relaxation = SVector(FT(10), FT(0), FT(0))\n\n    # Wave damping coefficient (1/s)\n    sponge_ampz = FT(0.5)\n\n    # Vertical level where the absorbing layer starts\n    z_s = FT(10000.0)\n\n    # Pass the sponge parameters to the sponge calculator\n    rayleigh_sponge =\n        RayleighSponge{FT}(zmax, z_s, sponge_ampz, u_relaxation, 2)\n\n    # Define the time integrator:\n    # We chose an explicit single-rate LSRK144 for this problem\n    ode_solver = ClimateMachine.ExplicitSolverType(\n        solver_method = LSRK144NiegemannDiehlBusch,\n    )\n\n    # Setup the source terms for this problem:\n    source = (Gravity(), rayleigh_sponge)\n\n    # Define the reference state:\n    T_virt = FT(280)\n    temp_profile_ref = IsothermalProfile(param_set, T_virt)\n    ref_state = HydrostaticState(temp_profile_ref)\n    nothing # hide\n\n    _C_smag = FT(0.0)\n    model = AtmosModel{FT}(\n        AtmosLESConfigType,\n        param_set;\n        init_state_prognostic = init_agnesi_hs_lin!,\n        ref_state = ref_state,\n        turbulence = Vreman(_C_smag),\n        moisture = DryModel(),\n        source = source,\n        tracers = NoTracers(),\n    )\n\n    config = ClimateMachine.AtmosLESConfiguration(\n        \"Agnesi_NH_LINEAR\",      # Problem title [String]\n        N,                       # Polynomial order [Int]\n        resolution,              # (Δx, Δy, Δz) effective resolution [m]\n        xmax,                    # Domain maximum size [m]\n        ymax,                    # Domain maximum size [m]\n        zmax,                    # Domain maximum size [m]\n        param_set,               # Parameter set.\n        init_agnesi_hs_lin!,     # Function specifying initial condition\n        solver_type = ode_solver,# Time-integrator type\n        model = model,           # Model type\n        meshwarp = setmax(warp_agnesi, xmax, ymax, zmax),\n    )\n\n    return config\nend","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"Define a main method (entry point)","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"function main()\n\n    FT = Float64\n\n    # Define the polynomial order and effective grid spacings:\n    N = 4\n\n    # Define the domain size and spatial resolution\n    Nx = 20\n    Ny = 20\n    Nz = 20\n    xmax = FT(144000)\n    ymax = FT(4000)\n    zmax = FT(30000)\n    Δx = xmax / FT(Nx)\n    Δy = ymax / FT(Ny)\n    Δz = zmax / FT(Nz)\n    resolution = (Δx, Δy, Δz)\n\n    t0 = FT(0)\n    timeend = FT(100)\n\n    # Define the max Courant for the time time integrator (ode_solver).\n    # The default value is 1.7 for LSRK144:\n    CFL = FT(1.5)\n\n    # Assign configurations so they can be passed to the `invoke!` function\n    driver_config = config_agnesi_hs_lin(FT, N, resolution, xmax, ymax, zmax)\n    solver_config = ClimateMachine.SolverConfiguration(\n        t0,\n        timeend,\n        driver_config,\n        init_on_cpu = true,\n        Courant_number = CFL,\n    )\n\n    # Set up the spectral filter to remove the solutions spurious modes\n    # Define the order of the exponential filter: use 32 or 64 for this problem.\n    # The larger the value, the less dissipation you get:\n    filterorder = 64\n    filter = ExponentialFilter(solver_config.dg.grid, 0, filterorder)\n    cbfilter = GenericCallbacks.EveryXSimulationSteps(1) do\n        Filters.apply!(\n            solver_config.Q,\n            AtmosFilterPerturbations(driver_config.bl),\n            solver_config.dg.grid,\n            filter,\n            state_auxiliary = solver_config.dg.state_auxiliary,\n        )\n        nothing\n    end\n    # End exponential filter\n\n    # Invoke solver (calls `solve!` function for time-integrator),\n    # pass the driver, solver and diagnostic config information.\n    result = ClimateMachine.invoke!(\n        solver_config;\n        user_callbacks = (cbfilter,),\n        check_euclidean_distance = true,\n    )\n\n    # Check that the solution norm is reasonable.\n    @test FT(0.9) < result < FT(1)\n    # Some energy is lost from the sponge, so we cannot\n    # expect perfect energy conservation.\nend","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"Call main","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"main();\nnothing #hide","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"","category":"page"},{"location":"generated/Atmos/agnesi_nh_lin/","page":"Linear Non-Hydrostatic Mountain (Topography)","title":"Linear Non-Hydrostatic Mountain (Topography)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Numerics/SystemSolvers/bgmres.jl\"","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/#Batched-Generalized-Minimal-Residual","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"In this tutorial we describe the basics of using the batched gmres iterative solver. At the end you should be able to","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Use BatchedGeneralizedMinimalResidual to solve batches of linear systems\nConstruct a columnwise linear solver with BatchedGeneralizedMinimalResidual","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/#What-is-the-Generalized-Minimal-Residual-Method?","page":"Batched Generalized Minimal Residual","title":"What is the Generalized Minimal Residual Method?","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The  Generalized Minimal Residual Method (GMRES) is a Krylov subspace method for solving linear systems:","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":" Ax = b","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"See the wikipedia for more details.","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/#What-is-the-Batched-Generalized-Minimal-Residual-Method?","page":"Batched Generalized Minimal Residual","title":"What is the Batched Generalized Minimal Residual Method?","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"As the name suggests it solves a whole bunch of independent GMRES problems","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/#Basic-Example","page":"Batched Generalized Minimal Residual","title":"Basic Example","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"First we must load a few things","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"using ClimateMachine\nusing ClimateMachine.SystemSolvers\nusing LinearAlgebra, Random, Plots","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Next we define two linear systems that we would like to solve simultaneously. The matrix for the first linear system is","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"A1 = [\n    2.0 -1.0 0.0\n    -1.0 2.0 -1.0\n    0.0 -1.0 2.0\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"And the right hand side is","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"b1 = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The exact solution to the first linear system is","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x1_exact = [1.5, 2.0, 1.5];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The matrix for the first linear system is","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"A2 = [\n    2.0 -1.0 0.0\n    0.0 2.0 -1.0\n    0.0 0.0 2.0\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"And the right hand side is","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"b2 = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The exact solution to second linear system is","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x2_exact = [0.875, 0.75, 0.5];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We now define a function that performs the action of each linear operator independently.","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"function closure_linear_operator(A1, A2)\n    function linear_operator!(x, y)\n        mul!(view(x, :, 1), A1, view(y, :, 1))\n        mul!(view(x, :, 2), A2, view(y, :, 2))\n        return nothing\n    end\n    return linear_operator!\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"To understand how this works let us construct an instance of the linear operator and apply it to a vector","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"linear_operator! = closure_linear_operator(A1, A2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Let us see what the action of this linear operator is","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"y1 = ones(typeof(1.0), 3);\ny2 = ones(typeof(1.0), 3) * 2.0;\ny = [y1 y2];\nx = copy(y);\nlinear_operator!(x, y);\nx","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We see that the first column is A1 * [1 1 1]' and the second column is A2 * [2 2 2]' that is,","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"[A1 * y1 A2 * y2]","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We are now ready to set up our Batched Generalized Minimal Residual solver We must now set up the right hand side of the linear system","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"b = [b1 b2];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"as well as the exact solution, (to verify convergence)","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x_exact = [x1_exact x2_exact];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"warning: Warning\nFor BatchedGeneralizedMinimalResidual the assumption is that each column of b is independent and corresponds to a batch. This will come back later.","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We now use an instance of the solver","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"linearsolver = BatchedGeneralizedMinimalResidual(b, size(A1, 1), 2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"As well as an initial guess, denoted by the variable x","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x1 = ones(typeof(1.0), 3);\nx2 = ones(typeof(1.0), 3);\nx = [x1 x2];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"To solve the linear system, we just need to pass to the linearsolve! function","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"iters = linearsolve!(linear_operator!, nothing, linearsolver, x, b)","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"which is guaranteed to converge in 3 iterations since length(b1)=length(b2)=3 We can now check that the solution that we computed, x","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"has converged to the exact solution","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x_exact","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Which indeed it has.","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/#Advanced-Example","page":"Batched Generalized Minimal Residual","title":"Advanced Example","text":"","category":"section"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We now go through a more advanced application of the Batched Generalized Minimal Residual solver","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"warning: Warning\nIterative methods should be used with preconditioners!","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The first thing we do is define a linear operator that mimics the behavior of a columnwise operator in ClimateMachine","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"function closure_linear_operator!(A, tup)\n    function linear_operator!(y, x)\n        alias_x = reshape(x, tup)\n        alias_y = reshape(y, tup)\n        for i6 in 1:tup[6]\n            for i4 in 1:tup[4]\n                for i2 in 1:tup[2]\n                    for i1 in 1:tup[1]\n                        tmp = alias_x[i1, i2, :, i4, :, i6][:]\n                        tmp2 = A[i1, i2, i4, i6] * tmp\n                        alias_y[i1, i2, :, i4, :, i6] .=\n                            reshape(tmp2, (tup[3], tup[5]))\n                    end\n                end\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Next we define the array structure of an MPIStateArray in its true high dimensional form","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"tup = (2, 2, 5, 2, 10, 2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We define our linear operator as a random matrix","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Random.seed!(1234);\nB = [\n    randn(tup[3] * tup[5], tup[3] * tup[5])\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_A = [\n    B[i1, i2, i4, i6] + 3 * (i1 + i2 + i4 + i6) * I\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"as well as its inverse","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"columnwise_inv_A = [\n    inv(columnwise_A[i1, i2, i4, i6])\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_linear_operator! = closure_linear_operator!(columnwise_A, tup);\ncolumnwise_inverse_linear_operator! =\n    closure_linear_operator!(columnwise_inv_A, tup);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The structure of an MPIStateArray is related to its true higher dimensional form as follows:","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"mpi_tup = (tup[1] * tup[2] * tup[3], tup[4], tup[5] * tup[6]);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We now define the right hand side of our Linear system","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"b = randn(mpi_tup);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"As well as the initial guess","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x = copy(b);\nx += randn(mpi_tup) * 0.1;\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"In the previous tutorial we mentioned that it is assumed that the right hand side is an array whose column vectors all independent linear systems. But right now the array structure of x and b do not follow this requirement. To handle this case we must pass in additional arguments that tell the linear solver how to reconcile these differences. The first thing that the linear solver must know of is the higher tensor form of the MPIStateArray, which is just the tup from before","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"reshape_tuple_f = tup;\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The second thing it needs to know is which indices correspond to a column and we want to make sure that these are the first set of indices that appear in the permutation tuple (which can be thought of as enacting a Tensor Transpose).","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"permute_tuple_f = (5, 3, 4, 6, 1, 2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"It has this format since the 3 and 5 index slots are the ones associated with traversing a column. And the 4 index slot corresponds to a state. We also need to tell our solver which kind of Array struct to use","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"ArrayType = Array;\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We are now ready to finally define our linear solver, which uses a number of keyword arguments","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"gmres = BatchedGeneralizedMinimalResidual(\n    b,\n    tup[3] * tup[5] * tup[4],\n    tup[1] * tup[2] * tup[6];\n    atol = eps(Float64) * 100,\n    rtol = eps(Float64) * 100,\n    forward_reshape = reshape_tuple_f,\n    forward_permute = permute_tuple_f,\n);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"m is the number of gridpoints along a column. As mentioned previously, this is tup[3]*tup[5]*tup[4]. The n term corresponds to the batch size or the number of columns in this case. atol and rtol are relative and absolute tolerances","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"All the hard work is done, now we just call our linear solver","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"iters = linearsolve!(\n    columnwise_linear_operator!,\n    nothing,\n    gmres,\n    x,\n    b,\n    max_iters = tup[3] * tup[5] * tup[4],\n)","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We see that it converged in less than tup[3]*tup[5] = 50 iterations. Let us verify that it is indeed correct by computing the exact answer numerically and comparing it against the iterative solver.","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x_exact = copy(x);\ncolumnwise_inverse_linear_operator!(x_exact, b);\nnothing #hide","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Now we can compare with some norms","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"norm(x - x_exact) / norm(x_exact)\ncolumnwise_linear_operator!(x_exact, x);\nnorm(x_exact - b) / norm(b)","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Which we see are small, given our choice of atol and rtol. The struct also keeps a record of its convergence rate in the residual member (max over all batched solvers). The can be visualized via","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"plot(log.(gmres.resnorms[:]) / log(10));\nplot!(legend = false, xlims = (1, iters), ylims = (-15, 2));\nplot!(ylabel = \"log10 residual\", xlabel = \"iterations\")","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"","category":"page"},{"location":"generated/Numerics/SystemSolvers/bgmres/","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"This page was generated using Literate.jl.","category":"page"},{"location":"HowToGuides/Atmos/MoistureModelChoices/#Moisture-model-choices-in-Atmos.jl","page":"Moisture model","title":"Moisture model choices in Atmos.jl","text":"","category":"section"},{"location":"HowToGuides/Atmos/MoistureModelChoices/","page":"Moisture model","title":"Moisture model","text":"The moisture model in Atmos.jl describes the behavior   of suspended water in the atmosphere (i.e. water vapor,   cloud liquid water and cloud ice). There are three options available: DryModel, EquilMoist and NonEquilMoist.","category":"page"},{"location":"HowToGuides/Atmos/MoistureModelChoices/#DryModel","page":"Moisture model","title":"DryModel","text":"","category":"section"},{"location":"HowToGuides/Atmos/MoistureModelChoices/","page":"Moisture model","title":"Moisture model","text":"The DryModel assumes that air is dry and there is no water available   in any form. It does not add any water related variables to state variables.","category":"page"},{"location":"HowToGuides/Atmos/MoistureModelChoices/#EquilMoist","page":"Moisture model","title":"EquilMoist","text":"","category":"section"},{"location":"HowToGuides/Atmos/MoistureModelChoices/","page":"Moisture model","title":"Moisture model","text":"The EquilMoist assumes that water is present in the air and that   all of its phases are always in thermodynamic equilibrium. It employs an iterative search algorithm called saturation adjustment to find   the temperature at which all water phases are in equilibrium   and the corresponding q_liq and q_ice   (cloud liquid water cloud ice specific humidities). It adds ρ q_tot (air density times total water specific humidity)    to state variables. The q_liq and q_ice are diagnosed during output based on the temperature   stored in the auxiliary state.","category":"page"},{"location":"HowToGuides/Atmos/MoistureModelChoices/#NonEquilMoist","page":"Moisture model","title":"NonEquilMoist","text":"","category":"section"},{"location":"HowToGuides/Atmos/MoistureModelChoices/","page":"Moisture model","title":"Moisture model","text":"The NonEquilMoist assumes that water is present in the air,   its phases are in thermal equilibrium (i.e., they have the same temperature),   but it does not assume that the partitioning of water   into its vapor, liquid, and ice phases is in equilibrium. At each time step, the cloud liquid water and cloud ice source/sink terms   are obtained as relaxation towards equilibrium over time scale   that may eventually depend on factors such as the number of cloud condensation nuclei.   (for details see here.) This approach does not require employing iterative algorithm and   allows for supersaturation to be present in the computational domain. It adds ρ q_tot, ρ q_liq and ρ q_ice to the state variables   (air density times total water, cloud liquid water and cloud ice specific humidities). Because the assumed relaxation timescale for condensation/evaporation and   deposition/sublimation is small, it requires care when choosing the   model timestep length.","category":"page"},{"location":"HowToGuides/Atmos/MoistureModelChoices/#Implementation-notes","page":"Moisture model","title":"Implementation notes","text":"","category":"section"},{"location":"HowToGuides/Atmos/MoistureModelChoices/","page":"Moisture model","title":"Moisture model","text":"warn: Warn\nWhile recover_thermo_state is an ideal long-term solution, right now we are directly calling newthermostate to avoid inconsistent aux states in kernels where the aux states are out of sync with the boundary state.","category":"page"},{"location":"HowToGuides/Atmos/MoistureModelChoices/","page":"Moisture model","title":"Moisture model","text":"The moisture models rely on the   new_thermo_state   and   recover_thermo_state   convenience functions to create a struct that stores   air properties needed to uniquely define air thermodynamic state. For the DryModel it is the   PhaseDry   struct that has three fields:   parameter set used by the Atmos.jl model, internal energy and air density. For the EquilMoist model it is the   PhaseEquil   struct that has five fields:   parameter set used by the Atmos.jl model, internal energy, air density,   total water specific humidity and temperature at which all water phases   are in equilibrium. For the NonEquilMoist model it is the   PhaseNonEquil   struct that has four fields:   parameter set used by the Atmos.jl model, internal energy,   air density and phase partition struct. All other properties, such as the speed of sound in the air,   water vapor specific humidity,   etc, should be computed based on the thermodynamic state struct.","category":"page"},{"location":"HowToGuides/Atmos/MoistureModelChoices/","page":"Moisture model","title":"Moisture model","text":"The new_thermo_state function is called at the beginning of each time step   in the atmos_nodal_update_auxiliary_state function. For the EquilMoist model the new_thermo_state function calls   the saturation_adjustment to find the equilibrium temperature. It populates the fields of the PhaseEquil struct   and saves the equilibrium air temperature into the auxiliary state. For the DryModel and NonEquilMoist model the thermodynamic state struct   is created based on the current state variables. The recover_thermo_state function should be used throughout the code to create   an instance of the thermodynamic state struct. For the EquilMoist model it populates the PhaseEquil fields based on the   current state variables and the temperature stored in the auxiliary state. This avoids executing unnecessarily the saturation_adjustemnt algorithm. For the DryModel and NonEquilMoist model the recover_thermo_state   function is the same as the new_thermo_state function   and populates the corresponding struct fields based on   the current state variables.","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/how_to_make_a_balance_law.jl\"","category":"page"},{"location":"generated/how_to_make_a_balance_law/#How-to-make-a-Balance-law","page":"Balance Law","title":"How to make a Balance law","text":"","category":"section"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"CurrentModule = ClimateMachine.BalanceLaws","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"Defining the set of solved PDEs in ClimateMachine revolve around defining a BalanceLaw. A balance law solves equations of the form:","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"∂Y\n-- = - ∇ • ( F_{first_order}(Y) + F_{second_order}(Y, Σ) ) + S_{non_conservative}(Y, Σ)\n∂t","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"Here, Y, Σ, F_{first_order}, F_{second_order}, and S_{non_conservative} can be thought of column vectors[1] expressing:","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"Y the prognostic state variables, or unknowns of the PDEs to be solved\nΣ the gradients of functions of the prognostic state variables\nF_{first-order} contains all first-order fluxes (e.g. not functions","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"of gradients of any variables)","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"F_{second-order} contains all second-order and higher-order fluxes","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"(e.g. functions of gradients of any variables)","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"S_{non_conservative} non-conservative sources[2]","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"In order to alleviate users from being concerned with the burden of spatial discretization, users must provide their own implementations of the following methods, which are computed locally at each nodal point:","category":"page"},{"location":"generated/how_to_make_a_balance_law/#Variable-name-specification-methods","page":"Balance Law","title":"Variable name specification methods","text":"","category":"section"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"The vars_state method is used to specify the names of the variables for the following state variable types:","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"Type Purpose\nPrognostic the variables in the prognostic state vector, typically mass, momentum, and various tracers.\nAuxiliary any variables required for the balance law that aren't related to derivatives of the state variables (e.g. spatial coordinates or various integrals) or those needed to solve expensive auxiliary equations (e.g., temperature via a non-linear equation solve)\nGradient the gradients of functions of the prognostic state variables. used to represent values before and after differentiation\nGradientFlux the gradient fluxes necessary to impose Neumann boundary conditions. typically the product of a diffusivity tensor with a gradient state variable, potentially equivalent to the second-order flux for a prognostic state variable\nUpwardIntegrals any one-dimensional vertical integrals from bottom to top of the domain required for the balance law. used to represent both the integrand and the resulting indefinite integral\nDownwardIntegrals any one-dimensional vertical integral from top to bottom of the domain required for the balance law. each variable here must also exist in vars_state since the reverse integral kernels use subtraction to reverse the integral instead of performing a new integral. use to represent the value before and after reversing direction","category":"page"},{"location":"generated/how_to_make_a_balance_law/#Methods-to-compute-gradients-and-integrals","page":"Balance Law","title":"Methods to compute gradients and integrals","text":"","category":"section"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"Method Purpose\ncompute_gradient_argument! specify how to compute the arguments to the gradients. can be functions of prognostic state  and auxiliary variables.\ncompute_gradient_flux! specify how to compute gradient fluxes. can be a functions of the gradient state, the prognostic state, and auxiliary variables.\nintegral_load_auxiliary_state! specify how to compute integrands. can be functions of the prognostic state and auxiliary variables.\nintegral_set_auxiliary_state! specify which auxiliary variables are used to store the output of the integrals.\nreverse_integral_load_auxiliary_state! specify auxiliary variables need their integrals reversed.\nreverse_integral_set_auxiliary_state! specify which auxiliary variables are used to store the output of the reversed integrals.\nupdate_auxiliary_state! perform any updates to the auxiliary variables needed at the beginning of each time-step. Can be used to solve non-linear equations, calculate integrals, and apply filters.\nupdate_auxiliary_state_gradient! same as above, but after computing gradients and gradient fluxes in case these variables are needed during the update.","category":"page"},{"location":"generated/how_to_make_a_balance_law/#Methods-to-compute-fluxes-and-sources","page":"Balance Law","title":"Methods to compute fluxes and sources","text":"","category":"section"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"Method Purpose\nflux_first_order! specify F_{first_order} for each prognostic state variable. can be functions of the prognostic state and auxiliary variables.\nflux_second_order! specify F_{second_order} for each prognostic state variable. can be functions of the prognostic state, gradient flux state, and auxiliary variables.\nsource! specify S_{non_conservative}  for each prognostic state variable. can be functions of the prognostic state, gradient flux state, and auxiliary variables.","category":"page"},{"location":"generated/how_to_make_a_balance_law/#Methods-to-compute-numerical-fluxes","page":"Balance Law","title":"Methods to compute numerical fluxes","text":"","category":"section"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"Method Purpose\nwavespeed specify how to compute the local wavespeed if using the RusanovNumericalFlux.\nboundary_state! define exterior nodal values of the prognostic state and gradient flux state used to compute the numerical boundary fluxes.","category":"page"},{"location":"generated/how_to_make_a_balance_law/#Methods-to-set-initial-conditions","page":"Balance Law","title":"Methods to set initial conditions","text":"","category":"section"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"Method Purpose\ninit_state_prognostic! provide initial values for the prognostic state as a function of time and space.\ninit_state_auxiliary! provide initial values for the auxiliary variables as a function of the geometry.","category":"page"},{"location":"generated/how_to_make_a_balance_law/#General-Remarks","page":"Balance Law","title":"General Remarks","text":"","category":"section"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"While Y can be thought of a column vector (each row of which corresponds to each state variable and its prognostic equation), the second function argument inside these methods behave as dictionaries, for example:","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"struct MyModel <: BalanceLaw end\n\nfunction vars_state(m::MyModel, ::Prognostic, FT)\n    @vars begin\n        ρ::FT\n        T::FT\n    end\nend\n\nfunction source!(m::MyModel, source::Vars, args...)\n    source.ρ = 1 # adds a source of 1 to RHS of ρ equation\n    source.T = 1 # adds a source of 1 to RHS of T equation\nend","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"All equations are marched simultaneously in time.","category":"page"},{"location":"generated/how_to_make_a_balance_law/#Reference-links","page":"Balance Law","title":"Reference links","text":"","category":"section"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"[1]: Column Vectors","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"[2]: Note that using non-conservative sources should be a final resort,","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"as this can leak conservation of the unknowns and lead to numerical instabilities. It is recommended to use either F_{diffusive} or F_{non_diffusive}, as these fluxes are communicated across elements[3]","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"[3]: MPI communication occurs only across elements, not within each element,","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"where there may be many [Gauss-Lobatto][4] points","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"[4]: Gauss-Lobatto","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"","category":"page"},{"location":"generated/how_to_make_a_balance_law/","page":"Balance Law","title":"Balance Law","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Land/Heat/heat_equation.jl\"","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Heat-equation-tutorial","page":"Heat Equation","title":"Heat equation tutorial","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"In this tutorial, we'll be solving the heat equation:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"frac ρcT t +   (-α ρcT) = 0","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"t is time\nα is the thermal diffusivity\nT is the temperature\nρ is the density\nc is the heat capacity\nρcT is the thermal energy","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To put this in the form of ClimateMachine's BalanceLaw, we'll re-write the equation as:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"frac ρcT t +   (F(α ρcT t)) = 0","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"F(α ρcT t) = -α ρcT is the second-order flux","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"with boundary conditions","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Fixed temperature T_surface at z_min (non-zero Dirichlet)\nNo thermal flux at z_min (zero Neumann)","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Solving these equations is broken down into the following steps:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Preliminary configuration\nPDEs\nSpace discretization\nTime discretization / solver\nSolver hooks / callbacks\nSolve\nPost-processing","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Preliminary-configuration","page":"Heat Equation","title":"Preliminary configuration","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#Loading-code-heat","page":"Heat Equation","title":"Loading code","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"First, we'll load our pre-requisites:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"load external packages:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using MPI\nusing OrderedCollections\nusing Plots\nusing StaticArrays\nusing OrdinaryDiffEq\nusing DiffEqBase","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"load CLIMAParameters and set up to use it:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using CLIMAParameters\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"load necessary ClimateMachine modules:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using ClimateMachine\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.DGMethods\nusing ClimateMachine.DGMethods.NumericalFluxes\nusing ClimateMachine.BalanceLaws:\n    BalanceLaw, Prognostic, Auxiliary, Gradient, GradientFlux\n\nusing ClimateMachine.Mesh.Geometry: LocalGeometry\nusing ClimateMachine.MPIStateArrays\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.VariableTemplates\nusing ClimateMachine.SingleStackUtils","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"import necessary ClimateMachine modules: (importing enables us to","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"provide implementations of these structs/methods)","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"import ClimateMachine.BalanceLaws:\n    vars_state,\n    source!,\n    flux_second_order!,\n    flux_first_order!,\n    compute_gradient_argument!,\n    compute_gradient_flux!,\n    nodal_update_auxiliary_state!,\n    nodal_init_state_auxiliary!,\n    init_state_prognostic!,\n    boundary_state!\n\nimport ClimateMachine.DGMethods: calculate_dt","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Initialization","page":"Heat Equation","title":"Initialization","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Define the float type (Float64 or Float32)","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"FT = Float64;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Initialize ClimateMachine for CPU.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"ClimateMachine.init(; disable_gpu = true);\n\nconst clima_dir = dirname(dirname(pathof(ClimateMachine)));\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Load some helper functions for plotting","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"include(joinpath(clima_dir, \"docs\", \"plothelpers.jl\"));\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Define-the-set-of-Partial-Differential-Equations-(PDEs)","page":"Heat Equation","title":"Define the set of Partial Differential Equations (PDEs)","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#Define-the-model","page":"Heat Equation","title":"Define the model","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Model parameters can be stored in the particular BalanceLaw, in this case, a HeatModel:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Base.@kwdef struct HeatModel{FT, APS} <: BalanceLaw\n    \"Parameters\"\n    param_set::APS\n    \"Heat capacity\"\n    ρc::FT = 1\n    \"Thermal diffusivity\"\n    α::FT = 0.01\n    \"Initial conditions for temperature\"\n    initialT::FT = 295.15\n    \"Bottom boundary value for temperature (Dirichlet boundary conditions)\"\n    T_bottom::FT = 300.0\n    \"Top flux (α∇ρcT) at top boundary (Neumann boundary conditions)\"\n    flux_top::FT = 0.0\nend","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Create an instance of the HeatModel:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"m = HeatModel{FT, typeof(param_set)}(; param_set = param_set);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This model dictates the flow control, using Dynamic Multiple Dispatch, for which kernels are executed.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Define-the-variables","page":"Heat Equation","title":"Define the variables","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"All of the methods defined in this section were imported in Loading code to let us provide implementations for our HeatModel as they will be used by the solver.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify auxiliary variables for HeatModel","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state(::HeatModel, ::Auxiliary, FT) = @vars(z::FT, T::FT);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify prognostic variables, the variables solved for in the PDEs, for HeatModel","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state(::HeatModel, ::Prognostic, FT) = @vars(ρcT::FT);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify state variables whose gradients are needed for HeatModel","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state(::HeatModel, ::Gradient, FT) = @vars(ρcT::FT);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify gradient variables for HeatModel","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state(::HeatModel, ::GradientFlux, FT) = @vars(α∇ρcT::SVector{3, FT});\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Define-the-compute-kernels","page":"Heat Equation","title":"Define the compute kernels","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify the initial values in aux::Vars, which are available in init_state_prognostic!. Note that","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"this method is only called at t=0\naux.z and aux.T are available here because we've specified z and T","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"in vars_state given Auxiliary in vars_state","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function nodal_init_state_auxiliary!(\n    m::HeatModel,\n    aux::Vars,\n    tmp::Vars,\n    geom::LocalGeometry,\n)\n    aux.z = geom.coord[3]\n    aux.T = m.initialT\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify the initial values in state::Vars. Note that","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"this method is only called at t=0\nstate.ρcT is available here because we've specified ρcT in","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state given Prognostic","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function init_state_prognostic!(\n    m::HeatModel,\n    state::Vars,\n    aux::Vars,\n    localgeo,\n    t::Real,\n)\n    state.ρcT = m.ρc * aux.T\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The remaining methods, defined in this section, are called at every time-step in the solver by the BalanceLaw framework.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Compute/update all auxiliary variables at each node. Note that","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"aux.T is available here because we've specified T in","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state given Auxiliary","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function nodal_update_auxiliary_state!(\n    m::HeatModel,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    aux.T = state.ρcT / m.ρc\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Since we have second-order fluxes, we must tell ClimateMachine to compute the gradient of ρcT. Here, we specify how ρcT is computed. Note that","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"transform.ρcT is available here because we've specified ρcT in","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state given Gradient","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function compute_gradient_argument!(\n    m::HeatModel,\n    transform::Vars,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    transform.ρcT = state.ρcT\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify where in diffusive::Vars to store the computed gradient from compute_gradient_argument!. Note that:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"diffusive.α∇ρcT is available here because we've specified α∇ρcT in","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state given Gradient","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"∇transform.ρcT is available here because we've specified ρcT  in","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state given Gradient","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function compute_gradient_flux!(\n    m::HeatModel,\n    diffusive::Vars,\n    ∇transform::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    diffusive.α∇ρcT = -m.α * ∇transform.ρcT\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We have no sources, nor non-diffusive fluxes.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function source!(m::HeatModel, _...) end;\nfunction flux_first_order!(m::HeatModel, _...) end;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Compute diffusive flux (F(α ρcT t) = -α ρcT in the original PDE). Note that:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"diffusive.α∇ρcT is available here because we've specified α∇ρcT in","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"vars_state given GradientFlux","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function flux_second_order!(\n    m::HeatModel,\n    flux::Grad,\n    state::Vars,\n    diffusive::Vars,\n    hyperdiffusive::Vars,\n    aux::Vars,\n    t::Real,\n)\n    flux.ρcT += diffusive.α∇ρcT\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Boundary-conditions","page":"Heat Equation","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Second-order terms in our equations, (F) where F = -αρcT, are internally reformulated to first-order unknowns. Boundary conditions must be specified for all unknowns, both first-order and second-order unknowns which have been reformulated.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The boundary conditions for ρcT (first order unknown)","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function boundary_state!(\n    nf,\n    m::HeatModel,\n    state⁺::Vars,\n    aux⁺::Vars,\n    n⁻,\n    state⁻::Vars,\n    aux⁻::Vars,\n    bctype,\n    t,\n    _...,\n)\n    # Apply Dirichlet BCs\n    if bctype == 1 # At bottom\n        state⁺.ρcT = m.ρc * m.T_bottom\n    elseif bctype == 2 # At top\n        nothing\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The boundary conditions for ρcT are specified here for second-order unknowns","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function boundary_state!(\n    nf,\n    m::HeatModel,\n    state⁺::Vars,\n    diff⁺::Vars,\n    aux⁺::Vars,\n    n⁻,\n    state⁻::Vars,\n    diff⁻::Vars,\n    aux⁻::Vars,\n    bctype,\n    t,\n    _...,\n)\n    # Apply Neumann BCs\n    if bctype == 1 # At bottom\n        nothing\n    elseif bctype == 2 # At top\n        diff⁺.α∇ρcT = n⁻ * m.flux_top\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Spatial-discretization","page":"Heat Equation","title":"Spatial discretization","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Prescribe polynomial order of basis functions in finite elements","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"N_poly = 5;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify the number of vertical elements","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"nelem_vert = 10;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify the domain height","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"zmax = FT(1);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Establish a ClimateMachine single stack configuration","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"driver_config = ClimateMachine.SingleStackConfiguration(\n    \"HeatEquation\",\n    N_poly,\n    nelem_vert,\n    zmax,\n    param_set,\n    m,\n    numerical_flux_first_order = CentralNumericalFluxFirstOrder(),\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Time-discretization-/-solver","page":"Heat Equation","title":"Time discretization / solver","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Specify simulation time (SI units)","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"t0 = FT(0)\ntimeend = FT(40)","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"In this section, we initialize the state vector and allocate memory for the solution in space (dg has the model m, which describes the PDEs as well as the function used for initialization). SolverConfiguration initializes the ODE solver, by default an explicit Low-Storage Runge-Kutta method. In this tutorial, we prescribe an option for an implicit Kvaerno3 method.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"First, let's define how the time-step is computed, based on the Fourier number (i.e., diffusive Courant number) is defined. Because the HeatModel is a custom model, we must define how both are computed. First, we must define our own implementation of DGMethods.calculate_dt, (which we imported):","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function calculate_dt(dg, model::HeatModel, Q, Courant_number, t, direction)\n    Δt = one(eltype(Q))\n    CFL = DGMethods.courant(diffusive_courant, dg, model, Q, Δt, t, direction)\n    return Courant_number / CFL\nend","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Next, we'll define our implementation of diffusive_courant:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function diffusive_courant(\n    m::HeatModel,\n    state::Vars,\n    aux::Vars,\n    diffusive::Vars,\n    Δx,\n    Δt,\n    t,\n    direction,\n)\n    return Δt * m.α / (Δx * Δx)\nend","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Finally, we initialize the state vector and solver configuration based on the given Fourier number. Note that, we can use a much larger Fourier number for implicit solvers as compared to explicit solvers.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"use_implicit_solver = false\nif use_implicit_solver\n    given_Fourier = FT(30)\n\n    solver_config = ClimateMachine.SolverConfiguration(\n        t0,\n        timeend,\n        driver_config;\n        ode_solver_type = ImplicitSolverType(OrdinaryDiffEq.Kvaerno3(\n            autodiff = false,\n            linsolve = LinSolveGMRES(),\n        )),\n        Courant_number = given_Fourier,\n        CFL_direction = VerticalDirection(),\n    )\nelse\n    given_Fourier = FT(0.7)\n\n    solver_config = ClimateMachine.SolverConfiguration(\n        t0,\n        timeend,\n        driver_config;\n        Courant_number = given_Fourier,\n        CFL_direction = VerticalDirection(),\n    )\nend;\n\n\ngrid = solver_config.dg.grid;\nQ = solver_config.Q;\naux = solver_config.dg.state_auxiliary;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Inspect-the-initial-conditions","page":"Heat Equation","title":"Inspect the initial conditions","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Let's export a plot of the initial state","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"output_dir = @__DIR__;\n\nmkpath(output_dir);\n\nz_scale = 100; # convert from meters to cm\nz_key = \"z\";\nz_label = \"z [cm]\";\nz = get_z(grid; z_scale = z_scale, rm_dupes = true);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Create an array to store the solution:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"all_data = Dict[dict_of_nodal_states(solver_config; interp = true)]  # store initial condition at ``t=0``\ntime_data = FT[0]                                      # store time data\n\nexport_plot(\n    z,\n    time_data,\n    all_data,\n    (\"ρcT\",),\n    joinpath(output_dir, \"initial_condition.png\");\n    xlabel = \"ρcT\",\n    ylabel = z_label,\n    xlims = (m.initialT - 1, m.T_bottom + 1),\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"(Image: )","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"It matches what we have in init_state_prognostic!(m::HeatModel, ...), so let's continue.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Solver-hooks-/-callbacks","page":"Heat Equation","title":"Solver hooks / callbacks","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Define the number of outputs from t0 to timeend","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"const n_outputs = 5;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This equates to exports every ceil(Int, timeend/n_outputs) time-step:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"const every_x_simulation_time = ceil(Int, timeend / n_outputs);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The ClimateMachine's time-steppers provide hooks, or callbacks, which allow users to inject code to be executed at specified intervals. In this callback, a dictionary of prognostic and auxiliary states are appended to all_data for time the callback is executed. In addition, time is collected and appended to time_data.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"callback = GenericCallbacks.EveryXSimulationTime(every_x_simulation_time) do\n    push!(all_data, dict_of_nodal_states(solver_config; interp = true))\n    push!(time_data, gettime(solver_config.solver))\n    nothing\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Solve","page":"Heat Equation","title":"Solve","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This is the main ClimateMachine solver invocation. While users do not have access to the time-stepping loop, code may be injected via user_callbacks, which is a Tuple of callbacks in GenericCallbacks.","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"ClimateMachine.invoke!(solver_config; user_callbacks = (callback,));\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Append result at the end of the last time step:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"push!(all_data, dict_of_nodal_states(solver_config; interp = true));\npush!(time_data, gettime(solver_config.solver));\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Post-processing","page":"Heat Equation","title":"Post-processing","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Our solution is stored in the array of dictionaries all_data whose keys are the output interval. The next level keys are the variable names, and the values are the values along the grid:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To get T at t=0, we can use T_at_t_0 = all_data[1][\"T\"][:]","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"@show keys(all_data[1])","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Let's plot the solution:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"export_plot(\n    z,\n    time_data,\n    all_data,\n    (\"ρcT\",),\n    joinpath(output_dir, \"solution_vs_time.png\");\n    xlabel = \"ρcT\",\n    ylabel = z_label,\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"(Image: )","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"export_contour(\n    z,\n    time_data,\n    all_data,\n    \"ρcT\",\n    joinpath(output_dir, \"solution_contour.png\");\n    ylabel = \"z [cm]\",\n)","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"(Image: )","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The results look as we would expect: a fixed temperature at the bottom is resulting in heat flux that propagates up the domain. To run this file, and inspect the solution in all_data, include this tutorial in the Julia REPL with:","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"include(joinpath(\"tutorials\", \"Land\", \"Heat\", \"heat_equation.jl\"))","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"","category":"page"},{"location":"generated/Land/Heat/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#Numerical-Fluxes","page":"Numerical Fluxes","title":"Numerical Fluxes","text":"","category":"section"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/","page":"Numerical Fluxes","title":"Numerical Fluxes","text":"CurrentModule = ClimateMachine.DGMethods.NumericalFluxes","category":"page"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#Types","page":"Numerical Fluxes","title":"Types","text":"","category":"section"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/","page":"Numerical Fluxes","title":"Numerical Fluxes","text":"NumericalFluxGradient\nRusanovNumericalFlux\nRoeNumericalFlux\nHLLCNumericalFlux\nNumericalFluxFirstOrder\nNumericalFluxSecondOrder\nCentralNumericalFluxSecondOrder\nCentralNumericalFluxFirstOrder\nCentralNumericalFluxGradient","category":"page"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.NumericalFluxGradient","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.NumericalFluxGradient","text":"NumericalFluxGradient\n\nAny P <: NumericalFluxGradient should define methods for:\n\nnumericalfluxgradient!(gnf::P, balancelaw::BalanceLaw, diffF, n⁻, Q⁻, Qstategradientflux⁻, Qaux⁻, Q⁺,                             Qstategradientflux⁺, Qaux⁺, t)    numericalboundaryfluxgradient!(gnf::P, balancelaw::BalanceLaw, localstategradientflux, n⁻, localtransform⁻, localstateprognostic⁻,                                      localstateauxiliary⁻, localtransform⁺, localstateprognostic⁺, localstateauxiliary⁺, bctype, t)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.RusanovNumericalFlux","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.RusanovNumericalFlux","text":"RusanovNumericalFlux <: NumericalFluxFirstOrder\n\nThe RusanovNumericalFlux (aka local Lax-Friedrichs) numerical flux.\n\nUsage\n\nRusanovNumericalFlux()\n\nRequires a flux_first_order! and wavespeed method for the balance law.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.RoeNumericalFlux","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.RoeNumericalFlux","text":"RoeNumericalFlux() <: NumericalFluxFirstOrder\n\nA numerical flux based on the approximate Riemann solver of Roe\n\nUsage\n\nRoeNumericalFlux()\n\nRequires a custom implementation for the balance law.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.HLLCNumericalFlux","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.HLLCNumericalFlux","text":"HLLCNumericalFlux() <: NumericalFluxFirstOrder\n\nA numerical flux based on the approximate Riemann solver of the HLLC method. The HLLC flux is a modification of the Harten, Lax, van-Leer (HLL) flux, where an additional contact property is introduced in order to restore missing rarefraction waves. The HLLC flux requires model-specific information, hence it requires a custom implementation based on the underlying balance law.\n\nUsage\n\nHLLCNumericalFlux()\n\nRequires a custom implementation for the balance law.\n\n@book{toro2013riemann,\n    title={Riemann solvers and numerical methods for fluid dynamics: a practical introduction},\n    author={Toro, Eleuterio F},\n    year={2013},\n    publisher={Springer Science & Business Media}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.NumericalFluxFirstOrder","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.NumericalFluxFirstOrder","text":"NumericalFluxFirstOrder\n\nAny N <: NumericalFluxFirstOrder should define the a method for\n\nnumerical_flux_first_order!(numerical_flux::N, balance_law::BalanceLaw, flux, normal_vector⁻, Q⁻, Qaux⁻, Q⁺,\n                             Qaux⁺, t)\n\nwhere\n\nflux is the numerical flux array\nnormal_vector⁻ is the unit normal\nQ⁻/Q⁺ are the minus/positive state arrays\nt is the time\n\nAn optional method can also be defined for\n\nnumerical_boundary_flux_first_order!(numerical_flux::N, balance_law::BalanceLaw, flux, normal_vector⁻, Q⁻,\n                                      Qaux⁻, Q⁺, Qaux⁺, bctype, t)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.NumericalFluxSecondOrder","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.NumericalFluxSecondOrder","text":"NumericalFluxSecondOrder\n\nAny N <: NumericalFluxSecondOrder should define the a method for\n\nnumerical_flux_second_order!(numerical_flux::N, balance_law::BalanceLaw, flux, normal_vector⁻, Q⁻, Qstate_gradient_flux⁻, Qaux⁻, Q⁺,\n                          Qstate_gradient_flux⁺, Qaux⁺, t)\n\nwhere\n\nflux is the numerical flux array\nnormal_vector⁻ is the unit normal\nQ⁻/Q⁺ are the minus/positive state arrays\nQstate_gradient_flux⁻/Qstate_gradient_flux⁺ are the minus/positive diffusive state arrays\nQstate_gradient_flux⁻/Qstate_gradient_flux⁺ are the minus/positive auxiliary state arrays\nt is the time\n\nAn optional method can also be defined for\n\nnumerical_boundary_flux_second_order!(numerical_flux::N, balance_law::BalanceLaw, flux, normal_vector⁻, Q⁻, Qstate_gradient_flux⁻,\n                                   Qaux⁻, Q⁺, Qstate_gradient_flux⁺, Qaux⁺, bctype, t)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.CentralNumericalFluxSecondOrder","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.CentralNumericalFluxSecondOrder","text":"CentralNumericalFluxSecondOrder <: NumericalFluxSecondOrder\n\nThe central numerical flux for diffusive terms\n\nUsage\n\nCentralNumericalFluxSecondOrder()\n\nRequires a flux_second_order! for the balance law.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.CentralNumericalFluxFirstOrder","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.CentralNumericalFluxFirstOrder","text":"CentralNumericalFluxFirstOrder() <: NumericalFluxFirstOrder\n\nThe central numerical flux for nondiffusive terms\n\nUsage\n\nCentralNumericalFluxFirstOrder()\n\nRequires a flux_first_order! method for the balance law.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGMethods/NumericalFluxes/#ClimateMachine.DGMethods.NumericalFluxes.CentralNumericalFluxGradient","page":"Numerical Fluxes","title":"ClimateMachine.DGMethods.NumericalFluxes.CentralNumericalFluxGradient","text":"CentralNumericalFluxGradient <: NumericalFluxGradient\n\n\n\n\n\n","category":"type"},{"location":"APIs/InputOutput/#Input/Output","page":"Input/Output","title":"Input/Output","text":"","category":"section"},{"location":"APIs/InputOutput/","page":"Input/Output","title":"Input/Output","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/InputOutput/#ArtifactWrappers-docs","page":"Input/Output","title":"Artifact Wrappers","text":"","category":"section"},{"location":"APIs/InputOutput/","page":"Input/Output","title":"Input/Output","text":"ArtifactWrappers.ArtifactFile\nArtifactWrappers.get_data_folder\nArtifactWrappers.ArtifactWrapper","category":"page"},{"location":"APIs/InputOutput/#ClimateMachine.ArtifactWrappers.ArtifactFile","page":"Input/Output","title":"ClimateMachine.ArtifactWrappers.ArtifactFile","text":"ArtifactFile\n\nA single data file to be downloaded, containing both the url and the name to use locally.\n\nFields\n\nurl\nURL pointing to data to be downloaded\nfilename\nLocal name used for downloaded online data\n\n\n\n\n\n","category":"type"},{"location":"APIs/InputOutput/#ClimateMachine.ArtifactWrappers.get_data_folder","page":"Input/Output","title":"ClimateMachine.ArtifactWrappers.get_data_folder","text":"get_data_folder(art_wrap::ArtifactWrapper)\n\nGet local folder of dataset defined in art_wrap.\n\nExample:\n\ndataset_path = get_data_folder(dataset)\n\n\n\n\n\n","category":"function"},{"location":"APIs/InputOutput/#ClimateMachine.ArtifactWrappers.ArtifactWrapper","page":"Input/Output","title":"ClimateMachine.ArtifactWrappers.ArtifactWrapper","text":"ArtifactWrapper\n\nA set of data files to be downloaded, grouped by data_name. Example:\n\ndataset = ArtifactWrapper(\n    \"Artifacts.toml\",\n    \"MyDataSet\",\n    ArtifactFile[\n        ArtifactFile(\n            url=\"https://..../SomeNetCDF1.nc\",\n            filename=\"experiment1.nc\",\n        ),\n        ArtifactFile(\n            url=\"https://..../SomeNetCDF2.nc\",\n            filename=\"experiment2.nc\",\n        ),\n    ]\n)\n\nFields\n\nartifact_toml\nPath to the used Artifacts.toml\ndata_name\nUnique name of dataset\nartifact_files\nArray of ArtifactFile's, grouped by this dataset\n\n\n\n\n\n","category":"type"},{"location":"APIs/InputOutput/#VTK","page":"Input/Output","title":"VTK","text":"","category":"section"},{"location":"APIs/InputOutput/","page":"Input/Output","title":"Input/Output","text":"VTK.writevtk\nVTK.writepvtu","category":"page"},{"location":"APIs/InputOutput/#ClimateMachine.VTK.writevtk","page":"Input/Output","title":"ClimateMachine.VTK.writevtk","text":"writevtk(prefix, Q::MPIStateArray, dg::DGModel [, fieldnames]; number_sample_points)\n\nWrite a vtk file for all the fields in the state array Q using geometry and connectivity information from dg.grid. The filename will start with prefix which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings fieldnames; if not specified the fields names will be \"Q1\" through \"Qk\" where k is the number of states in Q, i.e., k = size(Q,2).\n\nIf specified, fields are sampled on an equally spaced, tensor-product grid of points with 'numbersamplepoints' in each direction.\n\n\n\n\n\nwritevtk(prefix, Q::MPIStateArray, dg::DGModel, fieldnames,\n         state_auxiliary::MPIStateArray, auxfieldnames)\n\nWrite a vtk file for all the fields in the state array Q and auxiliary state state_auxiliary using geometry and connectivity information from dg.grid. The filename will start with prefix which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings fieldnames and auxfieldnames.\n\nIf fieldnames === nothing then the fields names will be \"Q1\" through \"Qk\" where k is the number of states in Q, i.e., k = size(Q,2).\n\nIf auxfieldnames === nothing then the fields names will be \"aux1\" through \"auxk\" where k is the number of states in state_auxiliary, i.e., k = size(state_auxiliary,2).\n\nIf specified, fields are sampled on an equally spaced, tensor-product grid of points with 'numbersamplepoints' in each direction.\n\n\n\n\n\nwritegrid(prefix, grid::DiscontinuousSpectralElementGrid)\n\nWrite a vtk file for the grid.  The filename will start with prefix which may also contain a directory path.\n\n\n\n\n\n","category":"function"},{"location":"APIs/InputOutput/#ClimateMachine.VTK.writepvtu","page":"Input/Output","title":"ClimateMachine.VTK.writepvtu","text":"writepvtu(pvtuprefix, vtkprefixes, fieldnames, FT)\n\nWrite a pvtu file with the prefix 'pvtuprefix' for the collection of vtk files given by 'vtkprefixes' using names  of fields 'fieldnames'. The data in the vtu files is of type FT.\n\n\n\n\n\n","category":"function"},{"location":"APIs/InputOutput/#Writers","page":"Input/Output","title":"Writers","text":"","category":"section"},{"location":"APIs/InputOutput/","page":"Input/Output","title":"Input/Output","text":"Writers.init_data\nWriters.full_name\nWriters.append_data","category":"page"},{"location":"APIs/InputOutput/#ClimateMachine.Writers.init_data","page":"Input/Output","title":"ClimateMachine.Writers.init_data","text":"init_data(\n    writer,\n    filename,\n    dims,\n    vars,\n)\n\nCreates the specified file, initializing it with the specified dimension information. An unlimited time dimension is implicitly created. The specified variables are also defined. This function must be called before append_data(). Specialized by every Writer subtype.\n\nArguments:\n\n- writer: instance of a subtype of AbstractWriter.\n\n- filename: into which to write data (without extension).\n\n- dims: Dict of dimension name to 2-tuple of dimension values and Dict\n\nof attributes.\n\n- vars: Dict of variable name to 3-tuple of a k-tuple of dimension\n\nnames, variable type, and Dict of attributes.\n\n\n\n\n\n","category":"function"},{"location":"APIs/InputOutput/#ClimateMachine.Writers.full_name","page":"Input/Output","title":"ClimateMachine.Writers.full_name","text":"full_name(\n    writer,\n    filename,\n)\n\nAppends the appropriate (based on writer) extension to the specified filename.\n\n\n\n\n\n","category":"function"},{"location":"APIs/InputOutput/#ClimateMachine.Writers.append_data","page":"Input/Output","title":"ClimateMachine.Writers.append_data","text":"append_data(\n    writer,\n    filename,\n    varvals,\n    simtime,\n)\n\nAppends the specified variables to the specified file. The file must have been previously created with init_data(). simtime is appended to the time dimension variable. Specialized by every Writer subtype.\n\nArguments:\n\n- writer: instance of a subtype of AbstractWriter.\n\n- filename: into which to write data (without extension).\n\n- varvals: Dict of variable name to k-dimensional array of values.\n\n- simtime: Current simulation time.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/VariableTemplates/#Variable-Templates","page":"Variable Templates","title":"Variable Templates","text":"","category":"section"},{"location":"APIs/Utilities/VariableTemplates/","page":"Variable Templates","title":"Variable Templates","text":"CurrentModule = ClimateMachine.VariableTemplates","category":"page"},{"location":"APIs/Utilities/VariableTemplates/#Types","page":"Variable Templates","title":"Types","text":"","category":"section"},{"location":"APIs/Utilities/VariableTemplates/","page":"Variable Templates","title":"Variable Templates","text":"Grad\nVars","category":"page"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.Grad","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.Grad","text":"Grad{S,A,offset}(array::A)\n\nDefines property overloading along slices of the second dimension of array using the type S as a template. offset is used to shift the starting element of the array.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.Vars","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.Vars","text":"Vars{S,A,offset}(array::A)\n\nDefines property overloading for array using the type S as a template. offset is used to shift the starting element of the array.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Utilities/VariableTemplates/#Index-methods","page":"Variable Templates","title":"Index methods","text":"","category":"section"},{"location":"APIs/Utilities/VariableTemplates/","page":"Variable Templates","title":"Variable Templates","text":"@vars\nvuntuple\nunroll_map\nflattened_tup_chain\nvarsize\nvarsindices\nvarsindex","category":"page"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.@vars","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.@vars","text":"@vars(var1::Type1, var2::Type2)\n\nA convenient syntax for describing a NamedTuple type.\n\nExample\n\njulia> @vars(a::Float64, b::Float64)\nNamedTuple{(:a, :b),Tuple{Float64,Float64}}\n\n\n\n\n\n","category":"macro"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.vuntuple","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.vuntuple","text":"vuntuple(f::F, N::Int)\n\nVal-Unroll ntuple: wrap ntuple arguments in Val for unrolling.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.unroll_map","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.unroll_map","text":"@unroll_map(f::F, N::Int, args...) where {F}\nunroll_map(f::F, N::Int, args...) where {F}\n\nUnroll N-expressions and wrap arguments in Val.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.flattened_tup_chain","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.flattened_tup_chain","text":"flattened_tup_chain(::Type{T}) where {T <: Union{NamedTuple,NTuple}}\n\nAn array of tuples, containing symbols and integers for every combination of each field in the Vars array.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.varsize","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.varsize","text":"varsize(S)\n\nThe number of elements specified by the template type S.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.varsindices","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.varsindices","text":"varsindices(S, ps::Tuple)\nvarsindices(S, ps...)\n\nReturn a tuple of indices corresponding to the properties specified by ps based on the template type S. Properties can be specified using either symbols or strings.\n\nExamples\n\njulia> S = @vars(x::Float64, y::Float64, z::Float64)\njulia> varsindices(S, (:x, :z))\n(1, 3)\n\njulia> S = @vars(x::Float64, y::@vars(α::Float64, β::SVector{3, Float64}))\njulia> varsindices(S, \"x\", \"y.β\")\n(1, 3, 4, 5)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/VariableTemplates/#ClimateMachine.VariableTemplates.varsindex","page":"Variable Templates","title":"ClimateMachine.VariableTemplates.varsindex","text":"varsindex(S, p::Symbol, [sp::Symbol...])\n\nReturn a range of indices corresponding to the property p and (optionally) its subproperties sp based on the template type S.\n\nExamples\n\njulia> S = @vars(x::Float64, y::Float64)\njulia> varsindex(S, :y)\n2:2\n\njulia> S = @vars(x::Float64, y::@vars(α::Float64, β::SVector{3, Float64}))\njulia> varsindex(S, :y, :β)\n3:5\n\n\n\n\n\n","category":"function"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"newcommandparamT1       text1\nnewcommandhyperparamT1text1\nnewcommandsimparamT1  text1\n\nnewcommandexp1mathrmexpleft(1right)\nnewcommandatan1mathrmatanleft(1right)\nnewcommandsign1mathrmsignleft(1right)\nnewcommanderf1mathrmerfleft(1right)\nnewcommanderfinv1mathrmerfinvleft(1right)\n\nnewcommandparam1     1\nnewcommandhyperparam11\nnewcommandsimparam1  1\n\nnewcommandCROSStimes\nnewcommandGRADnabla\nnewcommandDOTbullet\nnewcommandPDpartial\nnewcommandPDFzfracPDPD z\nnewcommandDM1langle 1 rangle\nnewcommandiEnve\nnewcommandSD2overline1_2\nnewcommandSDi1SD1i\nnewcommandSDj1SD1j\nnewcommandSDe1SD1iEnv\nnewcommandSDiog21_2\nnewcommandSDio1SDiog1i\nnewcommandSDjo1SDiog1j\nnewcommandSDeo1SDiog1iEnv\nnewcommandaSD21_2\nnewcommandaSDi1aSD1i\nnewcommandaSDj1aSD1j\nnewcommandaSDe1aSD1iEnv\nnewcommandotherDefswhere additional variable definitions are in\n\nnewcommandIntraCVSDi2overline1_i      2_i      \nnewcommandIntraCVSDj2overline1_j      2_j      \nnewcommandIntraCVSDe2overline1_iEnv2_iEnv\n\nnewcommandInterCVSDi2overline1_i      overline2_i      \nnewcommandInterCVSDj2overline1_j      overline2_j      \nnewcommandInterCVSDe2overline1_iEnvoverline2_iEnv\n\nnewcommandTCV2langle 1^*2^* rangle\n\nnewcommandBC11_z_min\nnewcommandBCT11_z_max\nnewcommandBCB11_z_min\nnewcommandBCG11_z_boundary\n\nnewcommandKmK^m\nnewcommandKhK^h\nnewcommandTEquilibT_mathrmiterated\nnewcommandPhasePartitionq\nnewcommandExnerDPi_dry\nnewcommandExnerMPi_moist\nnewcommandWindSpeedu\nnewcommandLayerThicknessparamDelta z\nnewcommandSurfaceRoughness1paramz_01\nnewcommandSensibleSurfaceHeatFluxF_mathrmsensible\nnewcommandLatentSurfaceHeatFluxF_mathrmlatent\nnewcommandFrictionVelocityu_*\nnewcommandBuoyancyb\nnewcommandBuoyancyGradPD_z Buoyancy\nnewcommandBuoyancyFluxIntraCVSDiwb\nnewcommandTemperatureScaletheta_*\nnewcommandSurfaceMomentumFluxBCoverlinewu\nnewcommandSurfaceHeatFluxBCoverlinewtheta\nnewcommandSurfaceBuoyancyFluxBCIntraCVSDiwtheta\nnewcommandConvectiveVelocityw_*  Convective velocity near the surface\nnewcommandInversionHeightz_*\nnewcommandMOLenLambda_M-O\nnewcommandzLLparamz_  z at the first surface level (we should make this grid-independent)\n\nnewcommandqtq_mathrmtot\nnewcommandqrq_mathrmrain\nnewcommandqlq_mathrmliq\nnewcommandqiq_mathrmice\nnewcommandqvq_mathrmvap\nnewcommandqvsatq_mathrmvap^*\nnewcommandpvsatp_mathrmvap^*\nnewcommandqcq_mathrmcon\nnewcommandThetaVaptheta_mathrmvap\nnewcommandThetaVirttheta_mathrmvirt\nnewcommandThetaRhotheta_rho\nnewcommandThetaLiqtheta_mathrmliq\nnewcommandThetaLiqIcetheta_mathrmliq-ice\nnewcommandThetaLiqIceSattheta^*_mathrmliq-ice\nnewcommandThetaDrytheta_mathrmdry\nnewcommandTDryT_dry\nnewcommandeinte_mathrmint\nnewcommandetote_mathrmtot\n\nnewcommandTRefT_0\nnewcommandalphaRefalpha_0\nnewcommandrhoRefrho_0\nnewcommandpRefp_0\nnewcommandHeavisidemathcal H\n\nnewcommandalphaLLalphaRef_zLL\nnewcommanduHsimparammathbfu_h\n\nnewcommandCoriolisParamhyperparammathrmcoriolis_param\nnewcommandSubsidenceParamhyperparammathrmsubsidence\nnewcommandbetaMhyperparambeta_m\nnewcommandbetaHhyperparambeta_h\nnewcommandgammaMhyperparamgamma_m\nnewcommandgammaHhyperparamgamma_h\n\nnewcommandPTildeparamtildep\nnewcommandVKConstparamkappa_mathrmVon-Karman\nnewcommandNsdhyperparamN_sd\nnewcommandgravparamg\nnewcommandTZeroparamT_0\nnewcommandRefHintVparameint_v0\nnewcommandRefHintIparameint_i0\n\nnewcommandEpsDVparamvarepsilon_dv\nnewcommandEpsVDparamvarepsilon_vd\nnewcommandRmR_m\nnewcommandCpmc_pm\nnewcommandCvmc_vm\nnewcommandRdparamR_d\nnewcommandRvparamR_v\nnewcommandCp1paramc_p1\nnewcommandCv1paramc_v1\nnewcommandCvdCvd\nnewcommandCvvCvv\nnewcommandCvlCvl\nnewcommandCviCvi\n\nnewcommandDeltaCpparamDelta c_p\nnewcommandTTripleparamT_mathrmtr\nnewcommandPTripleparamp_mathrmtr\nnewcommandTFreezeparamT_mathrmfreeze\n\nnewcommandRefLHvparamL_v0\nnewcommandRefLHsparamL_s0\nnewcommandRefLHfparamL_f0\nnewcommandLatentHeatV1L_vap(1)\nnewcommandLatentHeatS1L_sub(1)\nnewcommandLatentHeatF1L_fus(1)","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Eddy-Diffusivity-Mass-Flux-(EDMF)-parameterization","page":"EDMF equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) parameterization","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"This document describes the Eddy-Diffusivity Mass-Flux (EDMF) parameterization for subgrid-scale (SGS) turbulence and convection. The model equations and rationale are based on: Tan et al. (2018); Cohen et al. (2020); Lopez-Gomez et al. (2020). The key predictands of the EDMF parameterization are the SGS vertical fluxes of heat, moisture and momentum, and the cloud fraction in the host model grid. The EDMF parameterization divides the host model's grid into N ge 2 subdomains that represent an isotropic turbulent enviroment and coherent updraft(s) and or downdraft(s). The parameterization solves prognostic equations for first and second moments in the subdomains to provide both the abovementioned SGS vertical fluxes and cloud fraction in the host model grid.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"In this document, color-coding is used to indicate:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"paramTConstant parameters that are fixed in space and time (eg those defined in CLIMAParametersjl)\nsimparamTSingle column (SC) inputs (eg variables that are fed into the SC model from the dynamical core (eg horizontal velocity))\nhyperparamTTunable hyper-parameters that will need to be changeable but will only include single numbers (eg Float64)","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Subdomain-decomposition","page":"EDMF equations","title":"Subdomain decomposition","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The EDMF is 1D model in z that solves for the statistical distribution in the grid box of the host model. As such in the EDMF there is no spatial discretization in the horizontal directions (x and y), the horizontal space is broken into Nsd (sim 1-5) \"subdomains\" (SDs), denoted by subscript i, where 1 le i le Nsd. One of the subdomains, the \"environment\", is treated different compared to others, termed \"updrafts\" (and or \"downdrafts\"). This environment subdomain is denoted with a special index iEnv (which we usually set to 0). For dummy variables phi and psi, we use several domain and SD representations of interest:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\n  SDiphi                                                                                   quad  texthorizontal mean of variable phi over subdomain i \n  SDiphi = phi_i - SDiphi                                                            quad  textfluctuations of phi about the subdomain mean \n  IntraCVSDiphipsi                                                                      quad  textintra subdomain covariance \n  DMphi = sum_i aSDia SDiphi                                                       quad  texthorizontal mean of phi over the total domain \n  SDiphi^* = SDiphi - DMphi                                                        quad  textdifference between subdomain  domain means \n  InterCVSDiphipsi                                                                      quad  textinter subdomain covariance among subdomain means \n  phi^* = phi - DMphi                                                                    quad  textdifference between subdomain  domain means \n  TCVphipsi = sum_forall i a_i IntraCVSDiphipsi +\n  sum_forall i sum_forall j  aSDia aSDja SDiphi(SDipsi - SDjpsi)     quad  texttotal covariance\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Here, SDiphi and SDipsi are a dummy variables for the following 7 unknowns:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\n  SDiw                    quad textvertical velocity \n  SDieint                quad textinternal energy  \n  SDiqt                  quad texttotal water specific humidity  \n  SDiTKE                  quad textturbulent kinetic energy (05(IntraCVSDiuu+IntraCVSDivv+IntraCVSDiww))  \n  IntraCVSDieinteint  quad textintra subdomain covariance of eint and eint  \n  IntraCVSDiqtqt      quad textintra subdomain covariance of qt and qt \n  IntraCVSDieintqt    quad textintra subdomain covariance of eint and qt\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"From the large-scale model perspective, DMphi represents the resolved grid mean, and TCVphipsi represents the SGS fluxes and (co)-variances of scalars that need to be parameterized. Equations in the following sections, \\eqref{eq:AreaFracGov}, \\eqref{eq:1stMoment} and \\eqref{eq:2ndMoment}, are solved on z_min le z le z_max and t ge 0. There are 8 Nsd equations in total.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Domain-averaged-equations","page":"EDMF equations","title":"Domain averaged equations","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The EDMF model can be used in the context of a stand-alone single column, or integrated with a dynamical core. Either way, the EDMF model relies on grid mean variables, which may be prescribed or solved for. Taking an area fraction-weighted average of the subdomain equations yields the domain-averaged equations (which should be consistent with variables in the dynamical core).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The domain-averaged equations for DMphi in w qt eint uH are:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPD_t (rhoRef DMphi)\n+ PD_z (rhoRef DMw DMphi)\n+ nabla_h DOT left( rhoRef DMphi otimes DMphi right)\n= \n  DMS_textdiff^DMphi\n+ DMS_textpress\n+ DMS_textcoriolis\n+ DMS_textsubsidence\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nDMS_textdiff^DMphi  = PD_z (rhoRef aSDea SDeKm PD_z DMphi)   labeleqgm_diffusion \nDMS_textdiff^w          = PD_z (rhoRef aSDea SDeKm PD_z DMw)      labeleqgm_diffusion_w \nDMS_textpress             = - GRAD_h DMp                                       labeleqgm_pressure \nDMS_textcoriolis          = CoriolisParam DMphi CROSS mathbfk             labeleqgm_coriolis \nDMS_textsubsidence        = - SubsidenceParam GRAD phi                          labeleqgm_subsidence \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Sub-domain-equations:-Area-fraction","page":"EDMF equations","title":"Sub-domain equations: Area fraction","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The EDMF equations take the form of advection-diffusion equations. The subdomain area fraction is given by the mass continuity equation in the ith subdomain (aSDia):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"begingather\n  PD_t (rhoRef aSDia)\n  + PD_z (rhoRef aSDia SDiw)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH)\n  =\n  SDiS^a\n   quad i ne iEnv labeleqAreaFracGov \n  aSDia = 1 - sum_jneiEnv aSDja quad i = iEnv labeleqAreaFracConserve \n  qquad 0  aSDia  1 labeleqAreaFracConstraint\nendgather","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Here, rhoRef SDiw uH is fluid density, mean vertical velocity along z, and domain-mean of the horizontal velocity respectively. The area fraction constraints are necessary to ensure the system of equations is well-posed. All source terms (SDiS^a) will be discussed in later sections.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"note: Note\nThe greater than zero constraint must be satisfied at every step of the solution process, since it is necessary to avoid division by zero in the mean field equations.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^a = SDiS_epsilondelta^a\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-term-definitions","page":"EDMF equations","title":"Source term definitions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"We note that the net exchange is zero sum_i SDiS_epsilondelta^a = 0. Therefore, we may define the environment source term as the negative sum of all updraft source terms. The entrainment-detrainment source is:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS_epsilondelta^a =\nbegincases\n  rho a_i SDiw left( -delta_i + epsilon_i right)  i ne iEnv \n  0 - sum_j ne iEnv SDjS_epsilondelta^a  i = iEnv \nendcases\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Sub-domain-equations:-1st-moment","page":"EDMF equations","title":"Sub-domain equations: 1st moment","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The 1st moment sub-domain equations are:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleq1stMoment\n  PD_t (rhoRef aSDia SDiphi)\n  + PD_z (rhoRef aSDia SDiw SDiphi)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH SDiphi)\n  =\n  SDiS^phi\n   quad forall i \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Here, SDiS^phi are source terms, including diffusion, and many other sub-grid-scale (SGS) physics. In general, SDiS^phi and SDiS^a may depend on SDjphi and or aSDja for any j.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-terms-per-equation","page":"EDMF equations","title":"Source terms per equation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The source terms common to all unknowns are:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^phi =\n  SDiS_epsilondelta^phi\n+ SDiS_textturb-transp^phi quad forall phi\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Additional source terms exist in other equations:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^w =\n  SDiS_epsilondelta^w\n+ SDiS_textturb-transp^w\n+ SDiS_textbuoy\n+ SDiS_textnh-press\n+ SDiS_textcoriolis \nSDiS^eint =\n  SDiS_epsilondelta^eint\n+ SDiS_textturb-transp^eint\n+ SDiS_textMP-MSS^eint\n+ SDiS_textrad \nSDiS^qt =\n  SDiS_epsilondelta^qt\n+ SDiS_textturb-transp^qt\n+ SDiS_textMP-MSS^qt\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-term-definitions-2","page":"EDMF equations","title":"Source term definitions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Note: The sum of the total pressure and gravity are recast into the sum of the non-hydrostatic pressure and buoyancy sources.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS_epsilondelta^phi =\nbegincases\n  rhoRef a_i SDiw left( -delta_i SDiphi + epsilon_i SDephi right)  i ne iEnv \n  0 - sum_j ne iEnv SDjS_epsilondelta^phi  i=iEnv \nendcases \nSDiS_textturb-transp^phi  =  -PD_z (rhoRef a_i IntraCVSDiwphi) \n  = PD_z (rhoRef a_i SDiKm PD_z SDiphi) \nSDiS_textnh-press = -rhoRef aSDia left( alpha_b SDib  + alpha_d frac(SDiw - SDew)  SDiw - SDew  r_d aSDia^12 right) \nalpha_b = 13 quad alpha_d = 0375 quad r_d      = 500 m \nSDiS_textbuoy = rhoRef aSDia SDib \nSDiS_textcoriolis  = f(SDimathbfu - SDimathbfu_textgeo-wind) \nSDiS_textrad  = left( PD_t SDieint right)_radiation \nSDiS_textMP-MSS^qt  = \nSDiS_textMP-MSS^eint  = \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).\nBuoyancy (Buoyancy).\nEddy diffusivity (Km Kh).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Sub-domain-equations:-2nd-moment","page":"EDMF equations","title":"Sub-domain equations: 2nd moment","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The 2nd moment sub-domain equations are of the exact same form as the 1st moment equations (equation \\eqref{eq:1stMoment}):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleq2ndMoment\n  PD_t (rhoRef aSDia SDiphi)\n  + PD_z (rhoRef aSDia SDiw SDiphi)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH SDiphi)\n  =\n  SDiS^phi\n   quad forall i \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Here, SDiS^phi are source terms, including diffusion, and many other sub-grid-scale (SGS) physics. In general, SDiS^phi and SDiS^a may depend on SDjphi and or aSDja for any j.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-terms-per-equation-2","page":"EDMF equations","title":"Source terms per equation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The source terms common to all unknowns are:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^phipsi =\n  SDiS_epsilondelta^phipsi\n+ SDiS_textx-grad flux^phipsi\n+ SDiS_textturb-transp^phipsi\nquad forall phi psi\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Additional source terms exist in other equations:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^TKE =\n  SDiS_epsilondelta^TKE\n+ SDiS_textx-grad flux^TKE\n+ SDiS_textturb-transp^TKE\n+ SDiS_textdissip\n+ SDiS_textpress\n+ SDiS_textbuoyancy \nSDiS^phipsi =\n  SDiS_epsilondelta^phipsi\n+ SDiS_textx-grad flux^phipsi\n+ SDiS_textturb-transp^phipsi\n+ SDiS_textdissip^phipsi\n+ SDiS_textMP-MSS^phipsi\nquad phipsi in qtqt einteint eint qt\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-term-definitions-3","page":"EDMF equations","title":"Source term definitions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS_epsilondelta^phipsi =\nbegincases\n  rhoRef a_i SDiw left -delta_i IntraCVSDiphipsi + epsilon_i\nleft(\nIntraCVSDephipsi + (SDephi - SDiphi)(SDepsi - SDipsi)\nright) right  i ne iEnv \n  0 - sum_jne iEnv SDjS_epsilondelta^phipsi  i=iEnv \nendcases \nSDiS_epsilondelta^TKE =\nbegincases\n  rhoRef a_i SDiw left -delta_i SDiTKE + epsilon_i\nleft(\nSDeTKE + frac12 (SDew - SDiw)^2\nright) right  i ne iEnv \n  0 - sum_jne iEnv SDjS_epsilondelta^TKE  i=iEnv \nendcases \nSDiS_textx-grad flux^phipsi\n =\n- rhoRef a_i IntraCVSDiwpsi PD_z SDiphi\n- rhoRef a_i IntraCVSDiwphi PD_z SDipsi \n =\n 2 rhoRef a_i SDiKh PD_z SDipsi PD_z SDiphi \nSDiS_textx-grad flux^TKE\n =\nrhoRef a_i SDiKm left left(PD_zDMuright)^2 + left(PD_zDMvright)^2 + left(PD_zDMwright)^2 right \nSDiS_textturb-transp^phipsi  = - PD_z (rhoRef a_i overlinew_iphi_ipsi_i) \n = PD_z (rhoRef a_i SDiKh PD_z IntraCVSDiphipsi) \nSDiS_textturb-transp^TKE  = PD_z (rhoRef a_i SDiKm PD_z SDiTKE) \nSDiS_textdissip\n = - rhoRef a_i c_e IntraCVSDiphipsi fracSDiTKE^12SDiol_mix quad textEquation 38 in Tan et al \nc_e  = 2 \nSDiS_textpress\n = - aSDia left IntraCVSDiu(partial_x p^dagger) +\n                      IntraCVSDiv(partial_y p^dagger) +\n                      IntraCVSDiw(partial_z p^dagger)right  \n = 0 qquad textfor now need to derive correct formulation \nSDiS_textbuoyancy^TKE  = rhoRef aSDia BuoyancyFlux \nSDiS_textMP-MSSP^qtqt\n = \nSDiS_textMP-MSSP^einteint\n = \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).\nEddy diffusivity (Km Kh).\nMixing length (l_mix).\nBuoyancy flux (BuoyancyFlux).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#EDMF-variable-definitions","page":"EDMF equations","title":"EDMF variable definitions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"The following definitions are ordered in a dependency fashion; all variables are defined from variables already defined in previous subsections.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Constants","page":"EDMF equations","title":"Constants","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nc_K  = 01 \ntexttol_InversionHeightmathrm-stable  = 001 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Phase-partition","page":"EDMF equations","title":"Phase partition","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPhasePartition = qv ql qi \nqv = qt - ql - qi \npvsat(T) = PTriple left( fracTTTriple right)^fracDeltaCpRv expfracRefLHv - DeltaCp TZeroRv left( frac1TTriple - frac1T right) labeleqpvsat \nqvsat(T rho) = fracpvsat(T)rho Rv T                                                                                                                            labeleqqvsat \nqc = max(qt - qvsat 0)                                                                                                                                               labeleqqc \nql = lambda qc                                                                                                                                                         labeleqql \nqi = (1-lambda) qc                                                                                                                                                     labeleqqi \nlambda(T) = Heaviside(T-TFreeze)                                                                                                                                       labeleqlambda \nHeaviside = textHeaviside function \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Functionally,","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPhasePartition  = PhasePartition(qt T rho) \nqvsat  = qvsat(T rho) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Gas-constants","page":"EDMF equations","title":"Gas constants","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nEpsDV  = fracRvRd approx 161 \nEpsVD  = fracRdRv approx 062 \nRm  = Rd left1 + (EpsDV-1) qt - EpsDV (ql+qi) right \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Specific-heats","page":"EDMF equations","title":"Specific heats","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nCvm = (1 - SDiqt) Cvd + SDiqv Cvv + SDiql Cvl + SDiqi Cvi \nCpm = (1 - SDiqt) Cpd + SDiqt Cpv \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Latent-heat","page":"EDMF equations","title":"Latent heat","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nLatentHeatVT = RefLHv + (Cpv - Cpl) (T - TTriple) \nLatentHeatST = RefLHs + (Cpv - Cpi) (T - TTriple) \nLatentHeatFT = RefLHf + (Cpl - Cpi) (T - TTriple) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Exner-functions","page":"EDMF equations","title":"Exner functions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nExnerD(pRef)    = left(fracpRefPTilde right)^RdCpd \nExnerM(pRef PhasePartition) = left(fracpRefPTilde right)^RmCpm \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Specific heats Cpm and Cvm.\nGas constants (Rm).\nPhase partition PhasePartition qt qv ql qi qvsat.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Temperature","page":"EDMF equations","title":"Temperature","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Note that, while temperature may be computed using different thermodynamic formulations, ThermodynamicState's are immediately converted to the (qt eint rhoRef)-formulation.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Dry-temperature","page":"EDMF equations","title":"Dry temperature","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nTDry  = ThetaLiqIce ExnerD \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Exner functions ExnerD and ExnerM.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Functionally,","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nTDry  = TDry(ThetaLiqIce pRef) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#(\\qt,-\\eint,-\\rhoRef{})-formulation","page":"EDMF equations","title":"(qt eint rhoRef)-formulation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Here, T conditionally satisfies the non-linear set of equations, which can be solved using a standard root solver (e.g., Secant method):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nT =\nbegincases\nmathrmsatisfies  eint(T) = Cvm (T - TZero)  + qv RefHintV - qi RefHintI  qt  qvsat(T rhoRef) \n TZero + fraceint(T)(1-qt)Cvd + qt Cvv + qt RefHintV  textotherwise \nendcases\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Phase partition PhasePartition qt qv ql qi qvsat.\nSpecific heats Cpm and Cvm.\nReference state profiles (pRef, rhoRef, and alphaRef).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Functionally,","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nT  = T(qt eint rhoRef) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#(\\qt,-\\ThetaLiqIce,-\\rhoRef,-\\pRef)-formulation","page":"EDMF equations","title":"(qt ThetaLiqIce rhoRef pRef)-formulation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Here, T conditionally satisfies the non-linear set of equations, which can be solved using a standard root solver (e.g., Secant method):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nT =\nbegincases\nmathrmsatisfies  ThetaLiqIce ExnerM = T left(1 - frac RefLHv ql + RefLHs qiCpm T right)  qt  qvsat(T rhoRef) \n TDry  textotherwise \nendcases\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Dry temperature TDry.\nPhase partition PhasePartition qt qv ql qi qvsat.\nSpecific heats Cpm and Cvm.\nExner functions ExnerD and ExnerM.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Functionally,","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nT  = T(qt ThetaLiqIce rhoRef pRef) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Reference-state-profiles","page":"EDMF equations","title":"Reference state profiles","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Using the hydrostatic balance, PD_z pRef = - rhoRef grav, and the ideal gas law, pRef = rhoRef Rm TRef, the reference state profiles are computed as:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPD_z pRef  = - grav fracpRefTRef Rm \nint_BCpRef^pRef fracTDry(BCDMThetaLiqIce pRef)pRef PD pRef  = - fracgravBCDMRm int_z_min^z PD z \nrhoRef(pRef)  = fracpRefTDry(BCDMThetaLiqIce pRef) BCDMRm \nalphaRef  = frac1rhoRef(pRef) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Temperature (T and TDry).\nGas constants (Rm).\nSpecific heats Cpm and Cvm.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Mixing-ratios","page":"EDMF equations","title":"Mixing ratios","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqMixingRatios\nr_con  = fracqt+ql1 - qt \nr_vap  = fracqt-ql    - qi1 - qt \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Potential-temperatures","page":"EDMF equations","title":"Potential temperatures","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Fix: which virtual potential temperature is used","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqTheta\nThetaDry     = TExnerD \nThetaLiqIce  = ThetaDry (1 - (RefLHv ql + RefLHs qi)(Cpm T)) \nThetaVirt    = ThetaDry (1 - r_con + 061 r_vap) \nThetaVirt    = theta left(1 + 061 qr - ql right) \nThetaRho     = T RmExnerD \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nExner functions (ExnerM).\nMixing ratios (r_con, r_vap).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Shear-production","page":"EDMF equations","title":"Shear production","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqShearProduction\nS^2 = (PD_z DMu)^2 + (PD_z DMv)^2 + (PD_z SDew)^2 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Buoyancy","page":"EDMF equations","title":"Buoyancy","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqBuoyancy\nSDib^dagger  = grav (SDialpha - alphaRef)alphaRef \nSDib  = SDib^dagger - sum_j a_j SDjb^dagger \nalpha_i  = fracSDiRm SDiTpRef \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nPhase partition PhasePartition qt qv ql qi qvsat.\nTemperature (T and TDry).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Buoyancy-gradient","page":"EDMF equations","title":"Buoyancy gradient","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#(\\qt,-\\ThetaLiqIce,-\\pRef,-\\rhoRef)-formulation","page":"EDMF equations","title":"(qt ThetaLiqIce pRef rhoRef)-formulation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqBuoyancyGradLong\nSDiBuoyancyGrad  = PD_z SDiThetaLiqIce\nleft (1-f_c) PD_ThetaLiqIce b _d  + f_c PD_ThetaLiqIce b _s right +\nPD_z SDiqt      left (1-f_c) PD_qt b _d + f_c PD_qt b _s right \nf_c = 0 qquad textgood for simple cases need to confirm for more complex cases \nPD_ThetaLiqIce b _d  = fracgravDMThetaVirt left 1 + left( fracRvRd - 1 right) SDiqt right \nPD_ThetaLiqIce b _s = fracgravDMThetaVirt left 1 + fracRvRd left(1 + fracLatentHeatVSDiTRv SDiT right) SDiqvsat - SDiqt right left( 1 + fracLatentHeatVSDiT^2Cpm Rv SDiT^2 SDiqvsat right)^-1 \nPD_qt b _d = fracgravDMThetaVirt left( fracRvRd - 1 right) SDiThetaDry \nPD_qt b _s = left( fracLatentHeatVSDiTCpm SDiT PD_ThetaLiqIce b _s - fracgravDMThetaVirt right) SDiThetaDry \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nPotential temperatures (ThetaDry, ThetaVirt).\nPhase partition PhasePartition qt qv ql qi qvsat.\nLatent heat (LatentHeatVT).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#(\\qt,-\\eint,-\\rhoRef{})-formulation-2","page":"EDMF equations","title":"(qt eint rhoRef)-formulation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Pending.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Surface-fluxes","page":"EDMF equations","title":"Surface fluxes","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"todo: Todo\nAdd definitions for universal functions (e.g., Psi_m).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Variables in this section must be computed simultaneously because it requires the solution of a non-linear equation.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Monin-Obhukov-length","page":"EDMF equations","title":"Monin-Obhukov length","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqMOLen\nMOLen = begincases\n- fracFrictionVelocity^3 thetaVKConst grav SurfaceHeatFlux  SurfaceHeatFlux  0 \n0  textotherwise \nendcases \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Friction-velocity","page":"EDMF equations","title":"Friction velocity","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Knowns: u_mathrmave = sqrtDMu^2+DMv^2 LayerThickness SurfaceRoughnessm\nUnknowns: FrictionVelocity MOLen, and SurfaceMomentumFlux","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqFrictionVelocity\nu_mathrmave      = fracFrictionVelocityVKConst    left logleft(fracLayerThicknessSurfaceRoughnessmright) - Psi_mleft(fracLayerThicknessMOLenright) + fracSurfaceRoughnessmLayerThickness Psi_mleft(fracSurfaceRoughnessmMOLenright) + R_z0m left psi_mleft(fracSurfaceRoughnessmMOLenright) - 1 right right \nR_z0m               = 1 - SurfaceRoughnesshLayerThickness \nSurfaceMomentumFlux  = -FrictionVelocity^2                 labeleqSurfaceMomentumFlux  \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where Psi_m is defined in Appendix A, equations A6 in Nishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin‐Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Temperature-scale","page":"EDMF equations","title":"Temperature scale","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Knowns: theta_mathrmave theta_s LayerThickness SurfaceRoughnessh\nUnknowns: FrictionVelocity MOLen, and SurfaceHeatFlux","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqTemperatureScale\ntheta_mathrmave - theta_s  = fracPr TemperatureScaleVKConst left logleft(fracLayerThicknessSurfaceRoughnesshright) - Psi_hleft(fracLayerThicknessMOLenright) + fracSurfaceRoughnesshLayerThickness Psi_mleft(fracSurfaceRoughnesshMOLenright) + R_z0h left psi_hleft(fracSurfaceRoughnesshMOLenright) - 1 right right \nR_z0h                           = 1 - SurfaceRoughnesshLayerThickness \nSurfaceHeatFlux                  = -FrictionVelocityTemperatureScale  labeleqSurfaceHeatFlux  \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where Psi_h is defined in Appendix A, equation A6 in Nishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin‐Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Prandtl-number","page":"EDMF equations","title":"Prandtl number","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqPrandtlNumber\nPr_neut = 074 \nPr(z) = begincases\n    Pr_neut  MOLen  0 \n    Pr_neut left frac1 + omega_2 R_g - sqrt-4 R_g + (1+omega_2 R_g)^22 R_g right  textotherwise \nendcases \nomega_2 = omega_1+1 \nomega_1 = frac4013 \nR_g = fracBuoyancyGradS^2 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Shear production (S).\nMonin-Obhukov length (MOLen).\nBuoyancy gradient (BuoyancyGrad).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Mixing-length","page":"EDMF equations","title":"Mixing length","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"note: Note\nThese mixing length have been tested for the environment, not the updrafts","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqMixingLength\nSDiol_mix^m = fracsum_j l_j e^-l_jsum_j e^-l_j qquad j = 123 \nl_1 = fracsqrtc_wSDeTKESDeN \nc_w = 04 \nSDeN = fracgrav PD_z SDeThetaVirtSDeThetaVirt  qquad text(buoyancy frequency of environment) \nl_2 = fracVKConst zc_K kappa^* phi_m(zMOLen) \nphi_m(xi) = left( 1 + a_l xi right)^-b_l \n(a_l b_l) =\nbegincases\n  (-100 02)  MOLen  0 \n  (27 -1)  textotherwise \nendcases \nkappa^* = fracFrictionVelocitysqrtSDeTKE \nl_3 = sqrtfracc_varepsilonc_K sqrtSDeTKE\nleft max(S^2 - frac1Pr(z) BuoyancyGrad 0) right^-12 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Constants.\nShear production (S).\nMonin-Obhukov length (MOLen).\nFriction velocity (FrictionVelocity).\nBuoyancy gradient (BuoyancyGrad).\nPotential temperatures (ThetaDry, ThetaVirt).\nPrandtl number (Pr).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Smoothing function is provided in python file. The Prandtl number was used from Eq. 75 in Dan Li 2019 \"Turbulent Prandtl number in the atmospheric BL - where are we now\".","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Eddy-diffusivity","page":"EDMF equations","title":"Eddy diffusivity","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqEddyDiffusivity\nSDiKm  = begincases\nc_K SDiol_mix sqrtSDiTKE  i = iEnv \n0  textotherwise\nendcases \nSDiKh  = fracSDiKmPr \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Constants.\nMixing length (l_mix).\nPrandtl number (Pr).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Buoyancy-flux","page":"EDMF equations","title":"Buoyancy flux","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"todo: Todo\nCurrently, BuoyancyFlux is hard-coded from the first expression (which was used in SCAMPy), however, this value should be computed from the SurfaceFluxes section.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqBuoyancyFlux\nSurfaceBuoyancyFlux  = fracgrav BCalphaRefCpm BCSDiT (SensibleSurfaceHeatFlux + (EpsDV - 1) Cpm BCSDiT LatentSurfaceHeatFlux  LatentHeatVBCSDiT) \nBuoyancyFlux  = - SDiKh SDiBuoyancyGrad \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Eddy diffusivity (Km Kh).\nLatent heat (LatentHeatVT).\nBuoyancy gradient (BuoyancyGrad).\nSpecific heats Cpm and Cvm.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Entrainment-Detrainment","page":"EDMF equations","title":"Entrainment-Detrainment","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Entrainment (epsilon_i)","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqEntrainment\nepsilon_i = c_epsilon fracmax(SDib 0)SDiw^2 \nc_epsilon = 012 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Detrainment (delta_j):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqDetrainment\ndelta_i = c_delta fracmin(SDib 0)SDiw^2 + delta_B Heaviside(SDiql) \nc_delta = c_delta0 + Gamma(aSDia) \nGamma(aSDia) = 0 \nc_delta0 = c_epsilon = 012 \ndelta_B = 0004 m^-1 \nHeaviside = textHeaviside function \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nTemperature (T and TDry).\nBuoyancy (Buoyancy).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Inversion-height","page":"EDMF equations","title":"Inversion height","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqInversionHeight\nSDioInversionHeight =\nbegincases\n  left (PD_z ThetaRho)^-1 (BCThetaRho - ThetaRho_z_1) + z_1 right  simparamBCDMu^2 + simparamBCDMv^2 = texttol_InversionHeightmathrm-stable \n  left (PD_z Ri_bulk)^-1 (hyperparamRi_bulk crit - Ri_bulk_z_2) + z_2 right  textotherwise \nendcases \nz_1 = min_z (ThetaRho(z)  BCThetaRho) \nz_2 = min_z (Ri_bulk(z)  hyperparamRi_bulk crit) \nRi_bulk = grav z frac(ThetaRhoBCThetaRho - 1)simparamDMu^2 + simparamDMv^2 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Potential temperatures (theta).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Convective-velocity","page":"EDMF equations","title":"Convective velocity","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqConvectiveVelocity\nSDioConvectiveVelocity = (max(BuoyancyFlux SDioInversionHeight 0))^13 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Inversion height (SDioInversionHeight).\nBuoyancy flux (BuoyancyFlux).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Non-local-mixing-length","page":"EDMF equations","title":"Non-local mixing length","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqMixingLengthOld\nSDiol_mix = (l_A^-1 + l_B^-1)^-1 \nl_A = VKConst z left( 1 + a_l fraczMOLen right)^b_l \nSDiol_B = SDiotau SDiTKE \n(a_l b_l) =\nbegincases\n  (-100 02)  MOLen  0 \n  (27 -1)  textotherwise \nendcases \nSDiotau = SDioInversionHeightSDioConvectiveVelocity \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Inversion height (SDioInversionHeight).\nMonin-Obhukov length (MOLen).\nConvective velocity (SDioConvectiveVelocity).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Boundary-Conditions","page":"EDMF equations","title":"Boundary Conditions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Here, we specify boundary conditions (BCs) by their type, Dirichlet (D) or Neumann (N), and their value.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#BC-functions","page":"EDMF equations","title":"BC functions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nGamma_phi(F_1 F_2)\n = begincases\n    4 fracF_1 F_2FrictionVelocity^2 (1 - 83zLLMOLen)^-23  MOLen  0 \n    4 fracF_1 F_2FrictionVelocity^2  textotherwise\nendcases \nGamma_TKE\n = begincases\n    375 FrictionVelocity^2 + 02 ConvectiveVelocity^2 + FrictionVelocity^2 (-zLLMOLen)^23  MOLen  0 \n    375 FrictionVelocity^2  textotherwise\nendcases \nSensibleSurfaceHeatFlux  = BCTCVweint Cpm rhoRef \nLatentSurfaceHeatFlux    = BCTCVwqt  LatentHeatVT rhoRef \nF_eint(SensibleSurfaceHeatFlux)   = fracSensibleSurfaceHeatFluxCpm       = BCTCVweint rhoRef \nF_qt(LatentSurfaceHeatFlux)       = fracLatentSurfaceHeatFluxLatentHeatVT = BCTCVwqt   rhoRef \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nMonin-Obhukov length (MOLen).\nConvective velocity (SDioConvectiveVelocity).\nFriction velocity (FrictionVelocity).\nLatent heat (LatentHeatVT).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"and equation \\eqref{eq:TopPercentile} represents the mean of the top x-fraction of a standard normal distribution (Neggers et al., 2009).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPhi^-1(x)  = textinverse cumulative distribution function labeleqInverseCDF \nmathcal D(x) = frac1sqrt2pi x exp- frac12 (Phi^-1(1-x))^2   labeleqTopPercentile \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Area-fraction","page":"EDMF equations","title":"Area fraction","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nc_frac = 01 quad\nBCBaSDia =\nbegincases\n    1-c_frac  i = iEnv \n  fracc_fracNsd  i ne iEnv\nendcases quad\nBCTaSDia =\nbegincases\n    1-c_frac  i = iEnv \n  fracc_fracNsd  i ne iEnv\nendcases\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#st-order-moments","page":"EDMF equations","title":"1st order moments","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Top boundary","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nBCTSDiw           = 0 \nPD_z BCTSDiqt   = 0 \nPD_z BCTSDieint = 0 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Bottom boundary","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"todo: Todo\nNeed value for C_eint.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nBCBSDiw     = 0 \n- SDiKh PD_z BCBSDiqt   = TCVwqt   + mathcal D(aSDia) sqrtC_qt^2   WindSpeed^2Gamma_phi(TCVwqt   TCVwqt   ) \n- SDiKh PD_z BCBSDieint = TCVweint + mathcal D(aSDia) sqrtC_eint^2 WindSpeed^2Gamma_phi(TCVweint TCVweint ) \nC_qt = 0001133 \nC_ThetaLiqIce = 0001094 \nC_eint =  \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable/function definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"BC functions mathcal D.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#nd-order-moments","page":"EDMF equations","title":"2nd order moments","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Top boundary","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nBCTSDiTKE                          = 0 \nPD_z BCTIntraCVSDiqtqt        = 0 \nPD_z BCTIntraCVSDieinteint    = 0 \nPD_z BCTIntraCVSDieintqt      = 0 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"todo: Todo\nCurrently, we only account for the intra sub-domain covariance, but we would like to also account for the inter sub-domain covariance for all but the TKE.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"Bottom boundary","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nBCBSDiTKE                    = Gamma_TKE \nBCBIntraCVSDiqtqt        = Gamma_phi(TCVwqt   TCVwqt   ) \nBCBIntraCVSDieinteint    = Gamma_phi(TCVwqt   TCVweint ) \nBCBIntraCVSDieintqt      = Gamma_phi(TCVweint TCVweint ) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"where additional variable/function definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/","page":"EDMF equations","title":"EDMF equations","text":"BC functions Gamma_TKE, Gamma_phi, F_eint, SensibleSurfaceHeatFlux, F_qt, LatentSurfaceHeatFlux.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/burgers_single_stack.jl\"","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Single-stack-tutorial-based-on-the-3D-Burgers-tracer-equations","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single stack tutorial based on the 3D Burgers + tracer equations","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"This tutorial implements the Burgers equations with a tracer field in a single element stack. The flow is initialized with a horizontally uniform profile of horizontal velocity and uniform initial temperature. The fluid is heated from the bottom surface. Gaussian noise is imposed to the horizontal velocity field at each node at the start of the simulation. The tutorial demonstrates how to","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Initialize a BalanceLaw in a single stack configuration;\nReturn the horizontal velocity field to a given profile (e.g., large-scale advection);\nRemove any horizontal inhomogeneities or noise from the flow.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"The second and third bullet points are demonstrated imposing Rayleigh friction, horizontal diffusion and 2D divergence damping to the horizontal momentum prognostic equation.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Equations solved in balance law form:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"beginalign\nfrac ρ t = -   (ρmathbfu) \nfrac ρmathbfu t = -   (-μ mathbfu) -   (ρmathbfu mathbfu) - γ (ρmathbfu-ρmathbfu) - (ρmathbfu-ρmathbfu)z z - ν_d _h (_h  ρmathbfu) \nfrac ρcT t = -   (-α ρcT) -   (mathbfu ρcT)\nendalign","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Boundary conditions:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"beginalign\nz_mathrmmin  ρ = 1 \nz_mathrmmin  ρmathbfu = mathbf0 \nz_mathrmmin  ρcT = ρc T_mathrmfixed \nz_mathrmmax  ρ = 1 \nz_mathrmmax  ρmathbfu = mathbf0 \nz_mathrmmax  -αρcT = 0\nendalign","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"where","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"t is time\nρ is the density\nmathbfu is the velocity (vector)\nmathbfu is the horizontally averaged velocity (vector)\nμ is the dynamic viscosity tensor\nγ is the Rayleigh friction frequency\nν_d is the horizontal divergence damping coefficient\nT is the temperature\nα is the thermal diffusivity tensor\nc is the heat capacity\nρcT is the thermal energy","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Solving these equations is broken down into the following steps:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Preliminary configuration\nPDEs\nSpace discretization\nTime discretization\nSolver hooks / callbacks\nSolve\nPost-processing","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Preliminary-configuration","page":"Single Element Stack Experiment (Burgers Equation)","title":"Preliminary configuration","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/#Loading-code-burgers","page":"Single Element Stack Experiment (Burgers Equation)","title":"Loading code","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"First, we'll load our pre-requisites","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"load external packages:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"using MPI\nusing Distributions\nusing OrderedCollections\nusing Plots\nusing StaticArrays\nusing LinearAlgebra: Diagonal, tr","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"load CLIMAParameters and set up to use it:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"using CLIMAParameters\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"load necessary ClimateMachine modules:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"using ClimateMachine\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.Writers\nusing ClimateMachine.DGMethods\nusing ClimateMachine.DGMethods.NumericalFluxes\nusing ClimateMachine.BalanceLaws:\n    BalanceLaw, Prognostic, Auxiliary, Gradient, GradientFlux\n\nusing ClimateMachine.Mesh.Geometry: LocalGeometry\nusing ClimateMachine.MPIStateArrays\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.VariableTemplates\nusing ClimateMachine.SingleStackUtils","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"import necessary ClimateMachine modules: (importing enables us to","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"provide implementations of these structs/methods)","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"using ClimateMachine.Orientations:\n    Orientation,\n    FlatOrientation,\n    init_aux!,\n    vertical_unit_vector,\n    projection_tangential\n\nimport ClimateMachine.BalanceLaws:\n    vars_state,\n    source!,\n    flux_second_order!,\n    flux_first_order!,\n    compute_gradient_argument!,\n    compute_gradient_flux!,\n    init_state_auxiliary!,\n    init_state_prognostic!,\n    boundary_state!","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Initialization","page":"Single Element Stack Experiment (Burgers Equation)","title":"Initialization","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Define the float type (Float64 or Float32)","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"FT = Float64;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Initialize ClimateMachine for CPU.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"ClimateMachine.init(; disable_gpu = true);\n\nconst clima_dir = dirname(dirname(pathof(ClimateMachine)));\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Load some helper functions for plotting","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"include(joinpath(clima_dir, \"docs\", \"plothelpers.jl\"));\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Define-the-set-of-Partial-Differential-Equations-(PDEs)","page":"Single Element Stack Experiment (Burgers Equation)","title":"Define the set of Partial Differential Equations (PDEs)","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/#Define-the-model","page":"Single Element Stack Experiment (Burgers Equation)","title":"Define the model","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Model parameters can be stored in the particular BalanceLaw, in this case, the BurgersEquation:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Base.@kwdef struct BurgersEquation{FT, APS, O} <: BalanceLaw\n    \"Parameters\"\n    param_set::APS\n    \"Orientation model\"\n    orientation::O\n    \"Heat capacity\"\n    c::FT = 1\n    \"Vertical dynamic viscosity\"\n    μv::FT = 1e-4\n    \"Horizontal dynamic viscosity\"\n    μh::FT = 1\n    \"Vertical thermal diffusivity\"\n    αv::FT = 1e-2\n    \"Horizontal thermal diffusivity\"\n    αh::FT = 1\n    \"IC Gaussian noise standard deviation\"\n    σ::FT = 5e-2\n    \"Rayleigh damping\"\n    γ::FT = 5\n    \"Domain height\"\n    zmax::FT = 1\n    \"Initial conditions for temperature\"\n    initialT::FT = 295.15\n    \"Bottom boundary value for temperature (Dirichlet boundary conditions)\"\n    T_bottom::FT = 300.0\n    \"Top flux (α∇ρcT) at top boundary (Neumann boundary conditions)\"\n    flux_top::FT = 0.0\n    \"Divergence damping coefficient (horizontal)\"\n    νd::FT = 1\nend","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Create an instance of the BurgersEquation:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"orientation = FlatOrientation()\n\nm = BurgersEquation{FT, typeof(param_set), typeof(orientation)}(\n    param_set = param_set,\n    orientation = orientation,\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"This model dictates the flow control, using Dynamic Multiple Dispatch, for which kernels are executed.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Define-the-variables","page":"Single Element Stack Experiment (Burgers Equation)","title":"Define the variables","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"All of the methods defined in this section were imported in Loading code to let us provide implementations for our BurgersEquation as they will be used by the solver.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify auxiliary variables for BurgersEquation","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function vars_state(m::BurgersEquation, st::Auxiliary, FT)\n    @vars begin\n        coord::SVector{3, FT}\n        orientation::vars_state(m.orientation, st, FT)\n    end\nend","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify prognostic variables, the variables solved for in the PDEs, for BurgersEquation","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"vars_state(::BurgersEquation, ::Prognostic, FT) =\n    @vars(ρ::FT, ρu::SVector{3, FT}, ρcT::FT);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify state variables whose gradients are needed for BurgersEquation","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"vars_state(::BurgersEquation, ::Gradient, FT) =\n    @vars(u::SVector{3, FT}, ρcT::FT, ρu::SVector{3, FT});\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify gradient variables for BurgersEquation","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"vars_state(::BurgersEquation, ::GradientFlux, FT) = @vars(\n    μ∇u::SMatrix{3, 3, FT, 9},\n    α∇ρcT::SVector{3, FT},\n    νd∇D::SMatrix{3, 3, FT, 9}\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Define-the-compute-kernels","page":"Single Element Stack Experiment (Burgers Equation)","title":"Define the compute kernels","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify the initial values in aux::Vars, which are available in init_state_prognostic!. Note that","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"this method is only called at t=0.\naux.coord is available here because we've specified coord in vars_state(m, aux, FT).","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function nodal_init_state_auxiliary!(\n    m::BurgersEquation,\n    aux::Vars,\n    tmp::Vars,\n    geom::LocalGeometry,\n)\n    aux.coord = geom.coord\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"init_aux! initializes the auxiliary gravitational potential field needed for vertical projections","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function init_state_auxiliary!(\n    m::BurgersEquation,\n    state_auxiliary::MPIStateArray,\n    grid,\n    direction,\n)\n    init_aux!(m, m.orientation, state_auxiliary, grid, direction)\n\n    init_state_auxiliary!(\n        m,\n        nodal_init_state_auxiliary!,\n        state_auxiliary,\n        grid,\n        direction,\n    )\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify the initial values in state::Vars. Note that","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"this method is only called at t=0.\nstate.ρ, state.ρu andstate.ρcT are available here because we've specified ρ, ρu and ρcT in vars_state(m, state, FT).","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function init_state_prognostic!(\n    m::BurgersEquation,\n    state::Vars,\n    aux::Vars,\n    localgeo,\n    t::Real,\n)\n    z = aux.coord[3]\n    ε1 = rand(Normal(0, m.σ))\n    ε2 = rand(Normal(0, m.σ))\n    state.ρ = 1\n    ρu = 1 - 4 * (z - m.zmax / 2)^2 + ε1\n    ρv = 1 - 4 * (z - m.zmax / 2)^2 + ε2\n    ρw = 0\n    state.ρu = SVector(ρu, ρv, ρw)\n\n    state.ρcT = state.ρ * m.c * m.initialT\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"The remaining methods, defined in this section, are called at every time-step in the solver by the BalanceLaw framework.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Since we have second-order fluxes, we must tell ClimateMachine to compute the gradient of ρcT, u and ρu. Here, we specify how ρcT, u and ρu are computed. Note that e.g. transform.ρcT is available here because we've specified ρcT in vars_state(m, ::Gradient, FT).","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function compute_gradient_argument!(\n    m::BurgersEquation,\n    transform::Vars,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    transform.ρcT = state.ρcT\n    transform.u = state.ρu / state.ρ\n    transform.ρu = state.ρu\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify where in diffusive::Vars to store the computed gradient from compute_gradient_argument!. Note that:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"diffusive.μ∇u is available here because we've specified μ∇u in vars_state(m, ::GradientFlux, FT).\n∇transform.u is available here because we've specified u in vars_state(m, ::Gradient, FT).\ndiffusive.μ∇u is built using an anisotropic diffusivity tensor.\nThe divergence may be computed from the trace of tensor ∇ρu.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function compute_gradient_flux!(\n    m::BurgersEquation{FT},\n    diffusive::Vars,\n    ∇transform::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n) where {FT}\n    ∇ρu = ∇transform.ρu\n    ẑ = vertical_unit_vector(m.orientation, m.param_set, aux)\n    divergence = tr(∇ρu) - ẑ' * ∇ρu * ẑ\n    diffusive.α∇ρcT = Diagonal(SVector(m.αh, m.αh, m.αv)) * ∇transform.ρcT\n    diffusive.μ∇u = Diagonal(SVector(m.μh, m.μh, m.μv)) * ∇transform.u\n    diffusive.νd∇D =\n        Diagonal(SVector(m.νd, m.νd, FT(0))) *\n        Diagonal(SVector(divergence, divergence, FT(0)))\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Introduce Rayleigh friction towards a target profile as a source. Note that:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Rayleigh damping is only applied in the horizontal using the projection_tangential method.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function source!(\n    m::BurgersEquation{FT},\n    source::Vars,\n    state::Vars,\n    diffusive::Vars,\n    aux::Vars,\n    args...,\n) where {FT}\n    ẑ = vertical_unit_vector(m.orientation, m.param_set, aux)\n    z = aux.coord[3]\n    ρ̄ū =\n        state.ρ * SVector{3, FT}(\n            0.5 - 2 * (z - m.zmax / 2)^2,\n            0.5 - 2 * (z - m.zmax / 2)^2,\n            0.0,\n        )\n    ρu_p = state.ρu - ρ̄ū\n    source.ρu -=\n        m.γ * projection_tangential(m.orientation, m.param_set, aux, ρu_p)\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Compute advective flux. Note that:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"state.ρu is available here because we've specified ρu in vars_state(m, state, FT).","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function flux_first_order!(\n    m::BurgersEquation,\n    flux::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n    _...,\n)\n    flux.ρ = state.ρu\n\n    u = state.ρu / state.ρ\n    flux.ρu = state.ρu * u'\n    flux.ρcT = u * state.ρcT\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Compute diffusive flux (e.g. F(μ mathbfu t) = -μmathbfu in the original PDE). Note that:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"diffusive.μ∇u is available here because we've specified μ∇u in vars_state(m, ::GradientFlux, FT).\nThe divergence gradient can be written as a diffusive flux using a divergence diagonal tensor.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function flux_second_order!(\n    m::BurgersEquation,\n    flux::Grad,\n    state::Vars,\n    diffusive::Vars,\n    hyperdiffusive::Vars,\n    aux::Vars,\n    t::Real,\n)\n    flux.ρcT -= diffusive.α∇ρcT\n    flux.ρu -= diffusive.μ∇u\n    flux.ρu -= diffusive.νd∇D\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Boundary-conditions","page":"Single Element Stack Experiment (Burgers Equation)","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Second-order terms in our equations, (G) where G = μmathbfu, are internally reformulated to first-order unknowns. Boundary conditions must be specified for all unknowns, both first-order and second-order unknowns which have been reformulated.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"The boundary conditions for ρ, ρu and ρcT (first order unknowns)","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function boundary_state!(\n    nf,\n    m::BurgersEquation,\n    state⁺::Vars,\n    aux⁺::Vars,\n    n⁻,\n    state⁻::Vars,\n    aux⁻::Vars,\n    bctype,\n    t,\n    _...,\n)\n    if bctype == 1 # bottom\n        state⁺.ρ = 1\n        state⁺.ρu = SVector(0, 0, 0)\n        state⁺.ρcT = state⁺.ρ * m.c * m.T_bottom\n    elseif bctype == 2 # top\n        state⁺.ρ = 1\n        state⁺.ρu = SVector(0, 0, 0)\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"The boundary conditions for ρ, ρu and ρcT are specified here for second-order unknowns","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"function boundary_state!(\n    nf,\n    m::BurgersEquation,\n    state⁺::Vars,\n    diff⁺::Vars,\n    aux⁺::Vars,\n    n⁻,\n    state⁻::Vars,\n    diff⁻::Vars,\n    aux⁻::Vars,\n    bctype,\n    t,\n    _...,\n)\n    if bctype == 1 # bottom\n        state⁺.ρ = 1\n        state⁺.ρu = SVector(0, 0, 0)\n        state⁺.ρcT = state⁺.ρ * m.c * m.T_bottom\n    elseif bctype == 2 # top\n        state⁺.ρ = 1\n        state⁺.ρu = SVector(0, 0, 0)\n        diff⁺.α∇ρcT = -n⁻ * m.flux_top\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Spatial-discretization","page":"Single Element Stack Experiment (Burgers Equation)","title":"Spatial discretization","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Prescribe polynomial order of basis functions in finite elements","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"N_poly = 5;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify the number of vertical elements","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"nelem_vert = 10;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify the domain height","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"zmax = m.zmax;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Establish a ClimateMachine single stack configuration","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"driver_config = ClimateMachine.SingleStackConfiguration(\n    \"BurgersEquation\",\n    N_poly,\n    nelem_vert,\n    zmax,\n    param_set,\n    m,\n    numerical_flux_first_order = CentralNumericalFluxFirstOrder(),\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Time-discretization","page":"Single Element Stack Experiment (Burgers Equation)","title":"Time discretization","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Specify simulation time (SI units)","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"t0 = FT(0);\ntimeend = FT(1);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"We'll define the time-step based on the Fourier number and the Courant number of the flow","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Δ = min_node_distance(driver_config.grid)\n\ngiven_Fourier = FT(0.5);\nFourier_bound = given_Fourier * Δ^2 / max(m.αh, m.μh, m.νd);\nCourant_bound = FT(0.5) * Δ;\ndt = min(Fourier_bound, Courant_bound)","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Configure-a-ClimateMachine-solver.","page":"Single Element Stack Experiment (Burgers Equation)","title":"Configure a ClimateMachine solver.","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"This initializes the state vector and allocates memory for the solution in space (dg has the model m, which describes the PDEs as well as the function used for initialization). This additionally initializes the ODE solver, by default an explicit Low-Storage Runge-Kutta method.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"solver_config =\n    ClimateMachine.SolverConfiguration(t0, timeend, driver_config, ode_dt = dt);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Inspect-the-initial-conditions-for-a-single-nodal-stack","page":"Single Element Stack Experiment (Burgers Equation)","title":"Inspect the initial conditions for a single nodal stack","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Let's export plots of the initial state","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"output_dir = @__DIR__;\n\nmkpath(output_dir);\n\nz_scale = 100 # convert from meters to cm\nz_key = \"z\"\nz_label = \"z [cm]\"\nz = get_z(driver_config.grid; z_scale = z_scale)\nstate_vars = get_vars_from_nodal_stack(\n    driver_config.grid,\n    solver_config.Q,\n    vars_state(m, Prognostic(), FT),\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Create an array to store the solution:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"state_data = Dict[state_vars]  # store initial condition at ``t=0``\ntime_data = FT[0]                                      # store time data","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Generate plots of initial conditions for the southwest nodal stack","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"export_plot(\n    z,\n    time_data,\n    state_data,\n    (\"ρcT\",),\n    joinpath(output_dir, \"initial_condition_T_nodal.png\");\n    xlabel = \"ρcT at southwest node\",\n    ylabel = z_label,\n);\nexport_plot(\n    z,\n    time_data,\n    state_data,\n    (\"ρu[1]\",),\n    joinpath(output_dir, \"initial_condition_u_nodal.png\");\n    xlabel = \"ρu at southwest node\",\n    ylabel = z_label,\n);\nexport_plot(\n    z,\n    time_data,\n    state_data,\n    (\"ρu[2]\",),\n    joinpath(output_dir, \"initial_condition_v_nodal.png\");\n    xlabel = \"ρv at southwest node\",\n    ylabel = z_label,\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Inspect-the-initial-conditions-for-the-horizontal-averages","page":"Single Element Stack Experiment (Burgers Equation)","title":"Inspect the initial conditions for the horizontal averages","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Horizontal statistics of variables","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"state_vars_var = get_horizontal_variance(\n    driver_config.grid,\n    solver_config.Q,\n    vars_state(m, Prognostic(), FT),\n);\n\nstate_vars_avg = get_horizontal_mean(\n    driver_config.grid,\n    solver_config.Q,\n    vars_state(m, Prognostic(), FT),\n);\n\ndata_avg = Dict[state_vars_avg]\ndata_var = Dict[state_vars_var]\n\nexport_plot(\n    z,\n    time_data,\n    data_avg,\n    (\"ρu[1]\",),\n    joinpath(output_dir, \"initial_condition_avg_u.png\");\n    xlabel = \"Horizontal mean of ρu\",\n    ylabel = z_label,\n);\nexport_plot(\n    z,\n    time_data,\n    data_var,\n    (\"ρu[1]\",),\n    joinpath(output_dir, \"initial_condition_variance_u.png\");\n    xlabel = \"Horizontal variance of ρu\",\n    ylabel = z_label,\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Solver-hooks-/-callbacks","page":"Single Element Stack Experiment (Burgers Equation)","title":"Solver hooks / callbacks","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Define the number of outputs from t0 to timeend","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"const n_outputs = 5;\nconst every_x_simulation_time = timeend / n_outputs;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Create a dictionary for z coordinate (and convert to cm) NCDatasets IO:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"dims = OrderedDict(z_key => collect(z));\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Create dictionaries to store outputs:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"data_var = Dict[Dict([k => Dict() for k in 0:n_outputs]...),]\ndata_var[1] = state_vars_var\n\ndata_avg = Dict[Dict([k => Dict() for k in 0:n_outputs]...),]\ndata_avg[1] = state_vars_avg\n\ndata_nodal = Dict[Dict([k => Dict() for k in 0:n_outputs]...),]\ndata_nodal[1] = state_vars","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"The ClimateMachine's time-steppers provide hooks, or callbacks, which allow users to inject code to be executed at specified intervals. In this callback, the state variables are collected, combined into a single OrderedDict and written to a NetCDF file (for each output step).","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"callback = GenericCallbacks.EveryXSimulationTime(every_x_simulation_time) do\n    state_vars_var = get_horizontal_variance(\n        driver_config.grid,\n        solver_config.Q,\n        vars_state(m, Prognostic(), FT),\n    )\n    state_vars_avg = get_horizontal_mean(\n        driver_config.grid,\n        solver_config.Q,\n        vars_state(m, Prognostic(), FT),\n    )\n    state_vars = get_vars_from_nodal_stack(\n        driver_config.grid,\n        solver_config.Q,\n        vars_state(m, Prognostic(), FT),\n        i = 1,\n        j = 1,\n    )\n    push!(data_var, state_vars_var)\n    push!(data_avg, state_vars_avg)\n    push!(data_nodal, state_vars)\n    push!(time_data, gettime(solver_config.solver))\n    nothing\nend;\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Solve","page":"Single Element Stack Experiment (Burgers Equation)","title":"Solve","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"This is the main ClimateMachine solver invocation. While users do not have access to the time-stepping loop, code may be injected via user_callbacks, which is a Tuple of GenericCallbacks.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"ClimateMachine.invoke!(solver_config; user_callbacks = (callback,))","category":"page"},{"location":"generated/Atmos/burgers_single_stack/#Post-processing","page":"Single Element Stack Experiment (Burgers Equation)","title":"Post-processing","text":"","category":"section"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Our solution has now been calculated and exported to NetCDF files in output_dir.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Let's plot the horizontal statistics of ρu and ρcT, as well as the evolution of ρu for the southwest nodal stack:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"export_plot(\n    z,\n    time_data,\n    data_avg,\n    (\"ρu[1]\"),\n    joinpath(output_dir, \"solution_vs_time_u_avg.png\");\n    xlabel = \"Horizontal mean of ρu\",\n    ylabel = z_label,\n);\nexport_plot(\n    z,\n    time_data,\n    data_var,\n    (\"ρu[1]\"),\n    joinpath(output_dir, \"variance_vs_time_u.png\");\n    xlabel = \"Horizontal variance of ρu\",\n    ylabel = z_label,\n);\nexport_plot(\n    z,\n    time_data,\n    data_avg,\n    (\"ρcT\"),\n    joinpath(output_dir, \"solution_vs_time_T_avg.png\");\n    xlabel = \"Horizontal mean of ρcT\",\n    ylabel = z_label,\n);\nexport_plot(\n    z,\n    time_data,\n    data_var,\n    (\"ρcT\"),\n    joinpath(output_dir, \"variance_vs_time_T.png\");\n    xlabel = \"Horizontal variance of ρcT\",\n    ylabel = z_label,\n);\nexport_plot(\n    z,\n    time_data,\n    data_nodal,\n    (\"ρu[1]\"),\n    joinpath(output_dir, \"solution_vs_time_u_nodal.png\");\n    xlabel = \"ρu at southwest node\",\n    ylabel = z_label,\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"Rayleigh friction returns the horizontal velocity to the objective profile on the timescale of the simulation (1 second), since γ∼1. The horizontal viscosity and 2D divergence damping act to reduce the horizontal variance over the same timescale. The initial Gaussian noise is propagated to the temperature field through advection. The horizontal diffusivity acts to reduce this ρcT variance in time, although in a longer timescale.","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"To run this file, and inspect the solution, include this tutorial in the Julia REPL with:","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"include(joinpath(\"tutorials\", \"Atmos\", \"burgers_single_stack.jl\"))","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"","category":"page"},{"location":"generated/Atmos/burgers_single_stack/","page":"Single Element Stack Experiment (Burgers Equation)","title":"Single Element Stack Experiment (Burgers Equation)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/TutorialList.jl\"","category":"page"},{"location":"generated/TutorialList/#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"A suite of concrete examples are provided here as a guidance for constructing experiments.","category":"page"},{"location":"generated/TutorialList/#Balance-Law","page":"Home","title":"Balance Law","text":"","category":"section"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"An introduction on components within a balance law is provided.","category":"page"},{"location":"generated/TutorialList/#Atmos","page":"Home","title":"Atmos","text":"","category":"section"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"Showcase drivers for atmospheric modelling in GCM, single stack, and LES simulations are provided.","category":"page"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"Dry Idealzed GCM:  The Held-Suarez configuration is used as a guidance to create a driver that runs a simple GCM simulation.\nSingle Element Stack:  The Burgers Equations with a passive tracer is used as a guidance to run the simulation on a single element stack.\nLES Experiment:  The dry rising bubble case is used as a quigance in creating an LES driver.\nTopography:  Experiments of dry flow over prescirbe topography (Agnesi mountain) are provided for:\nLinear Hydrostatic Mountain\nLinear Non-Hydrostatic Mountain","category":"page"},{"location":"generated/TutorialList/#Ocean","page":"Home","title":"Ocean","text":"","category":"section"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"A showcase for Ocean model is still under construction.","category":"page"},{"location":"generated/TutorialList/#Land","page":"Home","title":"Land","text":"","category":"section"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"Examples are provided in constructing balance law and solving for fundemental equations in land modelling.","category":"page"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"Heat:  A tutorial shows how to create a HeatModel to solve the heat equation and visualize the outputs.\nSoil:  Examples of solving fundemental equations in the soil model are provided.\nHydraulic Functions:  a tutorial to specify the hydraulic function in the Richard's equation.\nSoil Heat Equations:  a tutorial for solving the heat equation in the soil.\nCoupled Water and Heat:  a tutorial for solving interactive heat and wateri in the soil model.","category":"page"},{"location":"generated/TutorialList/#Numerics-(need-to-be-moved-to-How-to-Guide)","page":"Home","title":"Numerics (need to be moved to How-to-Guide)","text":"","category":"section"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"System Solvers:  Two numerical methods to solve the linear system Ax=b are provided.\nConjugate Gradient\nBatched Generalized Minimal Residual\nDG Methods\nFilters","category":"page"},{"location":"generated/TutorialList/#Diagnostics","page":"Home","title":"Diagnostics","text":"","category":"section"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"A diagnostic tool that can","category":"page"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"generate statistics for MPIStateArrays\nvalidate with reference values","category":"page"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"for debugging purposes.","category":"page"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"","category":"page"},{"location":"generated/TutorialList/","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Contributing/#Contributing","page":"Contribution guide","title":"Contributing","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Thank you for considering contributing to the ClimateMachine! We encourage Pull Requests (PRs). Please do not hesitate to ask as questions if you're unsure about how to help.","category":"page"},{"location":"Contributing/#What-to-contribute?","page":"Contribution guide","title":"What to contribute?","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"The easiest way to contribute is by running the ClimateMachine, identifying problems and opening issues.\nYou can tackle an existing issue. We have a list of good first issues.\nWrite an example or tutorial.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use the ClimateMachine.","category":"page"},{"location":"Contributing/#Using-git","page":"Contribution guide","title":"Using git","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"If you are unfamiliar with git and version control, the following guides will be helpful:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Atlassian (bitbucket) git tutorials. A set of tips and tricks for getting started with git.\nGitHub's git tutorials. A set of resources from GitHub to learn git.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"We provide a brief guide here.","category":"page"},{"location":"Contributing/#Identity","page":"Contribution guide","title":"Identity","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"First make sure git knows your name and email address:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"$ git config --global user.name \"A. Climate Developer\"\n$ git config --global user.email \"a.climate.developer@eg.com\"","category":"page"},{"location":"Contributing/#Forks-and-branches","page":"Contribution guide","title":"Forks and branches","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Create your own fork of the ClimateMachine on GitHub and check out your copy:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"$ git clone https://github.com/<username>/ClimateMachine.jl.git\n$ cd ClimateMachine.jl\n$ git remote add upstream https://github.com/CliMA/ClimateMachine.jl","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Now you have two remote repositories – origin, which is your fork of the ClimateMachine, and upstream, which is the main ClimateMachine.jl repository.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Create a branch for your feature; this will hold your contribution:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"$ git checkout -b <branchname>","category":"page"},{"location":"Contributing/#Develop-your-feature","page":"Contribution guide","title":"Develop your feature","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Follow the Coding conventions we use. Make sure you add tests for your code in test/ and appropriate documentation in the code and/or in docs/.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"When your PR is ready for review, clean up your commit history by squashing and make sure your code is current with ClimateMachine master by rebasing.","category":"page"},{"location":"Contributing/#Squash-and-rebase","page":"Contribution guide","title":"Squash and rebase","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Use git rebase (not git merge) to sync your work:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"$ git fetch upstream\n$ git rebase upstream/master","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"You might find it easier to squash your commits first.","category":"page"},{"location":"Contributing/#Continuous-integration","page":"Contribution guide","title":"Continuous integration","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"It's time to click the button to open your PR! Fill out the template and provide a clear summary of what your PR does. When a PR is created or updated, a set of automated tests are run on the PR in our continuous integration (CI) system.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"A ClimateMachine developer will look at your PR and provide feedback!","category":"page"},{"location":"Contributing/#Unit-testing","page":"Contribution guide","title":"Unit testing","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Currently a number of checks are run per commit for a given PR.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.\nUnit Tests run subsets of the unit tests defined in tests/, using Pkg.test().  The tests are run in parallel to ensure that they finish in a reasonable time.  The tests only run the latest commit for a PR, branch and will kill any stale jobs on push.  These tests are only run on linux (Ubuntu LTS).","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Unit tests are run against every new commit for a given PR, the status of the unit-tests are not checked during the merge process but act as a sanity check for developers and reviewers. Depending on the content changed in the PR, some CI checks that are not necessary will be skipped.  For example doc only changes do not require the unit tests to be run.","category":"page"},{"location":"Contributing/#The-merge-process","page":"Contribution guide","title":"The merge process","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"We use bors to manage merging PR's in the the ClimateMachine repo. If you're a collaborator and have the necessary permissions, you can type bors try in a comment on a PR to have integration test suite run on that PR, or bors r+ to try and merge the code.  Bors ensures that all integration tests for a given PR always pass before merging into master.","category":"page"},{"location":"Contributing/#Integration-testing","page":"Contribution guide","title":"Integration testing","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Currently a number of checks are run during integration testing before being merged into master.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation checks that the documentation correctly builds for the merged PR.\nOS Unit Tests checks that ClimateMachine.jl package unit tests can pass  on every OS supported with a pre-compiled system image (Linux, macOS, Windows).\nClimateMachine-CI computationally expensive integration testing on CPU and GPU hardware using HPC cluster resources.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Integration tests are run when triggered by a reviewer through bors. Integration tests are more computationally heavyweight than unit-tests and can exercise tests using accelerator hardware (GPUs).","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Currently HPC cluster integration tests are run using the Buildkite CI service. Tests are parallelized and run as individual Slurm batch jobs on the HPC cluster and defined in .buildkite/pipeline.yml.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"An example integration test definition is outlined below:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"  - label: \"gpu_soil_test_bc\"\n    key: \"gpu_soil_test_bc\"\n    command:\n      - \"mpiexec julia --color=yes --project test/Land/Model/test_bc.jl \"\n    agents:\n      config: gpu\n      queue: central\n      slurm_ntasks: 1\n      slurm_gres: \"gpu:1\"","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"label / key: unique test defintion strings\ncommand(s): list of one or more bash commands to run.\nagent block:\nconfig: Defines cpu or gpu test environments.\nqueue: HPC queue to submit the job (default central).\nslurm_: All slurm_ definitions are passed through as  slurm batch job cli options.  Ex. for the above the slurm_ntasks: 1 is eqv. to --ntasks=1.  Flags are defined with an empty value.","category":"page"},{"location":"Contributing/#Contributing-Documentation","page":"Contribution guide","title":"Contributing Documentation","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Documentation is written in Julia-flavored markdown and generated from two sources:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"$CLIMATEMACHINE_HOME/docs/src","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"And Literate.jl tutorials:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"$CLIMATEMACHINE_HOME/tutorials","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"To locally build the documentation you need to create a new docs project to build and install the documentation related dependencies:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"cd $CLIMATEMACHINE_HOME\njulia --project=docs/ -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs docs/make.jl","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"The makefile script will generate the appropriate markdown files and static html from both the docs/src and tutorials/ directories, saving the output in docs/src/generated.","category":"page"},{"location":"Contributing/#How-to-generate-a-literate-tutorial-file","page":"Contribution guide","title":"How to generate a literate tutorial file","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"To create a tutorial using ClimateMachine, please use Literate.jl, and consult the Literate documentation for questions. For now, all literate tutorials are held in the tutorials directory.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"With Literate, all comments turn into markdown text and any Julia code is read and run as if it is in the Julia REPL. As a small caveat to this, you might need to suppress the output of certain commands. For example, if you define and run the following function","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"function f()\n    return x = [i * i for i in 1:10]\nend\n\nx = f()","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"The entire list will be output, while","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"f();","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"does not (because of the ;).","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"To show plots, you may do something like the following:","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"using Plots\nplot(x)","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Please consider writing the comments in your tutorial as if they are meant to be read as an article explaining the topic the tutorial is meant to explain. If there are any specific nuances to writing Literate documentation for ClimateMachine, please let us know!","category":"page"},{"location":"Contributing/#Speeding-up-the-documentation-build-process","page":"Contribution guide","title":"Speeding up the documentation build process","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Building the tutorials can take a long time so there is an environment variable switch to toggle on / off building the tutorials (true deafult):","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"CLIMATEMACHINE_DOCS_GENERATE_TUTORIALS=false julia --project=docs/ docs/make.jl","category":"page"},{"location":"APIs/Utilities/SingleStackUtils/#Single-Stack-Utils","page":"Single Stack Utilities","title":"Single Stack Utils","text":"","category":"section"},{"location":"APIs/Utilities/SingleStackUtils/","page":"Single Stack Utilities","title":"Single Stack Utilities","text":"CurrentModule = ClimateMachine.SingleStackUtils","category":"page"},{"location":"APIs/Utilities/SingleStackUtils/#Functions","page":"Single Stack Utilities","title":"Functions","text":"","category":"section"},{"location":"APIs/Utilities/SingleStackUtils/","page":"Single Stack Utilities","title":"Single Stack Utilities","text":"get_vars_from_nodal_stack\nget_vars_from_element_stack\nget_horizontal_mean\nget_horizontal_variance\nreduce_nodal_stack\nreduce_element_stack\nhorizontally_average!\ndict_of_nodal_states","category":"page"},{"location":"APIs/Utilities/SingleStackUtils/#ClimateMachine.SingleStackUtils.get_vars_from_nodal_stack","page":"Single Stack Utilities","title":"ClimateMachine.SingleStackUtils.get_vars_from_nodal_stack","text":"get_vars_from_nodal_stack(\n    grid::DiscontinuousSpectralElementGrid{T, dim, N},\n    Q::MPIStateArray,\n    vars;\n    vrange::UnitRange = 1:size(Q, 3),\n    i::Int = 1,\n    j::Int = 1,\n    exclude::Vector{String} = String[],\n    interp = false,\n) where {T, dim, N}\n\nReturn a dictionary whose keys are the flattenednames() of the variables specified in vars (as returned by e.g. vars_state), and whose values are arrays of the values for that variable along the vertical dimension in Q. Only a single element is expected in the horizontal as this is intended for the single stack configuration and i and j identify the horizontal nodal coordinates.\n\nVariables listed in exclude are skipped.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/SingleStackUtils/#ClimateMachine.SingleStackUtils.get_vars_from_element_stack","page":"Single Stack Utilities","title":"ClimateMachine.SingleStackUtils.get_vars_from_element_stack","text":"get_vars_from_element_stack(\n    grid::DiscontinuousSpectralElementGrid{T, dim, N},\n    Q::MPIStateArray,\n    vars;\n    vrange::UnitRange = 1:size(Q, 3),\n    exclude::Vector{String} = String[],\n    interp = false,\n) where {T, dim, N}\n\nReturn an array of get_vars_from_nodal_stack()s whose dimensions are the number of nodal points per element in the horizontal plane.\n\nVariables listed in exclude are skipped.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/SingleStackUtils/#ClimateMachine.SingleStackUtils.get_horizontal_mean","page":"Single Stack Utilities","title":"ClimateMachine.SingleStackUtils.get_horizontal_mean","text":"get_horizontal_mean(\n    grid::DiscontinuousSpectralElementGrid{T, dim, N},\n    Q::MPIStateArray,\n    vars;\n    vrange::UnitRange = 1:size(Q, 3),\n    exclude::Vector{String} = String[],\n    interp = false,\n) where {T, dim, N}\n\nReturn a dictionary whose keys are the flattenednames() of the variables specified in vars (as returned by e.g. vars_state), and whose values are arrays of the horizontal averages for that variable along the vertical dimension in Q. Only a single element is expected in the horizontal as this is intended for the single stack configuration.\n\nVariables listed in exclude are skipped.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/SingleStackUtils/#ClimateMachine.SingleStackUtils.get_horizontal_variance","page":"Single Stack Utilities","title":"ClimateMachine.SingleStackUtils.get_horizontal_variance","text":"get_horizontal_variance(\n    grid::DiscontinuousSpectralElementGrid{T, dim, N},\n    Q::MPIStateArray,\n    vars;\n    vrange::UnitRange = 1:size(Q, 3),\n    exclude::Vector{String} = String[],\n    interp = false,\n) where {T, dim, N}\n\nReturn a dictionary whose keys are the flattenednames() of the variables specified in vars (as returned by e.g. vars_state), and whose values are arrays of the horizontal variance for that variable along the vertical dimension in Q. Only a single element is expected in the horizontal as this is intended for the single stack configuration.\n\nVariables listed in exclude are skipped.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/SingleStackUtils/#ClimateMachine.SingleStackUtils.reduce_nodal_stack","page":"Single Stack Utilities","title":"ClimateMachine.SingleStackUtils.reduce_nodal_stack","text":"reduce_nodal_stack(\n    op::Function,\n    grid::DiscontinuousSpectralElementGrid{T, dim, N},\n    Q::MPIStateArray,\n    vars::NamedTuple,\n    var::String;\n    vrange::UnitRange = 1:size(Q, 3),\n) where {T, dim, N}\n\nReduce var from vars within Q over all nodal points in the specified vrange of elements with op. Return a tuple (result, z) where result is the final value returned by op and z is the index within vrange where the result was determined.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/SingleStackUtils/#ClimateMachine.SingleStackUtils.reduce_element_stack","page":"Single Stack Utilities","title":"ClimateMachine.SingleStackUtils.reduce_element_stack","text":"reduce_element_stack(\n    op::Function,\n    grid::DiscontinuousSpectralElementGrid{T, dim, N},\n    Q::MPIStateArray,\n    vars::NamedTuple,\n    var::String;\n    vrange::UnitRange = 1:size(Q, 3),\n) where {T, dim, N}\n\nReduce var from vars within Q over all nodal points in the specified vrange of elements with op. Return a tuple (result, z) where result is the final value returned by op and z is the index within vrange where the result was determined.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/SingleStackUtils/#ClimateMachine.SingleStackUtils.horizontally_average!","page":"Single Stack Utilities","title":"ClimateMachine.SingleStackUtils.horizontally_average!","text":"horizontally_average!(\n    grid::DiscontinuousSpectralElementGrid{T, dim, N},\n    Q::MPIStateArray,\n    i_vars,\n) where {T, dim, N}\n\nHorizontally average variables, from variable indexes i_vars, in MPIStateArray Q.\n\nnote: Note\nThese are not proper horizontal averages– the main purpose of this method is to ensure that there are no horizontal fluxes for a single stack configuration.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Utilities/SingleStackUtils/#ClimateMachine.SingleStackUtils.dict_of_nodal_states","page":"Single Stack Utilities","title":"ClimateMachine.SingleStackUtils.dict_of_nodal_states","text":"dict_of_nodal_states(\n    solver_config,\n    state_types = (Prognostic(), Auxiliary());\n    aux_excludes = [],\n    interp = false,\n    )\n\nA dictionary of single stack prognostic and auxiliary variables at the i=1,j=1 node given\n\nsolver_config a SolverConfiguration\naux_excludes a vector of strings containing the  variables to exclude from the auxiliary state.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Ocean/Ocean/#Ocean-Base-Module","page":"Ocean","title":"Ocean Base Module","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"CurrentModule = ClimateMachine.Ocean","category":"page"},{"location":"APIs/Ocean/Ocean/#Hydrostatic-Boussinesq","page":"Ocean","title":"Hydrostatic Boussinesq","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"CurrentModule = ClimateMachine.Ocean.HydrostaticBoussinesq","category":"page"},{"location":"APIs/Ocean/Ocean/#Models","page":"Ocean","title":"Models","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"HydrostaticBoussinesqModel\nLinearHBModel","category":"page"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.HydrostaticBoussinesq.HydrostaticBoussinesqModel","page":"Ocean","title":"ClimateMachine.Ocean.HydrostaticBoussinesq.HydrostaticBoussinesqModel","text":"HydrostaticBoussinesqModel <: BalanceLaw\n\nA BalanceLaw for ocean modeling.\n\nwrite out the equations here\n\nρₒ = reference density of sea water cʰ = maximum horizontal wave speed cᶻ = maximum vertical wave speed αᵀ = thermal expansitivity coefficient νʰ = horizontal viscosity νᶻ = vertical viscosity κʰ = horizontal diffusivity κᶻ = vertical diffusivity fₒ = first coriolis parameter (constant term) β  = second coriolis parameter (linear term)\n\nUsage\n\nHydrostaticBoussinesqModel(problem)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.HydrostaticBoussinesq.LinearHBModel","page":"Ocean","title":"ClimateMachine.Ocean.HydrostaticBoussinesq.LinearHBModel","text":"LinearHBModel <: BalanceLaw\n\nA BalanceLaw for modeling vertical diffusion implicitly.\n\nwrite out the equations here\n\nUsage\n\nmodel = HydrostaticBoussinesqModel(problem)\nlinear = LinearHBModel(model)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#BCs","page":"Ocean","title":"BCs","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"OceanBC\nPenetrable\nImpenetrable\nNoSlip\nFreeSlip\nKinematicStress\nInsulating\nTemperatureFlux","category":"page"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.OceanBC","page":"Ocean","title":"ClimateMachine.Ocean.OceanBC","text":"OceanBC(velocity    = Impenetrable(NoSlip())\n        temperature = Insulating())\n\nThe standard boundary condition for OceanModel. The default options imply a \"no flux\" boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.Penetrable","page":"Ocean","title":"ClimateMachine.Ocean.Penetrable","text":"Penetrable(drag::VelocityDragBC) :: VelocityBC\n\nDefines an penetrable wall model for velocity. This implies:\n\nno constraint on flow in the direction normal to the boundary, and\nflow parallel to the boundary is subject to the drag condition.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.Impenetrable","page":"Ocean","title":"ClimateMachine.Ocean.Impenetrable","text":"Impenetrable(drag::VelocityDragBC) :: VelocityBC\n\nDefines an impenetrable wall model for velocity. This implies:\n\nno flow in the direction normal to the boundary, and\nflow parallel to the boundary is subject to the drag condition.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.NoSlip","page":"Ocean","title":"ClimateMachine.Ocean.NoSlip","text":"NoSlip() :: VelocityDragBC\n\nZero velocity at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.FreeSlip","page":"Ocean","title":"ClimateMachine.Ocean.FreeSlip","text":"FreeSlip() :: VelocityDragBC\n\nNo surface drag on velocity parallel to the boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.KinematicStress","page":"Ocean","title":"ClimateMachine.Ocean.KinematicStress","text":"KinematicStress(stress) :: VelocityDragBC\n\nApplies the specified kinematic stress on velocity normal to the boundary. Prescribe the net inward kinematic stress across the boundary by stress, a function with signature stress(problem, state, aux, t), returning the flux (in m²/s²).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.Insulating","page":"Ocean","title":"ClimateMachine.Ocean.Insulating","text":"Insulating() :: TemperatureBC\n\nNo temperature flux across the boundary\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.TemperatureFlux","page":"Ocean","title":"ClimateMachine.Ocean.TemperatureFlux","text":"TemperatureFlux(flux) :: TemperatureBC\n\nPrescribe the net inward temperature flux across the boundary by flux, a function with signature flux(problem, state, aux, t), returning the flux (in m⋅K/s).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ShallowWater","page":"Ocean","title":"ShallowWater","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"CurrentModule = ClimateMachine.Ocean.ShallowWater","category":"page"},{"location":"APIs/Ocean/Ocean/#Models-2","page":"Ocean","title":"Models","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"ShallowWaterModel","category":"page"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.ShallowWater.ShallowWaterModel","page":"Ocean","title":"ClimateMachine.Ocean.ShallowWater.ShallowWaterModel","text":"ShallowWaterModel <: BalanceLaw\n\nA BalanceLaw for shallow water modeling.\n\nwrite out the equations here\n\nUsage\n\nShallowWaterModel(problem)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#OceanProblems","page":"Ocean","title":"OceanProblems","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"CurrentModule = ClimateMachine.Ocean.OceanProblems","category":"page"},{"location":"APIs/Ocean/Ocean/#Problems","page":"Ocean","title":"Problems","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"SimpleBox\nHomogeneousBox\nOceanGyre","category":"page"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.OceanProblems.SimpleBox","page":"Ocean","title":"ClimateMachine.Ocean.OceanProblems.SimpleBox","text":"SimpleBoxProblem <: AbstractSimpleBoxProblem\n\nStub structure with the dimensions of the box. Lˣ = zonal (east-west) length Lʸ = meridional (north-south) length H  = height of the ocean\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.OceanProblems.HomogeneousBox","page":"Ocean","title":"ClimateMachine.Ocean.OceanProblems.HomogeneousBox","text":"HomogeneousBox <: AbstractSimpleBoxProblem\n\nContainer structure for a simple box problem with wind-stress. Lˣ = zonal (east-west) length Lʸ = meridional (north-south) length H  = height of the ocean τₒ = maximum value of wind-stress (amplitude)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.OceanProblems.OceanGyre","page":"Ocean","title":"ClimateMachine.Ocean.OceanProblems.OceanGyre","text":"OceanGyre <: AbstractSimpleBoxProblem\n\nContainer structure for a simple box problem with wind-stress, coriolis force, and temperature forcing. Lˣ = zonal (east-west) length Lʸ = meridional (north-south) length H  = height of the ocean τₒ = maximum value of wind-stress (amplitude) λʳ = temperature relaxation penetration constant (meters / second) θᴱ = maximum surface temperature\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#Other-(development)","page":"Ocean","title":"Other (development)","text":"","category":"section"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"CurrentModule = ClimateMachine.Ocean.SplitExplicit01","category":"page"},{"location":"APIs/Ocean/Ocean/","page":"Ocean","title":"Ocean","text":"SplitExplicitLSRK2nSolver\nOceanDGModel","category":"page"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.SplitExplicit01.SplitExplicitLSRK2nSolver","page":"Ocean","title":"ClimateMachine.Ocean.SplitExplicit01.SplitExplicitLSRK2nSolver","text":"SplitExplicitLSRK2nSolver(slow_solver, fast_solver; dt, t0 = 0, coupled = true)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ_fast = f_fast(Q_fast Q_slow t)\n  dotQ_slow = f_slow(Q_slow Q_fast t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis method performs an operator splitting to timestep the Sea-Surface elevation and vertically averaged horizontal velocity of the model at a faster rate than the full model, using LowStorageRungeKutta2N time-stepping.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Ocean/Ocean/#ClimateMachine.Ocean.SplitExplicit01.OceanDGModel","page":"Ocean","title":"ClimateMachine.Ocean.SplitExplicit01.OceanDGModel","text":"OceanDGModel()\n\nhelper function to add required filtering not used in the Driver+Config setup\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#System-Solvers","page":"SystemSolvers","title":"System Solvers","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"CurrentModule = ClimateMachine.SystemSolvers","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#Non-linear-solvers","page":"SystemSolvers","title":"Non-linear solvers","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"LSOnly\nJacobianAction\nJacobianFreeNewtonKrylovSolver","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.LSOnly","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.LSOnly","text":"LSOnly\n\nOnly applies the linear solver (no Newton solver)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.JacobianAction","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.JacobianAction","text":"mutable struct JacobianAction{FT, AT}     rhs!     ϵ::FT     Q::AT     Qdq::AT     Fq::AT     Fqdq::AT end\n\nSolve for Frhs = F(q), the Jacobian action is computed\n\n∂F(Q)      F(Q + eΔQ) - F(Q)\n---- ΔQ ≈ -------------------\n ∂Q                e\n\n...\n\nArguments\n\nrhs!           : nonlinear operator F(Q)\nϵ::FT          : ϵ used for finite difference, e = e(Q, ϵ)\nQ::AT          : cache for Q\nQdq::AT        : container for Q + ϵΔQ\nFq::AT         : cache for F(Q)\nFqdq::AT       : container for F(Q + ϵΔQ)\n\n...\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.JacobianFreeNewtonKrylovSolver","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.JacobianFreeNewtonKrylovSolver","text":"Solve for Frhs = F(Q), by finite difference\n\n∂F(Q)      F(Q + eΔQ) - F(Q)\n---- ΔQ ≈ -------------------\n ∂Q                e\n\n Q^n+1 = Q^n - dF/dQ(Q^{n})⁻¹ (F(Q^n) - Frhs)\n\n set ΔQ = F(Q^n) - Frhs\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#Linear-solvers","page":"SystemSolvers","title":"Linear solvers","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#Generalized-Conjugate-Residual-Method","page":"SystemSolvers","title":"Generalized Conjugate Residual Method","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"GeneralizedConjugateResidual","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.GeneralizedConjugateResidual","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.GeneralizedConjugateResidual","text":"GeneralizedConjugateResidual(K, Q; rtol, atol)\n\nConjugate Residual\n\nThis is an object for solving linear systems using an iterative Krylov method. The constructor parameter K is the number of steps after which the algorithm is restarted (if it has not converged), Q is a reference state used only to allocate the solver internal state, and tolerance specifies the convergence criterion based on the relative residual norm. The amount of memory required by the solver state is roughly (2K + 2) * size(Q). This object is intended to be passed to the linearsolve! command.\n\nThis uses the restarted Generalized Conjugate Residual method of Eisenstat (1983).\n\nReferences\n\n@article{eisenstat1983variational,\n  title={Variational iterative methods for nonsymmetric systems of linear equations},\n  author={Eisenstat, Stanley C and Elman, Howard C and Schultz, Martin H},\n  journal={SIAM Journal on Numerical Analysis},\n  volume={20},\n  number={2},\n  pages={345--357},\n  year={1983},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#Generalized-Minimal-Residual-Method","page":"SystemSolvers","title":"Generalized Minimal Residual Method","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"GeneralizedMinimalResidual","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.GeneralizedMinimalResidual","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.GeneralizedMinimalResidual","text":"GeneralizedMinimalResidual(Q; M, rtol, atol)\n\nGMRES\n\nThis is an object for solving linear systems using an iterative Krylov method. The constructor parameter M is the number of steps after which the algorithm is restarted (if it has not converged), Q is a reference state used only to allocate the solver internal state, and rtol specifies the convergence criterion based on the relative residual norm. The amount of memory required for the solver state is roughly (M + 1) * size(Q). This object is intended to be passed to the linearsolve! command.\n\nThis uses the restarted Generalized Minimal Residual method of Saad and Schultz (1986).\n\nReferences\n\n@article{saad1986gmres,\n  title={GMRES: A generalized minimal residual algorithm for solving nonsymmetric linear systems},\n  author={Saad, Youcef and Schultz, Martin H},\n  journal={SIAM Journal on scientific and statistical computing},\n  volume={7},\n  number={3},\n  pages={856--869},\n  year={1986},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#Batched-Generalized-Minimal-Residual-Method","page":"SystemSolvers","title":"Batched Generalized Minimal Residual Method","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"BatchedGeneralizedMinimalResidual","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.BatchedGeneralizedMinimalResidual","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.BatchedGeneralizedMinimalResidual","text":"BatchedGeneralizedMinimalResidual(\n    Q,\n    dofperbatch,\n    Nbatch;\n    M = min(20, length(Q)),\n    rtol = √eps(eltype(AT)),\n    atol = eps(eltype(AT)),\n    forward_reshape = size(Q),\n    forward_permute = Tuple(1:length(size(Q))),\n)\n\nBGMRES\n\nThis is an object for solving batched linear systems using the GMRES algorithm. The constructor parameter M is the number of steps after which the algorithm is restarted (if it has not converged), Q is a reference state used only to allocate the solver internal state, dofperbatch is the size of each batched system (assumed to be the same throughout), Nbatch is the total number of independent linear systems, and rtol specifies the convergence criterion based on the relative residual norm (max across all batched systems). The argument forward_reshape is a tuple of integers denoting the reshaping (if required) of the solution vectors for batching the Arnoldi routines. The argument forward_permute describes precisely which indices of the array Q to permute. This object is intended to be passed to the linearsolve! command.\n\nThis uses a batched-version of the restarted Generalized Minimal Residual method of Saad and Schultz (1986).\n\nNote\n\nEventually, we'll want to do something like this:\n\ni = @index(Global)\nlinearoperator!(Q[:, :, :, i], args...)\n\nThis will help stop the need for constantly reshaping the work arrays. It would also potentially save us some memory.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#Conjugate-Gradient-Solver-Method","page":"SystemSolvers","title":"Conjugate Gradient Solver Method","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"ConjugateGradient\ninitialize!\ndoiteration!","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.ConjugateGradient","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.ConjugateGradient","text":"ConjugateGradient(\n    Q::AT;\n    rtol = eps(eltype(Q)),\n    atol = eps(eltype(Q)),\n    max_iter = length(Q),\n    dims = :,\n    reshape_tuple = size(Q),\n) where {AT}\n\nConjugateGradient\n\nDescription\n\nOuter constructor for the ConjugateGradient struct\n\nArguments\n\nQ:(array). The kind of object that linearoperator! acts on.\n\nKeyword Arguments\n\nrtol: (float). relative tolerance\natol: (float). absolute tolerance\ndims: (tuple or : ). the dimensions to reduce over\nreshape_tuple: (tuple). the dimensions that the conjugate gradient solver operators over\n\nComment\n\nThe reshape tuple is necessary in case the linearoperator! is defined over vectors of a different size as compared to what plays nicely with the dimension reduction in the ConjugateGradient. It also allows the user to define preconditioners over arrays that are more convenienently shaped.\n\nReturn\n\nConjugateGradient struct\n\n\n\n\n\nConjugateGradient(\n    Q::MPIStateArray;\n    rtol = eps(eltype(Q)),\n    atol = eps(eltype(Q)),\n    max_iter = length(Q),\n    dims = :,\n    reshape_tuple = size(Q),\n)\n\nDescription\n\nOuter constructor for the ConjugateGradient struct with MPIStateArrays. THIS IS A HACK DUE TO RESHAPE FUNCTIONALITY ON MPISTATEARRAYS.\n\nArguments\n\nQ:(array). The kind of object that linearoperator! acts on.\n\nKeyword Arguments\n\nrtol: (float). relative tolerance\natol: (float). absolute tolerance\ndims: (tuple or : ). the dimensions to reduce over\nreshape_tuple: (tuple). the dimensions that the conjugate gradient solver operators over\n\nComment\n\nThe reshape tuple is necessary in case the linearoperator! is defined over vectors of a different size as compared to what plays nicely with the dimension reduction in the ConjugateGradient. It also allows the user to define preconditioners over arrays that are more convenienently shaped.\n\nReturn\n\nConjugateGradient struct\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.initialize!","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.initialize!","text":"initialize!(\n    linearoperator!,\n    Q,\n    Qrhs,\n    solver::ConjugateGradient,\n    args...,\n)\n\nDescription\n\nThis function initializes the iterative solver. It is called as part of the AbstractIterativeSystemSolver routine. SEE CODEREF for documentation on AbstractIterativeSystemSolver\n\nArguments\n\nlinearoperator!: (function). This applies the predefined linear operator on an array. Applies a linear operator to object \"y\" and overwrites object \"z\". The function argument i s linearoperator!(z,y, args...) and it returns nothing.\nQ: (array). This is an object that linearoperator! outputs\nQrhs: (array). This is an object that linearoperator! acts on\nsolver: (struct). This is a scruct for dispatch, in this case for ColumnwisePreconditionedConjugateGradient\nargs...: (arbitrary). This is optional arguments that can be passed into linearoperator! function.\n\nKeyword Arguments\n\nThere are no keyword arguments\n\nReturn\n\nconverged: (bool). A boolean to say whether or not the iterative solver has converged.\nthreshold: (float). The value of the residual for the first timestep\n\nComment\n\nThis function does nothing for conjugate gradient\n\n\n\n\n\nJacobianFreeNewtonKrylovSolver initialize the residual\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.doiteration!","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.doiteration!","text":"doiteration!(\n    linearoperator!,\n    preconditioner,\n    Q,\n    Qrhs,\n    solver::ConjugateGradient,\n    threshold,\n    args...;\n    applyPC! = (x, y) -> x .= y,\n)\n\nDescription\n\nThis function enacts the iterative solver. It is called as part of the AbstractIterativeSystemSolver routine. SEE CODEREF for documentation on AbstractIterativeSystemSolver\n\nArguments\n\nlinearoperator!: (function). This applies the predefined linear operator on an array. Applies a linear operator to object \"y\" and overwrites object \"z\". It is a function with arguments linearoperator!(z,y, args...), where \"z\" gets overwritten by \"y\" and \"args...\" are additional arguments passed to the linear operator. The linear operator is assumed to return nothing.\nQ: (array). This is an object that linearoperator! overwrites\nQrhs: (array). This is an object that linearoperator! acts on. This is the rhs to the linear system\nsolver: (struct). This is a scruct for dispatch, in this case for ConjugateGradient\nthreshold: (float). Either an absolute or relative tolerance\napplyPC!: (function). Applies a preconditioner to objecy \"y\" and overwrites object \"z\". applyPC!(z,y)\nargs...: (arbitrary). This is necessary for the linearoperator! function which has a signature linearoperator!(b, x, args....)\n\nKeyword Arguments\n\nThere are no keyword arguments\n\nReturn\n\nconverged: (bool). A boolean to say whether or not the iterative solver has converged.\niteration: (int). Iteration number for the iterative solver\nthreshold: (float). The value of the residual for the first timestep\n\nComment\n\nThis function does conjugate gradient\n\n\n\n\n\ndoiteration!(\n    linearoperator!,\n    preconditioner,\n    Q::MPIStateArray,\n    Qrhs::MPIStateArray,\n    solver::ConjugateGradient,\n    threshold,\n    args...;\n    applyPC! = (x, y) -> x .= y,\n)\n\nDescription\n\nThis function enacts the iterative solver. It is called as part of the AbstractIterativeSystemSolver routine. SEE CODEREF for documentation on AbstractIterativeSystemSolver. THIS IS A HACK TO WORK WITH MPISTATEARRAYS. THE ISSUE IS WITH RESHAPE.\n\nArguments\n\nlinearoperator!: (function). This applies the predefined linear operator on an array. Applies a linear operator to object \"y\" and overwrites object \"z\". It is a function with arguments linearoperator!(z,y, args...), where \"z\" gets overwritten by \"y\" and \"args...\" are additional arguments passed to the linear operator. The linear operator is assumed to return nothing.\nQ: (array). This is an object that linearoperator! overwrites\nQrhs: (array). This is an object that linearoperator! acts on. This is the rhs to the linear system\nsolver: (struct). This is a scruct for dispatch, in this case for ConjugateGradient\nthreshold: (float). Either an absolute or relative tolerance\napplyPC!: (function). Applies a preconditioner to objecy \"y\" and overwrites object \"z\". applyPC!(z,y)\nargs...: (arbitrary). This is necessary for the linearoperator! function which has a signature linearoperator!(b, x, args....)\n\nKeyword Arguments\n\nThere are no keyword arguments\n\nReturn\n\nconverged: (bool). A boolean to say whether or not the iterative solver has converged.\niteration: (int). Iteration number for the iterative solver\nthreshold: (float). The value of the residual for the first timestep\n\nComment\n\nThis function does conjugate gradient\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#LU-Decomposition","page":"SystemSolvers","title":"LU Decomposition","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"ManyColumnLU\nSingleColumnLU","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.ManyColumnLU","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.ManyColumnLU","text":"ManyColumnLU()\n\nThis solver is used for systems that are block diagonal where each block is associated with a column of the mesh.  The systems are solved using a non-pivoted LU factorization.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.SingleColumnLU","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.SingleColumnLU","text":"SingleColumnLU()\n\nThis solver is used for systems that are block diagonal where each block is associated with a column of the mesh.  Moreover, each block is assumed to be the same.  The systems are solved using a non-pivoted LU factorization.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#Preconditioners","page":"SystemSolvers","title":"Preconditioners","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"NoPreconditioner\nColumnwiseLUPreconditioner","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.NoPreconditioner","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.NoPreconditioner","text":"mutable struct NoPreconditioner end\n\nDo nothing\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.ColumnwiseLUPreconditioner","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.ColumnwiseLUPreconditioner","text":"mutable struct ColumnwiseLUPreconditioner{AT}     A::DGColumnBandedMatrix     Q::AT     PQ::AT     counter::Int     update_freq::Int end\n\n...\n\nArguments\n\nA: the lu factor of the precondition (approximated Jacobian), in the DGColumnBandedMatrix format\nQ: MPIArray container, used to update A\nPQ: MPIArray container, used to update A\ncounter: count the number of Newton, when counter > update_freq or counter < 0, update precondition\nupdate_freq: preconditioner update frequency\n\n...\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#Shared-components","page":"SystemSolvers","title":"Shared components","text":"","category":"section"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/","page":"SystemSolvers","title":"SystemSolvers","text":"AbstractSystemSolver\nAbstractNonlinearSolver\nAbstractIterativeSystemSolver\nAbstractPreconditioner\nnonlinearsolve!\nlinearsolve!\nsettolerance!\nprefactorize\npreconditioner_update!\npreconditioner_solve!\npreconditioner_counter_update!","category":"page"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.AbstractSystemSolver","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.AbstractSystemSolver","text":"AbstractSystemSolver\n\nThis is an abstract type representing a generic linear solver.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.AbstractNonlinearSolver","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.AbstractNonlinearSolver","text":"AbstractNonlinearSolver\n\nThis is an abstract type representing a generic nonlinear solver.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.AbstractIterativeSystemSolver","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.AbstractIterativeSystemSolver","text":"AbstractIterativeSystemSolver\n\nThis is an abstract type representing a generic iterative linear solver.\n\nThe available concrete implementations are:\n\nGeneralizedConjugateResidual\nGeneralizedMinimalResidual\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.AbstractPreconditioner","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.AbstractPreconditioner","text":"Abstract base type for all preconditioners.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.nonlinearsolve!","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.nonlinearsolve!","text":"Solving rhs!(Q) = Qrhs via Newton,\n\nwhere F = rhs!(Q) - Qrhs\n\ndF/dQ(Q^n) ΔQ ≈ jvp!(ΔQ;  Q^n, F(Q^n))\n\npreconditioner ≈ dF/dQ(Q)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.linearsolve!","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.linearsolve!","text":"linearsolve!(linearoperator!, solver::AbstractIterativeSystemSolver, Q, Qrhs, args...)\n\nSolves a linear problem defined by the linearoperator! function and the state Qrhs, i.e,\n\nL(Q) = Q_rhs\n\nusing the solver and the initial guess Q. After the call Q contains the solution.  The arguments args is passed to linearoperator! when it is called.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.settolerance!","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.settolerance!","text":"settolerance!(solver::AbstractIterativeSystemSolver, tolerance, relative)\n\nSets the relative or absolute tolerance of the iterative linear solver solver to tolerance.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.prefactorize","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.prefactorize","text":"prefactorize(linop!, linearsolver, args...)\n\nPrefactorize the in-place linear operator linop! for use with linearsolver.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.preconditioner_update!","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.preconditioner_update!","text":"Do nothing, when there is no preconditioner, preconditioner = Nothing\n\n\n\n\n\nupdate the DGColumnBandedMatrix by the finite difference approximation ...\n\nArguments\n\nop: operator used to compute the finte difference information\ndg: the DG model, use only the grid information\n\n...\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.preconditioner_solve!","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.preconditioner_solve!","text":"Do nothing, when there is no preconditioner, preconditioner = Nothing\n\n\n\n\n\nInplace applying the preconditioner\n\nQ = P⁻¹ * Q\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/SystemSolvers/SystemSolvers/#ClimateMachine.SystemSolvers.preconditioner_counter_update!","page":"SystemSolvers","title":"ClimateMachine.SystemSolvers.preconditioner_counter_update!","text":"Do nothing, when there is no preconditioner, preconditioner = Nothing\n\n\n\n\n\nUpdate the preconditioner counter, after each Newton iteration\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/TurbulenceConvection/#Turbulence-Convection","page":"Turbulence Convection","title":"Turbulence Convection","text":"","category":"section"},{"location":"APIs/Common/TurbulenceConvection/","page":"Turbulence Convection","title":"Turbulence Convection","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Common/TurbulenceConvection/","page":"Turbulence Convection","title":"Turbulence Convection","text":"TurbulenceConvection","category":"page"},{"location":"APIs/Common/TurbulenceConvection/#ClimateMachine.TurbulenceConvection","page":"Turbulence Convection","title":"ClimateMachine.TurbulenceConvection","text":"TurbulenceConvection\n\nTurbulence convection models, for example the Eddy-Diffusivity Mass-Flux model\n\n\n\n\n\n","category":"module"},{"location":"APIs/Common/TurbulenceConvection/#Models","page":"Turbulence Convection","title":"Models","text":"","category":"section"},{"location":"APIs/Common/TurbulenceConvection/","page":"Turbulence Convection","title":"Turbulence Convection","text":"TurbulenceConvection.NoTurbConv","category":"page"},{"location":"APIs/Common/TurbulenceConvection/#ClimateMachine.TurbulenceConvection.NoTurbConv","page":"Turbulence Convection","title":"ClimateMachine.TurbulenceConvection.NoTurbConv","text":"NoTurbConv <: TurbulenceConvectionModel\n\nA \"no model\" type, which results in kernels that pass through and do nothing.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceConvection/#Boundary-conditions","page":"Turbulence Convection","title":"Boundary conditions","text":"","category":"section"},{"location":"APIs/Common/TurbulenceConvection/","page":"Turbulence Convection","title":"Turbulence Convection","text":"TurbulenceConvection.NoTurbConvBC","category":"page"},{"location":"APIs/Common/TurbulenceConvection/#ClimateMachine.TurbulenceConvection.NoTurbConvBC","page":"Turbulence Convection","title":"ClimateMachine.TurbulenceConvection.NoTurbConvBC","text":"NoTurbConvBC <: TurbConvBC\n\nBoundary conditions are not applied\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Thermodynamics/#Thermodynamics","page":"Thermodynamics","title":"Thermodynamics","text":"","category":"section"},{"location":"APIs/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"CurrentModule = ClimateMachine.Thermodynamics","category":"page"},{"location":"APIs/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"Thermodynamics","category":"page"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics","text":"Thermodynamics\n\nMoist thermodynamic functions, e.g., for air pressure (atmosphere equation of state), latent heats of phase transitions, saturation vapor pressures, and saturation specific humidities.\n\nAbstractParameterSet's\n\nMany functions defined in this module rely on CLIMAParameters.jl. CLIMAParameters.jl defines several functions (e.g., many planet parameters). For example, to compute the mole-mass ratio:\n\nusing CLIMAParameters.Planet: molmass_ratio\nusing CLIMAParameters: AbstractEarthParameterSet\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nparam_set = EarthParameterSet()\n_molmass_ratio = molmass_ratio(param_set)\n\nBecause these parameters are widely used throughout this module, param_set is an argument for many Thermodynamics functions.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Common/Thermodynamics/#Thermodynamic-State-Constructors","page":"Thermodynamics","title":"Thermodynamic State Constructors","text":"","category":"section"},{"location":"APIs/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"PhasePartition\nPhasePartition_equil\nThermodynamicState\nPhaseDry\nPhaseDry_pT\nPhaseDry_pθ\nPhaseDry_ρT\nPhaseEquil\nPhaseEquil_ρTq\nPhaseEquil_pTq\nPhaseEquil_pθq\nPhaseEquil_ρθq\nPhaseNonEquil\nPhaseNonEquil_ρTq\nPhaseNonEquil_ρθq\nPhaseNonEquil_pθq","category":"page"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhasePartition","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhasePartition","text":"PhasePartition\n\nRepresents the mass fractions of the moist air mixture.\n\nConstructors\n\nPhasePartition(q_tot::Real[, q_liq::Real[, q_ice::Real]])\nPhasePartition(ts::ThermodynamicState)\n\nSee also PhasePartition_equil\n\nFields\n\ntot\ntotal specific humidity\nliq\nliquid water specific humidity (default: 0)\nice\nice specific humidity (default: 0)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhasePartition_equil","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhasePartition_equil","text":"PhasePartition_equil(param_set, T, ρ, q_tot, phase_type)\n\nPartition the phases in equilibrium, returning a PhasePartition object using the liquid_fraction function where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\nphase_type a thermodynamic state type\n\nThe residual q.tot - q.liq - q.ice is the vapor specific humidity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.ThermodynamicState","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.ThermodynamicState","text":"ThermodynamicState{FT}\n\nA thermodynamic state, which can be initialized for various thermodynamic formulations (via its sub-types). All ThermodynamicState's have access to functions to compute all other thermodynamic properties.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseDry","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseDry","text":"PhaseDry{FT} <: ThermodynamicState\n\nA dry thermodynamic state (q_tot = 0).\n\nConstructors\n\nPhaseDry(param_set, e_int, ρ)\n\nFields\n\nparam_set\nparameter set, used to dispatch planet parameter function calls\ne_int\ninternal energy\nρ\ndensity of dry air\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseDry_pT","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseDry_pT","text":"PhaseDry_pT(param_set, p, T)\n\nConstructs a PhaseDry thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\np pressure\nT temperature\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseDry_pθ","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseDry_pθ","text":"PhaseDry_pθ(param_set, p, θ_dry)\n\nConstructs a PhaseDry thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\np pressure\nθ_dry dry potential temperature\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseDry_ρT","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseDry_ρT","text":"PhaseDry_ρT(param_set, ρ, T)\n\nConstructs a PhaseDry thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nρ density\nT temperature\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseEquil","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseEquil","text":"PhaseEquil{FT} <: ThermodynamicState\n\nA thermodynamic state assuming thermodynamic equilibrium (therefore, saturation adjustment may be needed).\n\nConstructors\n\nPhaseEquil(param_set, e_int, ρ, q_tot)\n\nFields\n\nparam_set\nparameter set, used to dispatch planet parameter function calls\ne_int\ninternal energy\nρ\ndensity of air (potentially moist)\nq_tot\ntotal specific humidity\nT\ntemperature: computed via saturation_adjustment\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseEquil_ρTq","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseEquil_ρTq","text":"PhaseEquil_ρTq(param_set, ρ, T, q_tot)\n\nConstructs a PhaseEquil thermodynamic state from temperature.\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nρ density\nT temperature\nq_tot total specific humidity\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseEquil_pTq","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseEquil_pTq","text":"PhaseEquil_pTq(param_set, p, T, q_tot)\n\nConstructs a PhaseEquil thermodynamic state from temperature.\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\np pressure\nT temperature\nq_tot total specific humidity\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseEquil_pθq","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseEquil_pθq","text":"PhaseEquil_pθq(param_set, p, θ_liq_ice, q_tot)\n\nConstructs a PhaseEquil thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\np pressure\nθ_liq_ice liquid-ice potential temperature\nq_tot total specific humidity\ntemperature_tol temperature tolerance for saturation adjustment\nmaxiter maximum iterations for saturation adjustment\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseEquil_ρθq","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseEquil_ρθq","text":"PhaseEquil_ρθq(param_set, ρ, θ_liq_ice, q_tot)\n\nConstructs a PhaseEquil thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nρ (moist-)air density\nθ_liq_ice liquid-ice potential temperature\nq_tot total specific humidity\ntemperature_tol temperature tolerance for saturation adjustment\nmaxiter maximum iterations for saturation adjustment\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseNonEquil","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseNonEquil","text":"PhaseNonEquil{FT} <: ThermodynamicState\n\nA thermodynamic state assuming thermodynamic non-equilibrium (therefore, temperature can be computed directly).\n\nConstructors\n\nPhaseNonEquil(param_set, e_int, q::PhasePartition, ρ)\n\nFields\n\nparam_set\nparameter set, used to dispatch planet parameter function calls\ne_int\ninternal energy\nρ\ndensity of air (potentially moist)\nq\nphase partition\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseNonEquil_ρTq","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseNonEquil_ρTq","text":"PhaseNonEquil_ρTq(param_set, ρ, T, q_pt)\n\nConstructs a PhaseNonEquil thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nρ (moist-)air density\nT temperature\nq_pt phase partition\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseNonEquil_ρθq","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseNonEquil_ρθq","text":"PhaseNonEquil_ρθq(param_set, ρ, θ_liq_ice, q_pt)\n\nConstructs a PhaseNonEquil thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nρ (moist-)air density\nθ_liq_ice liquid-ice potential temperature\nq_pt phase partition\n\nand, optionally\n\npotential_temperature_tol potential temperature for non-linear equation solve\nmaxiter maximum iterations for non-linear equation solve\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.PhaseNonEquil_pθq","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.PhaseNonEquil_pθq","text":"PhaseNonEquil_pθq(param_set, p, θ_liq_ice, q_pt)\n\nConstructs a PhaseNonEquil thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\np pressure\nθ_liq_ice liquid-ice potential temperature\nq_pt phase partition\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#Thermodynamic-state-methods","page":"Thermodynamics","title":"Thermodynamic state methods","text":"","category":"section"},{"location":"APIs/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"air_density\nair_pressure\nair_temperature\ncondensate\ncp_m\ncv_m\ndry_pottemp\nexner\ngas_constant_air\ngas_constants\nhas_condensate\nIce\nice_specific_humidity\ninternal_energy\ninternal_energy_sat\nlatent_heat_fusion\nlatent_heat_liq_ice\nlatent_heat_sublim\nlatent_heat_vapor\nLiquid\nliquid_fraction\nliquid_ice_pottemp\nliquid_ice_pottemp_sat\nliquid_specific_humidity\nmoist_static_energy\nq_vap_saturation\nq_vap_saturation_liquid\nq_vap_saturation_ice\nq_vap_saturation_generic\nrelative_humidity\nsaturated\nsaturation_adjustment\nsaturation_excess\nsaturation_vapor_pressure\nsoundspeed_air\nspecific_enthalpy\nspecific_volume\nsupersaturation\ntotal_energy\ntotal_specific_enthalpy\ntotal_specific_humidity\nvapor_specific_humidity\nvirtual_pottemp\nvirtual_temperature","category":"page"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.air_density","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.air_density","text":"air_density(param_set, T, p[, q::PhasePartition])\n\nThe (moist-)air density from the equation of state (ideal gas law) where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT air temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nair_density(ts::ThermodynamicState)\n\nThe (moist-)air density, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.air_pressure","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.air_pressure","text":"air_pressure(param_set, T, ρ[, q::PhasePartition])\n\nThe air pressure from the equation of state (ideal gas law) where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT air temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nair_pressure(ts::ThermodynamicState)\n\nThe air pressure from the equation of state (ideal gas law), given a thermodynamic state ts.\n\n\n\n\n\nair_pressure(param_set, T::FT, T∞::FT, p∞::FT, ::DryAdiabaticProcess)\n\nThe air pressure for an isentropic process, where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nT∞ ambient temperature\np∞ ambient pressure\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.air_temperature","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.air_temperature","text":"air_temperature(param_set, e_int, q::PhasePartition)\n\nThe air temperature, where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\ne_int internal energy per unit mass\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nair_temperature(ts::ThermodynamicState)\n\nThe air temperature, given a thermodynamic state ts.\n\n\n\n\n\nair_temperature(param_set, p::FT, θ::FT, Φ::FT, ::DryAdiabaticProcess)\n\nThe air temperature for an isentropic process, where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\np pressure\nθ potential temperature\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.condensate","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.condensate","text":"condensate(q::PhasePartition{FT})\ncondensate(ts::ThermodynamicState)\n\nCondensate of the phase partition.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.cp_m","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.cp_m","text":"cp_m(param_set, [q::PhasePartition])\n\nThe isobaric specific heat capacity of moist air given\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\n\nand, optionally\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ncp_m(ts::ThermodynamicState)\n\nThe isobaric specific heat capacity of moist air, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.cv_m","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.cv_m","text":"cv_m(param_set, [q::PhasePartition])\n\nThe isochoric specific heat capacity of moist air given\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\n\nand, optionally\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ncv_m(ts::ThermodynamicState)\n\nThe isochoric specific heat capacity of moist air, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.dry_pottemp","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.dry_pottemp","text":"dry_pottemp(param_set, T, ρ[, q::PhasePartition])\n\nThe dry potential temperature where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\n\n\ndry_pottemp(ts::ThermodynamicState)\n\nThe dry potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.exner","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.exner","text":"exner(param_set, T, ρ[, q::PhasePartition)])\n\nThe Exner function where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nexner(ts::ThermodynamicState)\n\nThe Exner function, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.gas_constant_air","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.gas_constant_air","text":"gas_constant_air(param_set, [q::PhasePartition])\n\nThe specific gas constant of moist air given\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ngas_constant_air(ts::ThermodynamicState)\n\nThe specific gas constant of moist air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.gas_constants","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.gas_constants","text":"(R_m, cp_m, cv_m, γ_m) = gas_constants(param_set, [q::PhasePartition])\n\nWrapper to compute all gas constants at once, where optionally,\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nq PhasePartition. Without this argument, the results are for dry air.\n\nThe function returns a tuple of\n\nR_m gas_constant_air\ncp_m cp_m\ncv_m cv_m\nγ_m = cp_m/cv_m\n\n\n\n\n\n(R_m, cp_m, cv_m, γ_m) = gas_constants(ts::ThermodynamicState)\n\nWrapper to compute all gas constants at once, given a thermodynamic state ts.\n\nThe function returns a tuple of\n\nR_m gas_constant_air\ncp_m cp_m\ncv_m cv_m\nγ_m = cp_m/cv_m\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.has_condensate","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.has_condensate","text":"has_condensate(q::PhasePartition{FT})\nhas_condensate(ts::ThermodynamicState)\n\nBool indicating if condensate exists in the phase partition\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.Ice","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.Ice","text":"Ice <: Phase\n\nAn ice phase, to dispatch over saturation_vapor_pressure and q_vap_saturation_generic.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.ice_specific_humidity","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.ice_specific_humidity","text":"ice_specific_humidity(ts::ThermodynamicState)\nice_specific_humidity(q::PhasePartition)\n\nIce specific humidity given\n\nts a thermodynamic state\n\nor\n\nq a PhasePartition\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.internal_energy","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.internal_energy","text":"internal_energy(param_set, T[, q::PhasePartition])\n\nThe internal energy per unit mass, given a thermodynamic state ts or\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ninternal_energy(ts::ThermodynamicState)\n\nThe internal energy per unit mass, given a thermodynamic state ts.\n\n\n\n\n\ninternal_energy(ρ::FT, ρe::FT, ρu::AbstractVector{FT}, e_pot::FT)\n\nThe internal energy per unit mass, given\n\nρ (moist-)air density\nρe total energy per unit volume\nρu momentum vector\ne_pot potential energy (e.g., gravitational) per unit mass\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.internal_energy_sat","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.internal_energy_sat","text":"internal_energy_sat(param_set, T, ρ, q_tot, phase_type)\n\nThe internal energy per unit mass in thermodynamic equilibrium at saturation where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\nphase_type a thermodynamic state type\n\n\n\n\n\ninternal_energy_sat(ts::ThermodynamicState)\n\nThe internal energy per unit mass in thermodynamic equilibrium at saturation, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.latent_heat_fusion","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.latent_heat_fusion","text":"latent_heat_fusion(param_set, T::FT) where {FT<:Real}\n\nThe specific latent heat of fusion where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\n\n\n\n\n\nlatent_heat_fusion(ts::ThermodynamicState)\n\nThe specific latent heat of fusion given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.latent_heat_liq_ice","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.latent_heat_liq_ice","text":"latent_heat_liq_ice(param_set, q::PhasePartition{FT})\n\nEffective latent heat of condensate (weighted sum of liquid and ice), with specific latent heat evaluated at reference temperature T_0 given\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.latent_heat_sublim","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.latent_heat_sublim","text":"latent_heat_sublim(param_set, T::FT) where {FT<:Real}\n\nThe specific latent heat of sublimation where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\n\n\n\n\n\nlatent_heat_sublim(ts::ThermodynamicState)\n\nThe specific latent heat of sublimation given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.latent_heat_vapor","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.latent_heat_vapor","text":"latent_heat_vapor(param_set, T::FT) where {FT<:Real}\n\nThe specific latent heat of vaporization where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\n\n\n\n\n\nlatent_heat_vapor(ts::ThermodynamicState)\n\nThe specific latent heat of vaporization given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.Liquid","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.Liquid","text":"Liquid <: Phase\n\nA liquid phase, to dispatch over saturation_vapor_pressure and q_vap_saturation_generic.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.liquid_fraction","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.liquid_fraction","text":"liquid_fraction(param_set, T, phase_type[, q])\n\nThe fraction of condensate that is liquid where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nphase_type a thermodynamic state type\n\nPhaseNonEquil behavior\n\nIf q.liq or q.ice are nonzero, the liquid fraction is computed from them.\n\nThermodynamicState\n\nOtherwise, phase equilibrium is assumed so that the fraction of liquid is a function that is 1 above T_freeze and goes to zero below T_freeze.\n\n\n\n\n\nliquid_fraction(ts::ThermodynamicState)\n\nThe fraction of condensate that is liquid given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.liquid_ice_pottemp","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.liquid_ice_pottemp","text":"liquid_ice_pottemp(param_set, T, ρ, q::PhasePartition)\n\nThe liquid-ice potential temperature where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nliquid_ice_pottemp(ts::ThermodynamicState)\n\nThe liquid-ice potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.liquid_ice_pottemp_sat","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.liquid_ice_pottemp_sat","text":"liquid_ice_pottemp_sat(param_set, T, ρ, phase_type[, q::PhasePartition])\n\nThe saturated liquid ice potential temperature where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\nphase_type a thermodynamic state type\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nliquid_ice_pottemp_sat(param_set, T, ρ, phase_type, q_tot)\n\nThe saturated liquid ice potential temperature where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\nphase_type a thermodynamic state type\nq_tot total specific humidity\n\n\n\n\n\nliquid_ice_pottemp_sat(ts::ThermodynamicState)\n\nThe liquid potential temperature given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.liquid_specific_humidity","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.liquid_specific_humidity","text":"liquid_specific_humidity(ts::ThermodynamicState)\nliquid_specific_humidity(q::PhasePartition)\n\nLiquid specific humidity given\n\nts a thermodynamic state\n\nor\n\nq a PhasePartition\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.moist_static_energy","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.moist_static_energy","text":"moist_static_energy(ts, e_pot)\n\nMoist static energy, given\n\nts a thermodynamic state\ne_pot potential energy (e.g., gravitational) per unit mass\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.q_vap_saturation","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.q_vap_saturation","text":"q_vap_saturation(param_set, T, ρ, phase_type[, q::PhasePartition])\n\nCompute the saturation specific humidity, given\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\nphase_type a thermodynamic state type\n\nand, optionally,\n\nq PhasePartition\n\nIf the PhasePartition q is given, the saturation specific humidity is that of a mixture of liquid and ice, computed in a thermodynamically consistent way from the weighted sum of the latent heats of the respective phase transitions (Pressel et al., JAMES, 2015). That is, the saturation vapor pressure and from it the saturation specific humidity are computed from a weighted mean of the latent heats of vaporization and sublimation, with the weights given by the fractions of condensates q.liq/(q.liq + q.ice) and q.ice/(q.liq + q.ice) that are liquid and ice, respectively.\n\nIf the PhasePartition q is not given, or has zero liquid and ice specific humidities, the saturation specific humidity is that over a mixture of liquid and ice, with the fraction of liquid given by temperature dependent liquid_fraction(param_set, T, phase_type) and the fraction of ice by the complement 1 - liquid_fraction(param_set, T, phase_type).\n\n\n\n\n\nq_vap_saturation(ts::ThermodynamicState)\n\nCompute the saturation specific humidity, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.q_vap_saturation_liquid","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.q_vap_saturation_liquid","text":"q_vap_saturation_liquid(ts::ThermodynamicState)\n\nCompute the saturation specific humidity over liquid, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.q_vap_saturation_ice","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.q_vap_saturation_ice","text":"q_vap_saturation_ice(ts::ThermodynamicState)\n\nCompute the saturation specific humidity over ice, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.q_vap_saturation_generic","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.q_vap_saturation_generic","text":"q_vap_saturation_generic(param_set, T, ρ[, phase=Liquid()])\n\nCompute the saturation specific humidity over a plane surface of condensate, given\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nLiquid() indicating condensate is liquid\nIce() indicating condensate is ice\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.relative_humidity","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.relative_humidity","text":"relative_humidity(param_set, T, p, phase_type, q::PhasePartition)\n\nThe relative humidity, given\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\np pressure\nphase_type a thermodynamic state type\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\n\n\nrelative_humidity(ts::ThermodynamicState)\n\nThe relative humidity, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.saturated","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.saturated","text":"saturated(ts::ThermodynamicState)\n\nBoolean indicating if thermodynamic state is saturated.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.saturation_adjustment","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.saturation_adjustment","text":"saturation_adjustment(\n    param_set,\n    e_int,\n    ρ,\n    q_tot,\n    phase_type,\n    maxiter,\n    temperature_tol\n)\n\nCompute the temperature that is consistent with\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\ne_int internal energy\nρ (moist-)air density\nq_tot total specific humidity\nphase_type a thermodynamic state type\nmaxiter maximum iterations for non-linear equation solve\ntemperature_tol temperature tolerance\n\nby finding the root of\n\ne_int - internal_energy_sat(param_set, T, ρ, q_tot, phase_type) = 0\n\nusing Newtons method with analytic gradients.\n\nSee also saturation_adjustment.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.saturation_excess","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.saturation_excess","text":"saturation_excess(param_set, T, ρ, phase_type, q::PhasePartition)\n\nThe saturation excess in equilibrium where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\nphase_type a thermodynamic state type\nq PhasePartition\n\nThe saturation excess is the difference between the total specific humidity q.tot and the saturation specific humidity in equilibrium, and it is defined to be nonzero only if this difference is positive.\n\n\n\n\n\nsaturation_excess(ts::ThermodynamicState)\n\nCompute the saturation excess in equilibrium, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.saturation_vapor_pressure","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.saturation_vapor_pressure","text":"saturation_vapor_pressure(param_set, T, Liquid())\n\nReturn the saturation vapor pressure over a plane liquid surface given\n\nT temperature\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nsaturation_vapor_pressure(param_set, T, Ice())\n\nReturn the saturation vapor pressure over a plane ice surface given\n\nT temperature\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nsaturation_vapor_pressure(param_set, T, LH_0, Δcp)\n\nCompute the saturation vapor pressure over a plane surface by integration of the Clausius-Clapeyron relation.\n\nThe Clausius-Clapeyron relation\n\n`dlog(p_v_sat)/dT = [LH_0 + Δcp * (T-T_0)]/(R_v*T^2)`\n\nis integrated from the triple point temperature T_triple, using Kirchhoff's relation\n\n`L = LH_0 + Δcp * (T - T_0)`\n\nfor the specific latent heat L with constant isobaric specific heats of the phases. The linear dependence of the specific latent heat on temperature T allows analytic integration of the Clausius-Clapeyron relation to obtain the saturation vapor pressure p_v_sat as a function of the triple point pressure press_triple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.soundspeed_air","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.soundspeed_air","text":"soundspeed_air(param_set, T[, q::PhasePartition])\n\nThe speed of sound in unstratified air, where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nsoundspeed_air(ts::ThermodynamicState)\n\nThe speed of sound in unstratified air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.specific_enthalpy","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.specific_enthalpy","text":"specific_enthalpy(e_int, R_m, T)\n\nSpecific enthalpy, given\n\ne_int internal specific energy\nR_m gas_constant_air\nT air temperature\n\n\n\n\n\nspecific_enthalpy(ts)\n\nSpecific enthalpy, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.specific_volume","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.specific_volume","text":"specific_volume(ts::ThermodynamicState)\n\nThe (moist-)air specific volume, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.supersaturation","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.supersaturation","text":"supersaturation(param_set, q, ρ, T, Liquid())\nsupersaturation(param_set, q, ρ, T, Ice())\nsupersaturation(ts, Ice())\nsupersaturation(ts, Liquid())\n\nparam_set - abstract set with earth parameters\nq - phase partition\nρ - air density,\nT - air temperature\nLiquid(), Ice() - liquid or ice phase to dispatch over.\nts thermodynamic state\n\nReturns supersaturation (qv/qv_sat -1) over water or ice.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.total_energy","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.total_energy","text":"total_energy(param_set, e_kin, e_pot, T[, q::PhasePartition])\n\nThe total energy per unit mass, given\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\ne_kin kinetic energy per unit mass\ne_pot potential energy per unit mass\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ntotal_energy(e_kin, e_pot, ts::ThermodynamicState)\n\nThe total energy per unit mass given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.total_specific_enthalpy","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.total_specific_enthalpy","text":"total_specific_enthalpy(e_tot, R_m, T)\n\nTotal specific enthalpy, given\n\ne_tot total specific energy\nR_m gas_constant_air\nT air temperature\n\n\n\n\n\ntotal_specific_enthalpy(ts)\n\nTotal specific enthalpy, given\n\ne_tot total specific energy\nts a thermodynamic state\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.total_specific_humidity","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.total_specific_humidity","text":"total_specific_humidity(ts::ThermodynamicState)\ntotal_specific_humidity(param_set, T, p, relative_humidity)\n\nTotal specific humidity given\n\nts a thermodynamic state\n\nor\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\np pressure\nrelative_humidity relative humidity (can exceed 1 when there is super saturation/condensate)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.vapor_specific_humidity","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.vapor_specific_humidity","text":"vapor_specific_humidity(q::PhasePartition{FT})\n\nThe vapor specific humidity, given a PhasePartition q.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.virtual_pottemp","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.virtual_pottemp","text":"virtual_pottemp(param_set, T, ρ[, q::PhasePartition])\n\nThe virtual potential temperature where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nvirtual_pottemp(ts::ThermodynamicState)\n\nThe virtual potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.virtual_temperature","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.virtual_temperature","text":"virtual_temperature(param_set, T, ρ[, q::PhasePartition])\n\nThe virtual temperature where\n\nparam_set an AbstractParameterSet, see the Thermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nvirtual_temperature(ts::ThermodynamicState)\n\nThe virtual temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/Thermodynamics/#Dispatch-types","page":"Thermodynamics","title":"Dispatch types","text":"","category":"section"},{"location":"APIs/Common/Thermodynamics/","page":"Thermodynamics","title":"Thermodynamics","text":"DryAdiabaticProcess","category":"page"},{"location":"APIs/Common/Thermodynamics/#ClimateMachine.Thermodynamics.DryAdiabaticProcess","page":"Thermodynamics","title":"ClimateMachine.Thermodynamics.DryAdiabaticProcess","text":"DryAdiabaticProcess\n\nFor dispatching to isentropic formulas\n\n\n\n\n\n","category":"type"},{"location":"GettingStarted/Terminology/#Terminology","page":"Terminology","title":"Terminology","text":"","category":"section"},{"location":"GettingStarted/Terminology/","page":"Terminology","title":"Terminology","text":"The ClimateMachine documentation uses terminology from several disciplines. Below are some definitions of some of these terms. Please let us know via a github issue if there are other terms that are unclear or confusing to you.","category":"page"},{"location":"GettingStarted/Terminology/#Software-terms","page":"Terminology","title":"Software terms","text":"","category":"section"},{"location":"GettingStarted/Terminology/","page":"Terminology","title":"Terminology","text":"Driver file: a julia script which (a) specifies which BalanceLaw is being used, (b) specifies changes to the default version of that model, (c) specifies initial and boundary conditions, (d) specifies numerical details related to timestep, grid, and frequency of output, and (e) runs the integration. Examples can be found in tutorials and experiments.\nSource file: a julia file containing code involved in implementing the choices made in a driver file. This is where the numerical methods related to solving the equations (e.g. the ODE time steppers, or the creation of the grid) are defined. Users typically only interact with functions defined in source code within a driver file by using arguments to those functions, unless they wish to develop the source code itself.\nKernel: Functions which are launched on the compute device (i.e., the CPU or GPU) and run with an array of workitems or threads. ClimateMachine.jl uses KernelAbstractions.jl as its kernel language.\nCallback: Functions executed by the ODE integrator after each time step; see solve!. This allows the ability to inject custom behavior into the ODE integrators, such as diagnostic output, visualization, and apply filtering to the numerical solution. Several convenience functions exists specifying callback frequency: number of simulation steps, every X simulation time, and every X wall clock seconds. The callback mechanism is inspired by the callback mechanism of DifferentialEquations.jl.","category":"page"},{"location":"GettingStarted/Terminology/#Numerics","page":"Terminology","title":"Numerics","text":"","category":"section"},{"location":"GettingStarted/Terminology/","page":"Terminology","title":"Terminology","text":"Balance Law: The system of PDEs being solved, expressed in a particular form amenable to DG methods. Please see the how-to-guide or the API.\nCourant number: The ratio of the distance sound waves, diffusion, and other physical processes in your model travel or carry information in a timestep, relative to the resolution of your spatial discretization. This can typically be written in terms of physical constants, the grid size, and the time step, and is used for determining stability of ODE time steppers.\nCFL limit: A maximum value for the Courant number in order to guarantee convergence to the true solution. Given a spatial discretization, this determines the maximum timestep that can be used. The value of the CFL limit depends on the ODE solving algorithm used.","category":"page"},{"location":"GettingStarted/Terminology/#Physics","page":"Terminology","title":"Physics","text":"","category":"section"},{"location":"GettingStarted/Terminology/","page":"Terminology","title":"Terminology","text":"Diurnal variation: A periodic variation in Earth processes driven by the rotation of the Earth. Examples include heating of the Earth's surface due to solar radiation, or the semi-diurnal tidal cycle.\nShortwave radiation: This refers to solar radiation, with intensity peaking in the visible part of the spectrum.\nLongwave radiation: This refers to the emitted infrared radiation of the Earth surface or atmosphere.\nAdvection/advective flux: Advection is movement of some material/quantity by the bulk velocity of a fluid. In the BalanceLaw language, the advective flux of a prognostic variable is a first order flux.\nDiffusion/diffusive flux: Diffusion describes a process in which a material or quantity is moved,  or approximated as moved, due to random motion of particles. More generally, a diffusive flux is one generated by a gradient in concentration, temperature, or another quantity. A diffusive flux is a second order flux in the BalanceLaw framework.\nHyperdiffusion: an explicit higher-order flux term representing horizontal diffusion. The ClimateMachine hyperdiffusive flux uses a fourth-order derivative, but it is included in a second order flux. It enforces the flow of enstrophy absorption at the smallest resolution, and models dissipation effects.","category":"page"},{"location":"GettingStarted/Terminology/#Documentation","page":"Terminology","title":"Documentation","text":"","category":"section"},{"location":"GettingStarted/Terminology/","page":"Terminology","title":"Terminology","text":"APIs: This section details the parts of the source code that are visible to users wanting to run models and explains how to interact with and call them. API stands for application programming interface; from Wikipedia, \"It defines the kinds of calls or requests that can be  made, how to make them, the data formats that should be used, the  conventions to follow, etc.\"  \nTutorials: Driver files with concrete examples showing how to run simple land, ocean, and atmosphere models, or how to use certain numerical functions.\nExperiments: Driver files with more complex models. These could be considered the starting point for research; they are not a part of the docs as they are constantly being updated.\nHow-to-guide: Code and explanations for components used in models.","category":"page"},{"location":"APIs/Common/TurbulenceClosures/#TurbulenceClosures","page":"Turbulence Closures","title":"TurbulenceClosures","text":"","category":"section"},{"location":"APIs/Common/TurbulenceClosures/","page":"Turbulence Closures","title":"Turbulence Closures","text":"CurrentModule = ClimateMachine.TurbulenceClosures","category":"page"},{"location":"APIs/Common/TurbulenceClosures/","page":"Turbulence Closures","title":"Turbulence Closures","text":"TurbulenceClosures","category":"page"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures","text":"TurbulenceClosures\n\nFunctions for turbulence, sub-grid scale modelling. These include viscosity terms, diffusivity and stress tensors.\n\nConstantViscosity\nViscousSponge\nSmagorinskyLilly\nVreman\nAnisoMinDiss\n\n\n\n\n\n","category":"module"},{"location":"APIs/Common/TurbulenceClosures/#Turbulence-Closure-Model-Constructors","page":"Turbulence Closures","title":"Turbulence Closure Model Constructors","text":"","category":"section"},{"location":"APIs/Common/TurbulenceClosures/","page":"Turbulence Closures","title":"Turbulence Closures","text":"TurbulenceClosureModel\nWithDivergence\nWithoutDivergence\nConstantViscosity\nConstantDynamicViscosity\nConstantKinematicViscosity\nSmagorinskyLilly\nVreman\nAnisoMinDiss\nHyperDiffusion\nNoHyperDiffusion\nDryBiharmonic\nEquilMoistBiharmonic\nViscousSponge\nNoViscousSponge\nUpperAtmosSponge","category":"page"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.TurbulenceClosureModel","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.TurbulenceClosureModel","text":"Abstract type with default do-nothing behaviour for\n\narbitrary turbulence closure models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.WithDivergence","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.WithDivergence","text":"WithDivergence\n\nA divergence type which includes the divergence term in the momentum flux tensor\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.WithoutDivergence","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.WithoutDivergence","text":"WithoutDivergence\n\nA divergence type which does not include the divergence term in the momentum flux tensor\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.ConstantViscosity","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.ConstantViscosity","text":"ConstantViscosity <: TurbulenceClosureModel\n\nAbstract type for constant viscosity models\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.ConstantDynamicViscosity","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.ConstantDynamicViscosity","text":"ConstantDynamicViscosity <: ConstantViscosity\n\nTurbulence with constant dynamic viscosity (ρν). Divergence terms are included in the momentum flux tensor if divergence_type is WithDivergence.\n\nFields\n\nρν\nDynamic Viscosity [kg/m/s]\ndivergence_type\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.ConstantKinematicViscosity","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.ConstantKinematicViscosity","text":"ConstantKinematicViscosity <: ConstantViscosity\n\nTurbulence with constant kinematic viscosity (ν). Divergence terms are included in the momentum flux tensor if divergence_type is WithDivergence.\n\nFields\n\nν\nKinematic Viscosity [m2/s]\ndivergence_type\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.SmagorinskyLilly","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.SmagorinskyLilly","text":"SmagorinskyLilly <: TurbulenceClosureModel\n\nFields\n\nC_smag\nSmagorinsky Coefficient [dimensionless]\n\nSmagorinsky Model Reference\n\narticle{doi:10.1175/1520-0493(1963)091<0099:GCEWTP>2.3.CO;2,\n  author = {Smagorinksy, J.},\n  title = {General circulation experiments with the primitive equations},\n  journal = {Monthly Weather Review},\n  volume = {91},\n  number = {3},\n  pages = {99-164},\n  year = {1963},\n  doi = {10.1175/1520-0493(1963)091<0099:GCEWTP>2.3.CO;2},\n  URL = {https://doi.org/10.1175/1520-0493(1963)091<0099:GCEWTP>2.3.CO;2},\n  eprint = {https://doi.org/10.1175/1520-0493(1963)091<0099:GCEWTP>2.3.CO;2}\n  }\n\nLilly Model Reference\n\narticle{doi:10.1111/j.2153-3490.1962.tb00128.x,\n  author = {LILLY, D. K.},\n  title = {On the numerical simulation of buoyant convection},\n  journal = {Tellus},\n  volume = {14},\n  number = {2},\n  pages = {148-172},\n  doi = {10.1111/j.2153-3490.1962.tb00128.x},\n  url = {https://onlinelibrary.wiley.com/doi/abs/10.1111/j.2153-3490.1962.tb00128.x},\n  eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.2153-3490.1962.tb00128.x},\n  year = {1962}\n  }\n\nBrunt-Väisälä Frequency Reference\n\nBrunt-Vaisala frequency N² defined as in equation (1b) in\n  Durran, D.R. and J.B. Klemp, 1982:\n  On the Effects of Moisture on the Brunt-Väisälä Frequency.\n  J. Atmos. Sci., 39, 2152–2158,\n  https://doi.org/10.1175/1520-0469(1982)039<2152:OTEOMO>2.0.CO;2\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.Vreman","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.Vreman","text":"Vreman{FT} <: TurbulenceClosureModel\n\nFilter width Δ is the local grid resolution calculated from the mesh metric tensor. A Smagorinsky coefficient is specified and used to compute the equivalent Vreman coefficient.\n\nν_e = √(Bᵦ/(αᵢⱼαᵢⱼ)) where αᵢⱼ = ∂uⱼ∂uᵢ with uᵢ the resolved scale velocity component.\nβij = Δ²αₘᵢαₘⱼ\nBᵦ = β₁₁β₂₂ + β₂₂β₃₃ + β₁₁β₃₃ - β₁₂² - β₁₃² - β₂₃²\n\nβᵢⱼ is symmetric, positive-definite. If Δᵢ = Δ, then β = Δ²αᵀα\n\nFields\n\nC_smag\nSmagorinsky Coefficient [dimensionless]\n\nReference\n\n@article{Vreman2004,\n  title={An eddy-viscosity subgrid-scale model for turbulent shear flow: Algebraic theory and applications},\n  author={Vreman, AW},\n  journal={Physics of fluids},\n  volume={16},\n  number={10},\n  pages={3670--3681},\n  year={2004},\n  publisher={AIP}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.AnisoMinDiss","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.AnisoMinDiss","text":"AnisoMinDiss{FT} <: TurbulenceClosureModel\n\nFilter width Δ is the local grid resolution calculated from the mesh metric tensor. A Poincare coefficient is specified and used to compute the equivalent AnisoMinDiss coefficient (computed as the solution to the eigenvalue problem for the Laplacian operator).\n\nFields\n\nC_poincare\n\nReference\n\n@article{\n    doi:10.1063/1.5037039,\n    author = {Vreugdenhil,Catherine A.  and Taylor,John R. },\n    title = {Large-eddy simulations of stratified plane Couette flow using the anisotropic minimum-dissipation model},\n    journal = {Physics of Fluids},\n    volume = {30},\n    number = {8},\n    pages = {085104},\n    year = {2018},\n    doi = {10.1063/1.5037039},\n    URL = {https://doi.org/10.1063/1.5037039}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.HyperDiffusion","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.HyperDiffusion","text":"Abstract type for Hyperdiffusion models\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.NoHyperDiffusion","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.NoHyperDiffusion","text":"NoHyperDiffusion <: HyperDiffusion Defines a default hyperdiffusion model with zero hyperdiffusive fluxes.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.DryBiharmonic","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.DryBiharmonic","text":"DryBiharmonic{FT} <: HyperDiffusion\n\nAssumes dry compressible flow.  Horizontal hyperdiffusion methods for application in GCM and LES settings Timescales are prescribed by the user while the diffusion coefficient is computed as a function of the grid lengthscale.\n\nFields\n\nτ_timescale\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.EquilMoistBiharmonic","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.EquilMoistBiharmonic","text":"EquilMoistBiharmonic{FT} <: HyperDiffusion\n\nAssumes equilibrium thermodynamics in compressible flow. Horizontal hyperdiffusion methods for application in GCM and LES settings Timescales are prescribed by the user while the diffusion coefficient is computed as a function of the grid lengthscale.\n\nFields\n\nτ_timescale\nτ_timescale_q_tot\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.ViscousSponge","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.ViscousSponge","text":"Abstract type for viscous sponge layers.\n\nModifier for viscosity computed from existing turbulence closures.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.NoViscousSponge","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.NoViscousSponge","text":"NoViscousSponge\n\nNo modifiers applied to viscosity/diffusivity in sponge layer\n\nFields\n\n\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.UpperAtmosSponge","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.UpperAtmosSponge","text":"Upper domain viscous relaxation\n\nApplies modifier to viscosity and diffusivity terms in a user-specified upper domain sponge region\n\nFields\n\n\n\nz_max\nMaximum domain altitude (m)\nz_sponge\nAltitude at with sponge starts (m)\nα_max\nSponge Strength 0 ⩽ α_max ⩽ 1\nγ\nSponge exponent\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/TurbulenceClosures/#Supporting-Methods","page":"Turbulence Closures","title":"Supporting Methods","text":"","category":"section"},{"location":"APIs/Common/TurbulenceClosures/","page":"Turbulence Closures","title":"Turbulence Closures","text":"turbulence_tensors\ninit_aux_turbulence!\nturbulence_nodal_update_auxiliary_state!\nprincipal_invariants\nsymmetrize\nnorm2\nstrain_rate_magnitude","category":"page"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.turbulence_tensors","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.turbulence_tensors","text":"ν, D_t, τ = turbulence_tensors(\n                ::TurbulenceClosureModel,\n                orientation::Orientation,\n                param_set::AbstractParameterSet,\n                state::Vars,\n                diffusive::Vars,\n                aux::Vars,\n                t::Real\n            )\n\nCompute the kinematic viscosity (ν), the diffusivity (D_t) and SGS momentum flux tensor (τ) for a given turbulence closure. Each closure overloads this method with the appropriate calculations for the returned quantities.\n\nArguments\n\n::TurbulenceClosureModel = Struct identifier for turbulence closure model\norientation = BalanceLaw.orientation\nparam_set parameter set\nstate = Array of prognostic (state) variables. See vars_state in BalanceLaw\ndiffusive = Array of diffusive variables\naux = Array of auxiliary variables\nt = time\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.init_aux_turbulence!","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.init_aux_turbulence!","text":"init_aux_turbulence!\n\nInitialise auxiliary variables for turbulence models. Overload for specific turbulence closure type.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.turbulence_nodal_update_auxiliary_state!","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.turbulence_nodal_update_auxiliary_state!","text":"turbulence_nodal_update_auxiliary_state!\n\nUpdate auxiliary variables for turbulence models. Overload for specific turbulence closure type.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.principal_invariants","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.principal_invariants","text":"principal_invariants(X)\n\nCalculates principal invariants of a tensor X. Returns 3 element tuple containing the invariants.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.symmetrize","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.symmetrize","text":"symmetrize(X)\n\nGiven a (3,3) second rank tensor X, compute (X + X')/2, returning a symmetric SHermitianCompact object.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.norm2","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.norm2","text":"norm2(X)\n\nGiven a tensor X, computes X:X.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/TurbulenceClosures/#ClimateMachine.TurbulenceClosures.strain_rate_magnitude","page":"Turbulence Closures","title":"ClimateMachine.TurbulenceClosures.strain_rate_magnitude","text":"strain_rate_magnitude(S)\n\nGiven the rate-of-strain tensor S, computes its magnitude.\n\n\n\n\n\n","category":"function"}]
}
